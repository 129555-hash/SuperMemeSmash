<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Meme Bros: Sprite Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Press+Start+2P&family=Roboto:wght@700&display=swap');
        :root { --p1: #3498db; --p2: #e74c3c; --cpu: #9b59b6; --ult: #f1c40f; --boss: #c0392b; --on: #2ecc71; --off: #e74c3c; --gold: #ffd700; --glitch: #ff00ff; }
        body { margin: 0; background: #111; overflow: hidden; font-family: 'Roboto', sans-serif; color: white; user-select: none; touch-action: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: #000; }
        canvas { display: block; box-shadow: 0 0 50px rgba(0,0,0,0.8); image-rendering: pixelated; image-rendering: crisp-edges; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; background: rgba(0,0,0,0.95); z-index: 10; transition: opacity 0.3s; overflow-y: auto; padding: 20px 0; box-sizing: border-box; }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        h1 { font-family: 'Black Ops One'; font-size: 40px; background: -webkit-linear-gradient(#eee, #999); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 0 0 15px 0; text-align: center; line-height: 1.1; }
        h2 { font-family: 'Press Start 2P'; color: #fff; margin-bottom: 30px; font-size: 20px; }
        .menu-btn { font-family: 'Press Start 2P'; padding: 10px 20px; font-size: 13px; background: transparent; color: white; border: 3px solid white; cursor: pointer; margin: 5px; transition: 0.2s; text-transform: uppercase; }
        .menu-btn:hover { background: white; color: black; transform: scale(1.1); }
        .menu-btn.boss-btn { border-color: var(--boss); color: var(--boss); } .menu-btn.boss-btn:hover { background: var(--boss); color: white; }
        .menu-btn.gold-btn { border-color: var(--gold); color: var(--gold); } .menu-btn.gold-btn:hover { background: var(--gold); color: white; }
        .menu-btn.dojo-btn { border-color: var(--p1); color: var(--p1); } .menu-btn.dojo-btn:hover { background: var(--p1); color: white; }
        .menu-btn.danger-btn { border-color: var(--off); color: var(--off); } .menu-btn.danger-btn:hover { background: var(--off); color: white; }
        #shop-screen { flex-direction: row !important; justify-content: center; align-items: center; padding: 50px; box-sizing: border-box; }
        #shop-container { display: flex; width: 100%; max-width: 1000px; height: 80%; gap: 30px; }
        #shop-left { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        #shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; overflow-y: auto; padding-right: 10px; max-height: 400px; }
        .shop-item { background: #222; border: 2px solid #555; padding: 15px; text-align: center; border-radius: 10px; cursor: pointer; transition: 0.2s; position: relative; }
        .shop-item:hover { border-color: white; transform: scale(1.05); }
        .shop-item.selected { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); background: #332200; }
        .shop-item.bought { border-color: var(--on); opacity: 0.5; pointer-events: none; }
        .shop-item.owned .shop-cost { color: var(--on); }
        #shop-right { flex: 1; background: rgba(255,255,255,0.05); border: 2px solid #fff; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 20px; position: relative; }
        .preview-title { font-family: 'Press Start 2P'; color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .char-cycler { display: flex; align-items: center; gap: 20px; margin-bottom: 20px; font-family: 'Press Start 2P'; font-size: 14px; z-index: 2; }
        .cycle-btn { cursor: pointer; font-size: 20px; user-select: none; }
        .cycle-btn:hover { color: var(--gold); }
        #buy-btn { width: 100%; padding: 20px; font-size: 20px; font-family: 'Black Ops One'; border: none; cursor: pointer; transition: 0.2s; margin-top: auto; z-index: 2; }
        .btn-buy { background: var(--gold); color: black; } .btn-buy:hover { background: white; }
        .btn-equip { background: var(--on); color: white; } .btn-equip:hover { background: white; color: black; }
        .btn-unequip { background: var(--off); color: white; } .btn-unequip:hover { background: white; color: black; }
        #hud { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-around; pointer-events: none; font-family: 'Black Ops One'; }
        .player-hud { background: rgba(0,0,0,0.6); padding: 15px 30px; border-radius: 10px; text-align: center; min-width: 180px; border-top: 5px solid #fff; }
        .p1-hud { border-color: var(--p1); } .p2-hud { border-color: var(--p2); } .p2-cpu { border-color: var(--cpu) !important; }
        .percent { font-size: 48px; color: white; text-shadow: 2px 2px 0 #000; }
        .ult-bar { height: 10px; width: 0%; background: #555; margin-top: 10px; }
        .ult-ready .ult-bar { background: var(--ult); box-shadow: 0 0 10px var(--ult); }
        #coin-display { position: absolute; top: 20px; right: 20px; font-family: 'Press Start 2P'; color: var(--gold); font-size: 20px; text-shadow: 2px 2px 0 #000; z-index: 20; }
        .coin-pop { position: absolute; color: var(--gold); font-family: 'Black Ops One'; font-size: 30px; pointer-events: none; animation: floatUp 1s forwards; text-shadow: 2px 2px 0 #000; }
        #mega-warning { position: absolute; top: 20%; width: 100%; text-align: center; font-family: 'Black Ops One'; font-size: 40px; color: var(--gold); text-shadow: 4px 4px 0 #000; pointer-events: none; display: none; animation: flashWarn 0.5s infinite; z-index: 15; }
        #secret-unlock { position: absolute; top: 30%; width: 100%; text-align: center; font-family: 'Black Ops One'; font-size: 50px; color: var(--glitch); text-shadow: 5px 5px 0 #000; pointer-events: none; display: none; z-index: 100; animation: glitchText 0.2s infinite; }
        #pause-menu { background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 30; }
        .volume-control { display: flex; align-items: center; gap: 20px; margin: 10px; font-family: 'Press Start 2P'; font-size: 12px; color:white;}
        #training-hud { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px; font-family: 'Press Start 2P'; font-size: 10px; color: #ccc; line-height: 1.8; display: none; border: 1px solid #fff; }
        #game-mode-hud { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; display: none; pointer-events: none; }
        .game-mode-score { font-family: 'Black Ops One'; font-size: 50px; color: var(--boss); text-shadow: 2px 2px 0 #fff; }
        .game-mode-title { font-family: 'Press Start 2P'; font-size: 12px; color: #aaa; margin-top: 5px; }
        .char-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; max-width: 800px; }
        .char-card { background: #333; border: 4px solid #555; border-radius: 10px; padding: 15px; text-align: center; cursor: pointer; transition: transform 0.2s; }
        .char-card.locked { opacity: 0.5; filter: grayscale(1); }
        .lock-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; display: none; }
        .char-card.locked .lock-icon { display: block; }
        .selected-p1 { border-color: var(--p1) !important; } .selected-p2 { border-color: var(--p2) !important; }
        .char-card canvas { width: 40px; height: 40px; }
        .map-grid { display: flex; gap: 20px; }
        .map-card { width: 200px; height: 150px; background: #444; border: 3px solid #666; border-radius: 8px; display: flex; justify-content: center; align-items: center; cursor: pointer; flex-direction: column; }
        .map-card:hover { border-color: #fff; }
        .map-preview { font-size: 40px; margin-bottom: 10px; }
        #moves-content { width: 100%; max-width: 1000px; margin: 0 auto; height: 70%; overflow-y: auto; background: #222; border: 2px solid #555; padding: 20px; display: block; box-sizing: border-box; }
        .moves-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }
        .move-card { background: rgba(255,255,255,0.05); padding: 15px; display: flex; gap: 15px; cursor: pointer; border: 1px solid #444; border-radius: 10px; }
        .move-icon { font-size: 40px; min-width: 50px; }
        .move-details { text-align: left; font-size: 12px; line-height: 1.8; color: #ccc; width: 100%; }
        .move-input { color: #e74c3c; font-weight: bold; font-size: 10px; background: #444; padding: 2px 5px; border-radius: 4px; margin-right: 5px;}
        /* Move detail modal */
        #move-detail { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 50; }
        #move-detail .box { width: 90%; max-width: 900px; background: #111; border: 2px solid #555; border-radius: 12px; padding: 24px; box-sizing: border-box; color: #fff; }
        #move-detail h3 { font-family: 'Black Ops One'; margin: 0 0 10px 0; }
        #move-detail .grid { display: grid; grid-template-columns: 1fr 2fr; gap: 16px; }
        #move-detail .stat { font-family: 'Press Start 2P'; font-size: 12px; color: #aaa; }
        #move-detail .section { margin-top: 12px; }
        .setting-row { display: flex; align-items: center; gap: 20px; margin-bottom: 20px; font-family: 'Press Start 2P'; font-size: 16px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; font-family: 'Press Start 2P'; font-size: 12px; }
        .control-key { padding: 10px 20px; font-family: 'Press Start 2P'; font-size: 12px; background: #333; border: 2px solid #fff; color: #fff; cursor: pointer; min-width: 80px; }
        .control-key:hover { background: #555; }
        .control-key.remapping { background: #ff0; color: #000; animation: pulse 0.5s infinite; }
        .toggle-btn { width: 100px; padding: 10px; cursor: pointer; border: 2px solid white; font-family: 'Press Start 2P'; }
        .toggle-on { background: var(--on); } .toggle-off { background: var(--off); }
        #cpu-controls { margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #cpu-toggle { font-size: 14px; padding: 10px 20px; border-color: var(--p2); color: var(--p2); }
        #cpu-toggle.cpu-active { background: var(--cpu); color: white; border-color: white; }
        #cpu-level-container { display: none; align-items: center; gap: 10px; font-family: 'Press Start 2P'; font-size: 12px; color: var(--cpu); }
        input[type=range] { width: 150px; accent-color: var(--cpu); cursor: pointer; }
        #trophy-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; width: 90%; max-width: 900px; height: 70%; overflow-y: auto; background: #222; border: 2px solid #555; padding: 20px; }
        .trophy-item { background: #333; border: 2px solid #555; padding: 20px; text-align: center; border-radius: 10px; }
        .trophy-item.unlocked { border-color: var(--gold); box-shadow: 0 0 10px var(--gold); }
        .trophy-icon { font-size: 50px; }
        .trophy-name { font-family: 'Press Start 2P'; font-size: 14px; color: #fff; margin-top: 10px; }
        .trophy-desc { font-size: 12px; color: #aaa; margin-top: 5px; }
        .trophy-item.locked .trophy-name { color: #777; }
        .trophy-item.locked .trophy-icon { filter: grayscale(1) brightness(0.5); }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-50px); opacity: 0; } }
        @keyframes flashWarn { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }
        @keyframes glitchText { 0% { transform: translate(0,0); } 25% { transform: translate(5px,-5px); } 50% { transform: translate(-5px,5px); } 75% { transform: translate(5px,5px); } 100% { transform: translate(-5px,-5px); } }
        .pulse { animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #mobile-controls { display: none; position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .touch-btn { pointer-events: auto; position: absolute; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; backdrop-filter: blur(2px); }
        .dpad { width: 60px; height: 60px; font-size: 24px; }
        #btn-left { bottom: 30px; left: 20px; } 
        #btn-right { bottom: 30px; left: 90px; } 
        #btn-up { bottom: 100px; left: 55px; } 
        #btn-down { bottom: 30px; left: 55px; }
        #btn-jump { bottom: 40px; right: 30px; width: 100px; height: 100px; font-size: 24px; } 
        #btn-atk { bottom: 60px; right: 150px; width: 80px; height: 80px; font-size: 20px; } 
        #btn-ult { bottom: 160px; right: 40px; width: 60px; height: 60px; font-size: 18px; }
        #btn-shield { bottom: 160px; right: 120px; width: 60px; height: 60px; font-size: 18px; }
        #gacha-screen { flex-direction: column !important; justify-content: center; align-items: center; padding: 50px; box-sizing: border-box; }
        #gacha-container { display: flex; flex-direction: column; align-items: center; gap: 30px; max-width: 600px; width: 100%; }
        #gacha-display { background: rgba(255,255,255,0.05); border: 3px solid var(--gold); border-radius: 15px; padding: 40px; text-align: center; min-height: 300px; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; }
        .gacha-result-icon { font-size: 100px; margin-bottom: 20px; }
        .gacha-result-name { font-family: 'Black Ops One'; font-size: 32px; color: var(--gold); margin-bottom: 10px; }
        .gacha-result-desc { font-family: 'Press Start 2P'; font-size: 12px; color: #aaa; }
        #gacha-roll-btn { width: 100%; padding: 25px; font-size: 24px; font-family: 'Black Ops One'; border: 4px solid var(--gold); background: transparent; color: var(--gold); cursor: pointer; transition: 0.2s; }
        #gacha-roll-btn:hover { background: var(--gold); color: black; transform: scale(1.05); }
        #gacha-roll-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #gacha-roll-premium-btn { width: 100%; padding: 25px; font-size: 24px; font-family: 'Black Ops One'; animation: glow 1.5s ease-in-out infinite; }
        #gacha-roll-premium-btn:disabled { opacity: 0.3; cursor: not-allowed; animation: none; }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 5px #ff00ff; } 50% { box-shadow: 0 0 20px #ff00ff, 0 0 30px #ff00ff; } }
        .gacha-cost { font-family: 'Press Start 2P'; font-size: 16px; color: var(--gold); margin-top: 10px; }
        .gacha-rarity { font-family: 'Press Start 2P'; font-size: 10px; color: #aaa; margin-top: 5px; }
        .gacha-ultra-rare { color: #ff00ff; text-shadow: 0 0 10px #ff00ff; }
        .gacha-rare { color: #ffd700; text-shadow: 0 0 5px #ffd700; }
        .gacha-common { color: #999; }
        /* Moves Guide UI */
        .moves-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(260px,1fr)); gap:16px; }
        .move-card { background:#111; border:1px solid #333; border-radius:12px; padding:14px; display:flex; gap:12px; align-items:flex-start; }
        .move-thumb { width:48px; height:48px; border-radius:8px; background:#222; display:flex; align-items:center; justify-content:center; }
        .move-details { font-family:'Press Start 2P'; font-size:10px; color:#ddd; line-height:1.6; }
        .move-title { font-family:'Black Ops One'; font-size:16px; color:#fff; margin-bottom:6px; }
        .badge { display:inline-block; border:1px solid #444; border-radius:6px; padding:3px 6px; font-size:10px; margin-right:6px; color:#aaa; }
        .statline { color:#aaa; font-size:10px; margin:6px 0; }
    </style>
</head>
<body>
<div id="game-container"><canvas id="gameCanvas"></canvas></div>
<div id="coin-display">üí∞ <span id="coin-count">0</span></div>
<div id="mega-warning">‚ö†Ô∏è A MEGA üí∞ HAS SPAWNED! ‚ö†Ô∏è</div>
<div id="secret-unlock">SECRET UNLOCKED!<br><span id="secret-name">THE MEME</span></div>
<div id="game-mode-hud">
    <div class="game-mode-score"><span id="game-score-val">0</span></div>
    <div class="game-mode-title" id="game-mode-title">SURVIVE</div>
</div>
<div id="training-hud">
    <div>DOJO</div><br>
    [1] CPU: <span id="train-cpu-mode">STAND</span><br>[2] RESET DMG<br>[3] RESET POS<br>[4] HITBOX: <span id="train-hitbox">OFF</span>
</div>
<div id="hud" class="hidden">
    <div class="player-hud p1-hud"><div id="p1-name">P1</div><div class="percent" id="p1-pct">0%</div><div class="stocks" id="p1-stocks">‚óè‚óè‚óè</div><div class="ult-container"><div id="p1-ult-bar" class="ult-bar"></div></div></div>
    <div class="player-hud p2-hud" id="p2-hud-box"><div id="p2-name">P2</div><div class="percent" id="p2-pct">0%</div><div class="stocks" id="p2-stocks">‚óè‚óè‚óè</div><div class="ult-container"><div id="p2-ult-bar" class="ult-bar"></div></div></div>
</div>
<div id="title-screen" class="screen">
    <h1>SUPER<br>MEME BROS<br>ULTIMATE</h1>
    <button class="menu-btn pulse" onclick="startLocal()">FIGHT (VS)</button>
    <button class="menu-btn boss-btn" onclick="startSurvival()">SURVIVAL</button>
    <button class="menu-btn" onclick="startMemeBall()">MEME BALL</button>
    <button class="menu-btn dojo-btn" onclick="startTraining()">TRAINING</button>
    <button class="menu-btn" onclick="startSpectator()">SPECTATOR</button>
    <button class="menu-btn gold-btn" onclick="openShop()">MEME SHOP</button>
    <button class="menu-btn" style="border-color: #ff00ff; color: #ff00ff;" onclick="openGacha()" onmouseover="this.style.background='#ff00ff';this.style.color='white';" onmouseout="this.style.background='transparent';this.style.color='#ff00ff';">GACHA üé∞</button>
    <button class="menu-btn" onclick="showMoves()">MOVES LIST</button>
    <button class="menu-btn" onclick="showTrophies()">TROPHIES</button>
    <button class="menu-btn" onclick="showMastery()">MASTERY</button>
    <button class="menu-btn" onclick="showFriends()">FRIENDS</button>
    <button class="menu-btn" onclick="showSoundTest()">SOUND TEST</button>
    <button class="menu-btn" onclick="startOnline()">ONLINE (BETA)</button>
    <button class="menu-btn" onclick="openSettings()">SETTINGS</button>
</div>
<div id="pause-menu" class="screen hidden">
    <h1>PAUSED</h1>
    <div class="volume-control">MUSIC: <input type="range" min="0" max="1" step="0.1" value="0.5" oninput="music.setVol(this.value)"></div>
    <div class="volume-control">SFX: <input type="range" min="0" max="1" step="0.1" value="0.5" oninput="sfx.setVol(this.value)"></div>
    <button class="menu-btn" onclick="togglePause()">RESUME</button>
    <button class="menu-btn danger-btn" onclick="location.reload()">QUIT</button>
</div>
<div id="shop-screen" class="screen hidden">
    <div style="position:absolute;top:20px;left:30px;font-size:24px;font-family:'Black Ops One';color:var(--gold)">MEME SHOP</div>
    <div id="shop-container">
        <div id="shop-left"><div id="shop-grid"></div></div>
        <div id="shop-right">
            <div class="preview-title">DRESSING ROOM</div><div class="preview-spacer"></div>
            <div class="char-cycler"><span class="cycle-btn" onclick="cycleShopChar(-1)">‚óÄ</span><span id="shop-char-name">DOGE</span><span class="cycle-btn" onclick="cycleShopChar(1)">‚ñ∂</span></div>
            <div id="shop-item-info" style="text-align:center;min-height:60px;font-size:14px;font-family:'Press Start 2P';z-index:2">SELECT ITEM</div>
            <button id="buy-btn" class="btn-buy" onclick="buyOrEquip()">BUY</button>
        </div>
    </div>
    <button class="menu-btn" style="position:absolute;bottom:20px;left:30px;z-index:20" onclick="closeShop()">BACK</button>
</div>
<div id="settings-screen" class="screen hidden">
    <h2>SETTINGS</h2>
    <div class="setting-row"><span>SHOW HITBOXES</span><button id="btn-hitbox" class="toggle-btn toggle-off" onclick="toggleHitboxSetting()">OFF</button></div>
    <div class="setting-row"><span>MUSIC</span><button id="btn-music" class="toggle-btn toggle-on" onclick="toggleMusicSetting()">ON</button></div>
    <div class="setting-row"><span>MOBILE CONTROLS</span><button id="btn-mobile" class="toggle-btn toggle-on" onclick="toggleMobileSetting()">ON</button></div>
    <button class="menu-btn" style="margin-top:20px" onclick="showControlsConfig()">CONFIGURE CONTROLS</button>
    <button class="menu-btn danger-btn" style="margin-top:30px" onclick="deleteSaveFile()">DELETE SAVE FILE</button>
    <button class="menu-btn" onclick="closeSettings()">BACK</button>
</div>
<div id="controls-config-screen" class="screen hidden" style="overflow-y:auto">
    <h2>CONTROL CONFIGURATION</h2>
    <div style="max-width:800px;margin:0 auto;padding:20px">
        <div style="display:flex;gap:40px;justify-content:center;flex-wrap:wrap">
            <div style="background:rgba(0,255,255,0.05);border:2px solid var(--p1);padding:20px;min-width:300px">
                <h3 style="color:var(--p1);font-family:'Press Start 2P';margin-bottom:20px">PLAYER 1</h3>
                <div class="control-row">LEFT: <button class="control-key" onclick="remapKey('p1','left')">A</button></div>
                <div class="control-row">RIGHT: <button class="control-key" onclick="remapKey('p1','right')">D</button></div>
                <div class="control-row">UP: <button class="control-key" onclick="remapKey('p1','up')">W</button></div>
                <div class="control-row">DOWN: <button class="control-key" onclick="remapKey('p1','down')">S</button></div>
                <div class="control-row">ATTACK: <button class="control-key" onclick="remapKey('p1','attack')">F</button></div>
                <div class="control-row">ULT: <button class="control-key" onclick="remapKey('p1','ult')">R</button></div>
                <div class="control-row">SHIELD: <button class="control-key" onclick="remapKey('p1','shield')">G</button></div>
            </div>
            <div style="background:rgba(255,0,255,0.05);border:2px solid var(--p2);padding:20px;min-width:300px">
                <h3 style="color:var(--p2);font-family:'Press Start 2P';margin-bottom:20px">PLAYER 2</h3>
                <div class="control-row">LEFT: <button class="control-key" onclick="remapKey('p2','left')">‚Üê</button></div>
                <div class="control-row">RIGHT: <button class="control-key" onclick="remapKey('p2','right')">‚Üí</button></div>
                <div class="control-row">UP: <button class="control-key" onclick="remapKey('p2','up')">‚Üë</button></div>
                <div class="control-row">DOWN: <button class="control-key" onclick="remapKey('p2','down')">‚Üì</button></div>
                <div class="control-row">ATTACK: <button class="control-key" onclick="remapKey('p2','attack')">L</button></div>
                <div class="control-row">ULT: <button class="control-key" onclick="remapKey('p2','ult')">Shift</button></div>
                <div class="control-row">SHIELD: <button class="control-key" onclick="remapKey('p2','shield')">K</button></div>
            </div>
        </div>
        <button class="menu-btn" onclick="resetControls()" style="margin-top:20px">RESET TO DEFAULT</button>
    </div>
    <button class="menu-btn" onclick="hideControlsConfig()">BACK</button>
</div>
    <button class="menu-btn" onclick="closeSettings()">BACK</button>
</div>
<div id="moves-screen" class="screen hidden" style="background:rgba(0,0,0,0.9);overflow:auto;align-items:flex-start;z-index:200">
    <div style="max-width:1000px;margin:40px auto;padding:30px;color:#fff;width:100%">
        <h2>Moves & Specials Guide</h2>
        <div id="moves-content"></div>
        <button class="menu-btn" onclick="hideMoves()">BACK</button>
    </div>
</div>
<!-- Detailed Move Modal -->
<div id="move-detail">
    <div class="box">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <h3 id="move-detail-title">Character</h3>
            <button class="menu-btn" onclick="closeMoveDetail()">CLOSE</button>
        </div>
        <div class="grid">
            <div>
                <canvas width="64" height="64" id="move-detail-thumb" style="width:128px;height:128px"></canvas>
                <div id="move-detail-stats" class="stat"></div>
            </div>
            <div>
                <div class="section" id="move-detail-universal"></div>
                <div class="section" id="move-detail-specials"></div>
                <div class="section" id="move-detail-ult"></div>
            </div>
        </div>
    </div>
</div>
<div id="trophy-screen" class="screen hidden">
    <h2>TROPHIES</h2>
    <div id="trophy-grid"></div>
    <button class="menu-btn" onclick="hideTrophies()">BACK</button>
</div>
<div id="mastery-screen" class="screen hidden" style="overflow-y:auto">
    <h2>CHARACTER MASTERY</h2>
    <div id="mastery-grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:20px;padding:20px;max-width:1200px;margin:0 auto"></div>
    <button class="menu-btn" onclick="hideMastery()">BACK</button>
</div>
<div id="friends-screen" class="screen hidden" style="overflow-y:auto">
    <h2>FRIENDS</h2>
    <div style="max-width:800px;margin:0 auto;padding:20px">
        <div style="background:rgba(255,215,0,0.1);border:2px solid #ffd700;padding:20px;margin-bottom:20px;text-align:center">
            <div style="font-family:'Press Start 2P';font-size:12px;color:#ffd700;margin-bottom:10px">YOUR FRIEND CODE</div>
            <div id="your-friend-code" style="font-family:'Press Start 2P';font-size:18px;color:#fff;margin-bottom:10px"></div>
            <button class="menu-btn" onclick="copyFriendCode()" style="font-size:10px;padding:8px 16px">COPY CODE</button>
        </div>
        <div style="margin-bottom:20px">
            <input type="text" id="friend-code-input" placeholder="Enter friend code..." style="width:60%;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
            <button class="menu-btn" onclick="addFriend()" style="font-size:10px;padding:10px 20px;margin-left:10px">ADD FRIEND</button>
        </div>
        <div id="friends-list"></div>
    </div>
    <button class="menu-btn" onclick="hideFriends()">BACK</button>
</div>
<div id="sound-test-screen" class="screen hidden">
    <h2>SOUND TEST</h2>
    <div style="max-width:600px;margin:0 auto;padding:20px">
        <h3 style="color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin:20px 0">MUSIC</h3>
        <div id="music-list" style="display:flex;flex-direction:column;gap:10px;margin-bottom:30px"></div>
        <h3 style="color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin:20px 0">SOUND EFFECTS</h3>
        <div id="sfx-list" style="display:flex;flex-direction:column;gap:10px"></div>
    </div>
    <button class="menu-btn" onclick="hideSoundTest()">BACK</button>
</div>
<div id="online-screen" class="screen hidden">
    <h2>ONLINE (BETA)</h2>
    <div style="display:flex;gap:20px;flex-direction:column;align-items:center">
        <div style="margin-bottom:10px;display:flex;gap:10px;align-items:center">
            <span style="font-family:'Press Start 2P';font-size:12px;color:#ffd700">Server URL</span>
            <input type="text" id="online-ws-url" placeholder="wss://your-relay.example.com" style="width:320px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff" value="https://supermemesmashmutliplayer-production.up.railway.app/">
        </div>
        <div style="margin-bottom:10px;display:flex;gap:10px;align-items:center">
            <span style="font-family:'Press Start 2P';font-size:12px;color:#ffd700">Your Name</span>
            <input type="text" id="online-nickname" placeholder="Player" maxlength="12" style="width:180px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
        </div>
        <div>
            <button class="menu-btn" onclick="hostRoom()">HOST ROOM</button>
            <div style="font-family:'Press Start 2P';font-size:12px;color:#aaa;margin-top:8px">Room Code: <span id="online-room-code">‚Äî</span></div>
        </div>
        <div>
            <input type="text" id="online-join-code" placeholder="Enter Room Code" style="width:220px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
            <button class="menu-btn" onclick="joinRoom()">JOIN</button>
        </div>
        <div id="online-status" style="font-family:'Press Start 2P';font-size:12px;color:#0f0;min-height:18px"></div>
        <div id="online-controls-help" style="display:none;flex-direction:column;gap:6px;margin:10px 0;padding:10px;background:rgba(0,0,0,0.4);border:1px solid #555;min-width:320px;font-family:'Press Start 2P';font-size:9px;color:#ddd">
            <div style="color:#ffd700">DEFAULT CONTROLS</div>
            <div id="controls-p1">P1 (Host): Move WASD ‚Ä¢ Attack F ‚Ä¢ Ult Q ‚Ä¢ Shield G</div>
            <div id="controls-p2">P2: Move WASD ‚Ä¢ Attack F ‚Ä¢ Ult R ‚Ä¢ Shield G</div>
            <div id="controls-p3">P3: Move WASD ‚Ä¢ Attack F ‚Ä¢ Ult R ‚Ä¢ Shield G</div>
            <div id="controls-p4">P4: Move WASD ‚Ä¢ Attack F ‚Ä¢ Ult R ‚Ä¢ Shield G</div>
            <div style="margin-top:6px;display:flex;gap:6px;flex-wrap:wrap">
                <button class="menu-btn" style="font-size:10px" onclick="remapKey('p1','ult')">Remap P1 Ult</button>
                <button class="menu-btn" style="font-size:10px" onclick="remapKey('p2','ult')">Remap P2 Ult</button>
                <button class="menu-btn" style="font-size:10px" onclick="remapKey('p3','ult')">Remap P3 Ult</button>
                <button class="menu-btn" style="font-size:10px" onclick="remapKey('p4','ult')">Remap P4 Ult</button>
            </div>
        </div>
        <div id="online-lobby-list" style="display:none;flex-direction:column;gap:8px;margin:15px 0;padding:15px;background:rgba(0,0,0,0.5);border:2px solid #555;min-width:320px">
            <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin-bottom:5px">CONNECTED PLAYERS</div>
            <div id="online-player-list" style="font-family:'Press Start 2P';font-size:9px;color:#fff"></div>
        </div>
        <div id="online-start-box" style="display:none;flex-direction:column;gap:10px;align-items:center">
            <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700">SELECT GAME MODE</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center">
                <button class="menu-btn" id="mode-1v1-btn" onclick="selectOnlineMode('1v1')" style="background:#0f0;color:#000">1v1</button>
                <button class="menu-btn" id="mode-2v2-btn" onclick="selectOnlineMode('2v2')">2v2</button>
            </div>
            <div id="online-char-select" style="margin-top:10px;display:flex;gap:10px;flex-direction:column;align-items:center">
                <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700">CHARACTER SELECT (Host)</div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center">
                    <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">P1:
                        <select id="online-p1-char" style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px"></select>
                    </label>
                    <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">P2:
                        <select id="online-p2-char" style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px"></select>
                    </label>
                </div>
                <div id="online-picked-preview" style="font-family:'Press Start 2P';font-size:9px;color:#aaa"></div>
            </div>
            <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin-top:10px">MATCH SETTINGS</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;align-items:center">
                <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">Stage:
                    <select id="online-stage-sel" style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px">
                        <option value="flat">Flat</option>
                        <option value="plat">Platforms</option>
                        <option value="edge">Edge</option>
                        <option value="machine">Machine</option>
                    </select>
                </label>
                <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">Stocks:
                    <input type="number" id="online-stocks" min="1" max="5" value="3" style="width:50px;padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px">
                </label>
            </div>
            <div style="display:flex;gap:15px;flex-wrap:wrap;justify-content:center;margin-top:8px">
                <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                    <input type="checkbox" id="online-items" checked style="margin-right:5px"> Items
                </label>
                <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                    <input type="checkbox" id="online-hazards" checked style="margin-right:5px"> Hazards
                </label>
                <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                    <input type="checkbox" id="online-teamattack" style="margin-right:5px"> Team Attack
                </label>
            </div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:10px">
                <button class="menu-btn" onclick="onlineStart('meme')">START MEME BALL</button>
                <button class="menu-btn" onclick="onlineStart('vs')">START VS MATCH</button>
            </div>
            <div style="font-family:'Press Start 2P';font-size:9px;color:#888;max-width:340px;text-align:center">1v1: 2 players | 2v2: 4 players (teams)</div>
        </div>
        <button class="menu-btn" onclick="hideOnline()">BACK</button>
    </div>
    <div style="position:absolute;bottom:20px;font-family:'Press Start 2P';font-size:10px;color:#888">Requires local signaling server ws://localhost:8080</div>
</div>
<div id="gacha-screen" class="screen hidden">
    <div style="position:absolute;top:20px;left:30px;font-size:24px;font-family:'Black Ops One';color:#ff00ff">GACHA üé∞</div>
    <div style="position:absolute;top:20px;right:30px;font-family:'Press Start 2P';font-size:12px;color:#ffd700;text-align:right">
        üí∞ <span id="gacha-coin-count">0</span><br>
        üé´ <span id="gacha-coin-special-count">0</span> Gacha Coins
    </div>
    <button class="menu-btn" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);font-size:12px;padding:8px 16px" onclick="toggleGachaInfo()">VIEW REWARDS</button>
    <div id="banner-timer" style="position:absolute;top:70px;left:50%;transform:translateX(-50%);font-family:'Press Start 2P';font-size:10px;color:#ff0;text-align:center;display:none">
        <div style="color:#f0f;margin-bottom:5px">‚≠ê LIMITED BANNER ‚≠ê</div>
        <div id="banner-char-name" style="font-size:14px;margin-bottom:5px"></div>
        <div>Time Left: <span id="banner-time-left"></span></div>
    </div>
    <div id="gacha-container">
        <div id="gacha-display">
            <div class="gacha-result-icon">üéÅ</div>
            <div class="gacha-result-name">ROLL FOR REWARDS!</div>
            <div class="gacha-result-desc">Click the button below to roll</div>
            <div class="gacha-rarity">Normal: 100 Coins | Premium: 1 Gacha Coin</div>
        </div>
        <button id="gacha-roll-btn" onclick="rollGacha()">NORMAL GACHA (100üí∞)</button>
        <button id="gacha-banner-btn" class="menu-btn" style="border-color:#ff0;color:#ff0;margin-top:10px;display:none;animation:pulse 1s infinite" onclick="rollBannerGacha()" onmouseover="this.style.background='#ff0';this.style.color='black';" onmouseout="this.style.background='transparent';this.style.color='#ff0';">BANNER GACHA (1üé´)</button>
        <button id="gacha-roll-premium-btn" class="menu-btn" style="border-color:#ff00ff;color:#ff00ff;margin-top:10px" onclick="rollPremiumGacha()" onmouseover="this.style.background='#ff00ff';this.style.color='white';" onmouseout="this.style.background='transparent';this.style.color='#ff00ff';">PREMIUM GACHA (1üé´)</button>
        <button class="menu-btn" style="margin-top:20px;border-color:#ffd700;color:#ffd700" onclick="convertCoinsToGacha()" onmouseover="this.style.background='#ffd700';this.style.color='black';" onmouseout="this.style.background='transparent';this.style.color='#ffd700';">CONVERT 1000üí∞ ‚Üí 1üé´</button>
    </div>
    <button class="menu-btn" style="position:absolute;bottom:20px;left:30px;z-index:20" onclick="closeGacha()">BACK</button>
    
    <!-- Gacha Info Panel -->
    <div id="gacha-info-panel" class="hidden" style="position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:100;overflow-y:auto;padding:40px;box-sizing:border-box">
        <button class="menu-btn" style="position:absolute;top:20px;right:20px;padding:10px 20px" onclick="toggleGachaInfo()">CLOSE</button>
        <h2 style="font-family:'Black Ops One';color:#ff00ff;text-align:center;margin-bottom:30px">GACHA REWARDS INFO</h2>
        
        <div id="gacha-pity-display" style="text-align:center;color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin-bottom:30px;padding:15px;background:rgba(255,215,0,0.1);border:2px solid #ffd700"></div>
        
        <div style="display:flex;gap:30px;justify-content:center;flex-wrap:wrap">
            <!-- Normal Gacha -->
            <div style="flex:1;min-width:300px;max-width:500px;background:rgba(0,255,255,0.05);border:2px solid #00ffff;padding:20px">
                <h3 style="font-family:'Press Start 2P';color:#00ffff;text-align:center;margin-bottom:20px">NORMAL GACHA (100üí∞)</h3>
                
                <div style="margin-bottom:20px">
                    <h4 style="color:#ffd700;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">üéÅ ULTRA RARE (0.5%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">üé≤ Lucky Block (GUARANTEED at 200 rolls)</p>
                </div>
                
                <div style="margin-bottom:20px">
                    <h4 style="color:#ff00ff;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">‚≠ê RARE (4.5%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                        üê∂ Doge<br>
                        üê∏ Frog<br>
                        üê± Cat<br>
                        ü¶´ Capy<br>
                        üßΩ Spongy<br>
                        üí™ The Meme<br>
                        üó∫Ô∏è GPS<br>
                        üìû John Pork<br>
                        ü§ñ Mechabara<br>
                        üó°Ô∏è Blue Dude
                    </p>
                </div>
                
                <div>
                    <h4 style="color:#00ff00;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">‚ú® COMMON (95%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                        üé® Skins<br>
                        üí• Effects<br>
                        üèÜ Titles<br>
                        üí∞ Coin Bundles
                    </p>
                </div>
            </div>
            
            <!-- Premium Gacha -->
            <div style="flex:1;min-width:300px;max-width:500px;background:rgba(255,0,255,0.05);border:2px solid #ff00ff;padding:20px">
                <h3 style="font-family:'Press Start 2P';color:#ff00ff;text-align:center;margin-bottom:20px">PREMIUM GACHA (1üé´)</h3>
                
                <div style="margin-bottom:20px">
                    <h4 style="color:#ffd700;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">üéÅ ULTRA RARE (20%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                        üí™ The Meme<br>
                        üó∫Ô∏è GPS<br>
                        üìû John Pork<br>
                        ü§ñ Mechabara<br>
                        üó°Ô∏è Blue Dude<br>
                        ‚ö° Glitch (EXCLUSIVE!)
                    </p>
                </div>
                
                <div style="margin-bottom:20px">
                    <h4 style="color:#ff00ff;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">‚≠ê RARE (30%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                        üé≤ Lucky Block<br>
                        üí∏ Brokeboy
                    </p>
                </div>
                
                <div>
                    <h4 style="color:#00ff00;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">‚ú® COSMETIC (50%)</h4>
                    <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                        üé® Exclusive Skins<br>
                        üí• Premium Effects<br>
                        üèÜ Rare Titles
                    </p>
                </div>
                
                <div style="margin-top:20px;padding:10px;background:rgba(255,215,0,0.1);border:1px solid #ffd700">
                    <p style="color:#ffd700;font-family:'Press Start 2P';font-size:9px;text-align:center">
                        üí° GUARANTEED RARE OR BETTER!<br>
                        Get Gacha Coins from special trophies or convert 1000üí∞ ‚Üí 1üé´
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="char-select" class="screen hidden">
    <h2>SELECT FIGHTER</h2><h3 id="select-instruction">P1 CHOOSE</h3><div class="char-grid" id="char-grid"></div>
    <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px">
        <button class="menu-btn" id="p1-mastery-toggle" style="display:none" onclick="toggleMastery(1)">P1 MASTERY: OFF</button>
        <button class="menu-btn" id="p2-mastery-toggle" style="display:none" onclick="toggleMastery(2)">P2 MASTERY: OFF</button>
    </div>
    <div id="cpu-controls"><button class="menu-btn" id="cpu-toggle" onclick="toggleCpu()">P2: HUMAN</button><div id="cpu-level-container" style="display:none;color:#ccc;font-family:'Press Start 2P'">LVL <span id="cpu-level-val">5</span> <input type="range" min="1" max="9" value="5" oninput="updateCpuLevel(this.value)"></div></div>
</div>
<div id="map-select" class="screen hidden"><h2>SELECT STAGE</h2><div class="map-grid" id="map-grid" style="display:flex;gap:20px"></div></div>
<div id="controls-hint" class="screen hidden" style="background:rgba(0,0,0,0.8);pointer-events:auto" onclick="startGameLoop()"><h2>READY?</h2><div style="display:flex;gap:50px;text-align:left"><div><strong style="color:var(--p1)">P1</strong><br>WASD + F<br>ULT: R<br>SHIELD: G</div><div id="p2-controls-text"><strong style="color:var(--p2)">P2</strong><br>Arrows + L<br>ULT: Shift<br>SHIELD: K</div></div><h3 class="pulse" style="margin-top:50px">CLICK TO FIGHT</h3></div>
<div id="game-over" class="screen hidden"><h1 id="winner-display">GAME!</h1><div id="mastery-progress" style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin:20px 0"></div><button class="menu-btn" onclick="rematch()" style="margin-bottom:10px">REMATCH</button><button class="menu-btn" onclick="location.reload()">MAIN MENU</button></div>
<div id="mobile-controls">
    <div id="btn-left" class="touch-btn dpad">‚Üê</div>
    <div id="btn-right" class="touch-btn dpad">‚Üí</div>
    <div id="btn-up" class="touch-btn dpad">‚Üë</div>
    <div id="btn-down" class="touch-btn dpad">‚Üì</div>
    <div id="btn-atk" class="touch-btn">A</div>
    <div id="btn-jump" class="touch-btn">JUMP</div>
    <div id="btn-ult" class="touch-btn">U</div>
    <div id="btn-shield" class="touch-btn">S</div>
</div>
<script>
console.log("RUNNING FILE VERSION: 15:15 PM");
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = 'TITLE',
    p1Char = null,
    p2Char = null,
    p2IsCpu = !1,
    cpuLevel = 5;
let useMasteryP1 = false,
    useMasteryP2 = false;
let isSurvival = !1,
    isMemeBall = !1,
    servingPlayer = 1,
    isServing = false,
    serveCharge = 0,
    p1Score = 0,
    p2Score = 0,
    ball = null;
// Online multiplayer
let isOnline = false,
    isHost = false,
    netSocket = null,
    netRoom = null,
    netPeerReady = false,
    netOpened = false,
    netReadyCount = 0,
    netConnectedPlayers = [], // [{id, name, ready}]
    netP2Inputs = {l:0,r:0,u:0,d:0,a:0,j:0,U:0,S:0},
    netP3Inputs = {l:0,r:0,u:0,d:0,a:0,j:0,U:0,S:0},
    netP4Inputs = {l:0,r:0,u:0,d:0,a:0,j:0,U:0,S:0},
    netTick = 0,
    netGameMode = '1v1', // '1v1' or '2v2'
    customStocks = 3, // Custom stock count for online matches
    rulesItemsEnabled = true,
    rulesHazardsEnabled = true,
    rulesTeamAttack = false, // Friendly fire in teams
    netDisconnected = false; // Track mid-match disconnect
let survivalWave = 0,
    spawnTimer = 0,
    isTraining = !1,
    trainingCpuMode = 0;
let players = [],
    platforms = [],
    items = [],
    ultEffects = [],
    particles = [],
    itemTimer = 0,
    camera = {
        x: 0,
        y: 0,
        zoom: 1
    },
    shake = 0,
    hitStop = 0,
    mapTimer = 0;
let megaCoinSpawned = !1,
    backgrounds = [],
    confetti = [];
let worldFlipped = !1,
    flipTimer = 0;
const keys = {};
const touchInput = {
    left: !1,
    right: !1,
    up: !1,
    down: !1,
    atk: !1,
    jump: !1,
    ult: !1,
    shield: !1
};
let showHitboxes = !1,
    shopCharIndex = 0,
    shopSelectedItem = null;
let killCount = 0;
const cheatCode = ['ArrowUp', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft'];
let cheatIndex = 0;
const cheatCode2 = ['ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowLeft'];
let cheatIndex2 = 0;
const cheatCode3 = ['ArrowLeft', 'ArrowLeft', 'ArrowRight', 'ArrowRight', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowRight'];
let cheatIndex3 = 0;
const cheatCode4 = ['ArrowUp', 'ArrowDown', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
let cheatIndex4 = 0;
const cheatCodeGacha = ['ArrowUp', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowDown', 'ArrowLeft'];
let cheatIndexGacha = 0;
// Konami code: Up, Up, Down, Down, Left, Right, Left, Right, B, A
const cheatCodeKonami = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','B','A'];
let cheatIndexKonami = 0;
// Pork code: (example) Up, Down, Left, Right, P, O, R, K
const cheatCodePork = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','p','o','r','k'];
let cheatIndexPork = 0;
// Glitch code: G, L, I, T, C, H
const cheatCodeGlitch = ['g','l','i','t','c','h'];
let cheatIndexGlitch = 0;
const SAVE_KEY = 'meme_bros_save_v4';
let saveData = {
    coins: 0,
    gachaCoins: 0,
    gachaPity: 0,
    unlocks: ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', '67kid', 'amogus', 'sahur', 'primo', 'ocralito'],
    goldMode: !1,
    cosmetics: [],
    trophies: [],
    mobileControls: !0,
    bannerEndTime: 0,
    currentBanner: null,
    mastery: {},
    friendCode: '',
    friends: [],
    customControls: null
};
let equippedCosmetic = null;
function generateSprite(pixelData, colors) {
    const pixelSize = 1;
    const canvas = document.createElement('canvas');
    if (!pixelData || pixelData.length === 0) return canvas;
    const width = pixelData[0].length;
    const height = pixelData.length;
    canvas.width = width * pixelSize;
    canvas.height = height * pixelSize;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = !1;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!pixelData[y] || x >= pixelData[y].length) continue;
            const colorKey = pixelData[y][x];
            if (colors[colorKey]) {
                ctx.fillStyle = colors[colorKey];
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            }
        }
    }
    return canvas;
}
function generateAnimationSheet(sheetData, colors) {
    const animations = {};
    for (const animName in sheetData) {
        animations[animName] = [];
        const animFrames = sheetData[animName].frames;
        animFrames.forEach(frameData => {
            animations[animName].push(generateSprite(frameData, colors));
        });
    }
    return animations;
}
const sfx = {
    ctx: null,
    vol: 0.5,
    init: function() {
        if (!this.ctx) this.ctx = new(window.AudioContext || window.webkitAudioContext)();
    },
    setVol: function(v) {
        this.vol = v;
    },
    play: function(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime,
            osc = this.ctx.createOscillator(),
            gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        let g = 0.1 * this.vol;
        if (type === 'jump') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.linearRampToValueAtTime(300, t + 0.1);
            gain.gain.setValueAtTime(g, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.1);
            gain.gain.setValueAtTime(g * 2, t);
        } else if (type === 'break') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, t);
            gain.gain.setValueAtTime(g * 5, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.5);
        } else if (type === 'ult') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, t);
            osc.frequency.linearRampToValueAtTime(800, t + 0.5);
            gain.gain.setValueAtTime(g * 3, t);
            osc.start(t);
            osc.stop(t + 1.0);
            return;
        } else if (type === 'coin') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1000, t);
            gain.gain.setValueAtTime(g, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.1);
        } else if (type === 'shield') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, t);
            gain.gain.setValueAtTime(g, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.1);
        } else if (type === 'mega') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.linearRampToValueAtTime(600, t + 1.0);
            gain.gain.setValueAtTime(g * 3, t);
            gain.gain.linearRampToValueAtTime(0, t + 1.0);
        }
        osc.start(t);
        osc.stop(t + 0.1);
    }
};
const music = {
    ctx: null,
    enabled: !0,
    currentTheme: null,
    nextNoteTime: 0,
    noteIndex: 0,
    tempo: 120,
    timerID: null,
    vol: 0.5,
    init: function() {
        if (this.ctx) return;
        this.ctx = new(window.AudioContext || window.webkitAudioContext)();
    },
    setVol: function(v) {
        this.vol = v;
    },
    toggle: function() {
        this.enabled = !this.enabled;
        if (!this.enabled) this.stop();
        else if (this.currentTheme) this.play(this.currentTheme);
        return this.enabled;
    },
    play: function(theme) {
        if (this.currentTheme === theme && this.timerID) return;
        this.stop();
        this.currentTheme = theme;
        if (!this.enabled || !this.ctx) return;
        this.noteIndex = 0;
        this.nextNoteTime = this.ctx.currentTime;
        this.scheduler();
    },
    stop: function() {
        clearTimeout(this.timerID);
        this.timerID = null;
    },
    scheduler: function() {
        if (!this.enabled) return;
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            this.playPattern();
            this.nextNoteTime += (60 / this.tempo) * 0.25;
            this.noteIndex++;
        }
        this.timerID = setTimeout(() => this.scheduler(), 25);
    },
    playPattern: function() {
        if (!this.enabled) return;
        const t = this.nextNoteTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        let freq = 0;
        let step = this.noteIndex % 16;
        if (this.currentTheme === 'MENU') {
            this.tempo = 100;
            osc.type = 'triangle';
            const seq = [261, 0, 311, 0, 392, 0, 311, 0, 466, 0, 392, 0, 311, 0, 261, 0];
            freq = seq[step];
            gain.gain.value = 0.05 * this.vol;
        } else if (this.currentTheme === 'BATTLE') {
            this.tempo = 140;
            osc.type = 'square';
            const seq = [261, 261, 329, 392, 440, 440, 392, 329, 349, 349, 329, 293, 261, 293, 329, 0];
            freq = seq[step];
            gain.gain.value = 0.03 * this.vol;
            if (step % 4 === 0) this.playBass(130, t);
        } else if (this.currentTheme === 'BOSS') {
            this.tempo = 110;
            osc.type = 'sawtooth';
            const seq = [65, 0, 65, 0, 69, 0, 65, 0, 73, 0, 69, 0, 65, 0, 61, 0];
            freq = seq[step];
            gain.gain.value = 0.08 * this.vol;
        } else if (this.currentTheme === 'WIN') {
            this.tempo = 120;
            osc.type = 'triangle';
            const seq = [523, 0, 523, 0, 523, 0, 659, 0, 783, 783, 783, 783, 0, 0, 0, 0];
            freq = seq[step];
            gain.gain.value = 0.05 * this.vol;
        }
        if (freq > 0) {
            osc.frequency.setValueAtTime(freq, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            osc.start(t);
            osc.stop(t + 0.1);
        }
    },
    playBass: function(freq, t) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(freq, t);
        gain.gain.setValueAtTime(0.05 * this.vol, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        osc.start(t);
        osc.stop(t + 0.2);
    }
};
const audioFiles = {
    vivaldi: null,
    init: function() {
        if (this.vivaldi) return; // Already initialized
        try {
            // Create audio element for Vivaldi
            this.vivaldi = new Audio();
            this.vivaldi.src = 'vivaldi-winter.mp3'; // Place MP3 file in same directory
            this.vivaldi.volume = 0.5;
            this.vivaldi.loop = false;
            console.log('[AudioFiles] Vivaldi initialized. File: vivaldi-winter.mp3');
        } catch (e) {
            console.error('[AudioFiles] Failed to initialize:', e);
        }
    },
    play: function(track) {
        if (track === 'VIVALDI') {
            if (!this.vivaldi) {
                console.warn('[AudioFiles] Vivaldi not initialized, initializing now...');
                this.init();
            }
            if (this.vivaldi) {
                this.vivaldi.currentTime = 0;
                this.vivaldi.play()
                    .then(() => console.log('[AudioFiles] Vivaldi playing!'))
                    .catch(e => console.error('[AudioFiles] Vivaldi playback failed:', e.message));
            }
        }
    },
    stop: function(track) {
        if (track === 'VIVALDI' && this.vivaldi) {
            this.vivaldi.pause();
            this.vivaldi.currentTime = 0;
        }
    }
};
class Ball {
    constructor() {
        this.x = 0;
        this.y = -200;
        this.vx = 0;
        this.vy = 0;
        this.r = 40;
        this.icon = 'ü•î';
        this.lastHit = 0;
        this.inPlay = false;
        this.hasCrossedNet = false;
    }
    reset(servingSide) {
        this.inPlay = false;
        this.lastHit = 0;
        this.hasCrossedNet = false;
        servingPlayer = servingSide || servingPlayer;
        isServing = true;
        serveCharge = 0;
        
        // Position ball with serving player
        const server = players.find(p => p.id === servingPlayer);
        if (server) {
            // Move server back to safe serving position
            const targetX = servingPlayer === 1 ? -250 : 250;
            server.x = targetX;
            server.y = 0;
            
            this.x = server.x;
            this.y = server.y - 80;
            this.vx = 0;
            this.vy = 0;
        } else {
            this.x = servingPlayer === 1 ? -200 : 200;
            this.y = -150;
            this.vx = 0;
            this.vy = 0;
        }
    }
    serve(power, side) {
        isServing = false;
        this.inPlay = true;
        this.lastHit = servingPlayer;
        this.hasCrossedNet = false;
        const direction = side === 1 ? 1 : -1;
        this.vx = direction * (8 + power * 0.15);
        this.vy = -5 - power * 0.1;
        this.serveTime = 60; // Grace period after serve (1 second)
        sfx.play('hit');
    }
    update() {
        // If serving, ball follows player
        if (isServing) {
            const server = players.find(p => p.id === servingPlayer);
            if (server) {
                this.x = server.x;
                this.y = server.y - 80;
            }
            return;
        }
        
        // Countdown serve grace period
        if (this.serveTime > 0) this.serveTime--;
        
        // Track if ball crosses net
        if (!this.hasCrossedNet && this.inPlay) {
            if ((servingPlayer === 1 && this.x > 0) || (servingPlayer === 2 && this.x < 0)) {
                this.hasCrossedNet = true;
            }
        }
        
        this.vy += 0.4;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.99;
        players.forEach(p => {
            let dx = this.x - (p.x + p.w / 2);
            let dy = this.y - (p.y + p.h / 2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.r + p.w / 2 && this.lastHit !== p.id) {
                this.vx = (dx / dist) * 10;
                this.vy = (dy / dist) * 10 - 10;
                this.lastHit = p.id;
                sfx.play('hit');
            }
        });
        platforms.forEach(p => {
            if (p.w < 100) {
                if (this.x + this.r > p.x && this.x - this.r < p.x + p.w && this.y + this.r > p.y && this.y - this.r < p.y + p.h) {
                    if (this.y < p.y) {
                        this.y = p.y - this.r;
                        this.vy *= -0.8;
                    } else {
                        this.vx *= -0.8;
                    }
                }
            }
        });
        
        // Check for out of bounds (sides) - reset to center without scoring
        if (this.x < -600 || this.x > 600 || this.y > 800) {
            this.reset(servingPlayer);
            return;
        }
        
        // Score only when ball hits ground on a side (after crossing net)
        if (this.y + this.r > 200 && this.inPlay && this.hasCrossedNet) {
            let scorer = 0;
            if (this.x < 0) {
                p2Score++;
                scorer = 2;
            } else {
                p1Score++;
                scorer = 1;
            }
            document.getElementById('game-score-val').innerText = `${p1Score} - ${p2Score}`;
            if (p1Score >= 5) endGame(1);
            else if (p2Score >= 5) endGame(2);
            else this.reset(scorer);
        }
    }
    draw() {
        ctx.font = "80px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, this.x, this.y);
    }
}
class Item {
    constructor(forceType) {
        if (forceType) {
            this.type = forceType;
        } else {
            this.type = Math.random() > 0.8 ? 'nyan' : (Math.random() > 0.5 ? 'hammer' : 'coin');
        }
        this.active = !0;
        this.w = 30;
        this.h = 30;
        if (this.type === 'mega') {
            this.w = 60;
            this.h = 60;
            this.x = (Math.random() * 200) - 100;
            this.y = -400;
            this.vx = 0;
            this.vy = 0;
            this.icon = 'üí∞';
        } else if (this.type === 'nyan') {
            this.y = Math.random() * 400 - 200;
            this.vx = (Math.random() < 0.5 ? 1 : -1) * 12;
            this.x = this.vx > 0 ? -600 : 600;
            this.vy = 0;
            this.icon = 'üåà';
        } else {
            this.x = (Math.random() * 600) - 300;
            this.y = -400;
            this.vx = 0;
            this.vy = 0;
            if (this.type === 'hammer') this.icon = 'üî®';
            else if (this.type === 'landmine') this.icon = 'üí£';
            else if (this.type === 'potion') this.icon = 'üß™';
            else if (this.type === 'tomato') this.icon = 'üçÖ';
            else this.icon = 'üí∞';
        }
        this.placed = !1;
    }
    update() {
        if (!this.active) return;
        if (this.type === 'nyan') {
            this.x += this.vx;
            if (this.x < -1500 || this.x > 1500) this.active = !1;
        } else {
            this.vy += 0.5;
            if (worldFlipped) this.vy -= 1.0;
            this.y += this.vy;
            for (let p of platforms)
                if (p.t !== 'lava' && !p.t.startsWith('machine') && this.vy > 0 && this.y + this.h > p.y && this.y + this.h < p.y + 30 && this.x + this.w > p.x && this.x < p.x + p.w) {
                    this.y = p.y - this.h;
                    this.vy = 0;
                }
            if (this.y > 800) this.active = !1;
        }
        if (this.type === 'landmine' && this.placed) {
            players.forEach(p => {
                if (Math.abs(p.x - this.x) < 30 && Math.abs(p.y - this.y) < 30) {
                    p.hit(0, -20, 30);
                    ultEffects.push({
                        t: 'tear',
                        x: this.x,
                        y: this.y,
                        l: 10
                    });
                    this.active = !1;
                    sfx.play('break');
                }
            });
        }
    }
    draw() {
        if (!this.active) return;
        ctx.font = this.type === 'mega' ? "80px Arial" : "30px Arial";
        if (this.type === 'landmine' && this.placed) ctx.font = "20px Arial";
        ctx.fillText(this.icon, this.x, this.y + 30);
    }
}
class Fighter {
    constructor(id, s, x, y, loc, cpu) {
        this.id = id;
        this.stats = s;
        this.x = x;
        this.y = y;
        this.w = 50;
        this.h = 50;
        this.vx = 0;
        this.vy = 0;
        this.pct = 0;
        this.stocks = 3;
        this.ult = 0;
        this.dir = id === 1;
        this.loc = loc;
        this.cpu = cpu;
        this.jumps = 2;
        this.stun = 0;
        this.inv = 0;
        this.cd = 0;
        this.box = null;
        this.hasHammer = !1;
        this.hasLandmine = !1;
        this.shieldHP = 100;
        this.shielding = !1;
        this.rolling = !1;
        this.rollDir = 0;
        this.rollTime = 0;
        this.isBoss = !1;
        this.bossHP = 0;
        this.alpha = 1;
        this.friction = 0.85;
        this.confused = 0;
        this.animation = "idle";
        this.frame = 0;
        this.frameTimer = 0;
        this.animSpeed = 0.1;
        this.animOverrideTimer = 0;
        this.animOverride = null;
        this.isParrying = !1;
        this.parryTimer = 0;
        // Mastery variant active flag (per character)
        try {
            if (this.stats && this.stats.id) {
                initMastery(this.stats.id);
                const lvl = (saveData.mastery && saveData.mastery[this.stats.id]) ? saveData.mastery[this.stats.id].level : 0;
                const unlocked = lvl >= 5;
                const want = (this.id === 1 ? useMasteryP1 : useMasteryP2);
                this.masteryActive = !!(unlocked && want);
            } else {
                this.masteryActive = false;
            }
        } catch (e) {
            this.masteryActive = false;
        }
    }
    updateAnimationState() {
        // Respect temporary animation overrides (e.g., attacks/ults)
        if (this.animOverrideTimer > 0) {
            this.animOverrideTimer--;
            return;
        }
        if (this.isParrying && this.parryTimer > 0) {
            this.setAnimation("shield");
            return;
        }
        if (this.stun > 0) {
            this.setAnimation("stun");
        } else if (!this.grounded) {
            this.setAnimation(this.vy < 0 ? "fall" : "jump");
        } else if (this.rolling) {
            this.setAnimation("roll");
        } else if (this.shielding) {
            this.setAnimation("shield");
        } else if (Math.abs(this.vx) > 0.5) {
            this.setAnimation("walk");
        } else {
            this.setAnimation("idle");
        }
    }
    setAnimation(newAnim) {
        if (this.animation !== newAnim) {
            this.animation = newAnim;
            this.frame = 0;
            this.frameTimer = 0;
            const animData = this.stats.animSheet ? this.stats.animSheet[newAnim] : null;
            if (animData && animData.speed) {
                this.animSpeed = animData.speed;
            } else if (this.stats.id === 'doge' && newAnim === 'idle') {
                this.animSpeed = 0.05;
            } else {
                this.animSpeed = 0.1;
            }
            if (this.stats.id === 'brokeboy') {
                console.log(`[ANIM] brokeboy -> ${newAnim} (speed=${this.animSpeed})`);
            }
        }
    }
    // Play an animation and prevent auto-state overrides for a short duration (in frames)
    playAnimation(animName, durationFrames) {
        this.setAnimation(animName);
        this.animOverride = animName;
        this.animOverrideTimer = Math.max(1, durationFrames | 0);
    }
    update() {
        if (this.stocks <= 0) return;
        this.ult = Math.min(100, this.ult + 0.05);
        if (this.shieldHP < 100 && !this.shielding) this.shieldHP += 0.5;
        if (this.alpha < 1) this.alpha += 0.001;
        if (this.friction > 0.85) this.friction -= 0.0005;
        if (this.confused > 0) this.confused--;
        if (this.luckyBlockCrush && this.grounded) {
            let t = players.find(p => p.id !== this.id && Math.abs(p.x - this.x) < 80 && Math.abs(p.y - this.y) < 100);
            if (t) {
                t.hit(0, -15, 50);
                this.luckyBlockCrush = false;
                if (Math.random() < 0.2) {
                    this.autoParryNext = true;
                }
            } else {
                this.luckyBlockCrush = false;
            }
        }
        if (this.gamblingFever) {
            this.gamblingFeverTimer--;
            if (this.gamblingFeverTimer <= 0) {
                this.gamblingFever = false;
            } else {
                if (this.gamblingFeverLastRoll <= 0) {
                    this.gamblingFeverLastRoll = Math.floor(Math.random() * 5) * 60 + 60;
                    const slot1 = Math.floor(Math.random() * 10);
                    const slot2 = Math.floor(Math.random() * 10);
                    const slot3 = Math.floor(Math.random() * 10);
                    if (slot1 === slot2 && slot2 === slot3 && [0,1,2,3,4,5,7,8,9].includes(slot1)) {
                        this.gamblingFeverActive = true;
                        this.gamblingFeverActiveTimer = 1200;
                        this.stats = {...this.stats, speed: this.stats.speed * 1.5};
                        this.alpha = 1;
                        this.inv = 1200;
                        setTimeout(() => {
                            if (this.gamblingFeverActive) {
                                this.stats = {...this.stats, speed: this.stats.speed / 1.5};
                                this.gamblingFeverActive = false;
                            }
                        }, 20000);
                        sfx.play('ult');
                    }
                } else {
                    this.gamblingFeverLastRoll--;
                }
            }
        }
        if (this.mrbeastBoost) {
            this.mrbeastTimer--;
            if (this.mrbeastTimer <= 0) {
                this.mrbeastBoost = false;
            }
        }
        this.updateAnimationState();
        if (this.isParrying) {
            if (this.parryTimer > 0) {
                this.parryTimer--;
                this.vx *= 0.1;
            } else {
                this.isParrying = !1;
            }
        }
        if (this.isBoss) {
            if (Math.random() < 0.01 && this.cd <= 0) {
                ultEffects.push({
                    t: 'moon',
                    x: players[0].x,
                    y: -500,
                    l: 50
                });
                this.cd = 60;
            }
            if (players[0].x > this.x + 100) this.vx += 0.5;
            else if (players[0].x < this.x - 100) this.vx -= 0.5;
            this.phys();
            if (this.cd > 0) this.cd--;
            return;
        }
        if (this.rolling) {
            this.rollTime--;
            this.vx = this.rollDir * 15;
            this.inv = 2;
            if (this.rollTime <= 0) {
                this.rolling = !1;
                this.vx = 0;
            }
            this.phys();
            return;
        }
        if (this.stun > 0) {
            this.stun--;
            this.shielding = !1;
            this.vx *= 0.8;
            this.phys();
            return;
        }
        let l = 0,
            r = 0,
            u = 0,
            d = 0,
            a = 0,
            j = 0,
            U = 0,
            S = 0;
        if (this.cpu) {
            let t = players.find(p => p.id !== this.id);
            if (isMemeBall && ball) {
                // Predict ball landing position
                let predictX = ball.x;
                let predictY = ball.y;
                let testVx = ball.vx;
                let testVy = ball.vy;
                
                // Simulate up to 60 frames ahead
                for (let i = 0; i < 60 && predictY < 200; i++) {
                    testVy += 0.4; // gravity
                    predictX += testVx;
                    predictY += testVy;
                    testVx *= 0.99;
                    testVy *= 0.99;
                    
                    // Check for net collision
                    if (predictX > -50 && predictX < 40 && predictY > 0 && predictY < 200) {
                        testVx *= -0.8;
                        predictX = testVx > 0 ? 40 : -50;
                    }
                }
                
                // Determine which side CPU should stay on
                let mySide = this.id === 1 ? -1 : 1; // P1 on left, P2 on right
                let targetX = predictX;
                
                // If ball is on opponent's side and moving away, stay near net
                if ((mySide === -1 && ball.x > 0 && ball.vx > 0) || 
                    (mySide === 1 && ball.x < 0 && ball.vx < 0)) {
                    targetX = mySide * 100; // Stay near net but not too close
                }
                
                // If ball is coming toward my side, position at predicted landing
                else if ((mySide === -1 && ball.x <= 0) || (mySide === 1 && ball.x >= 0)) {
                    // Clamp to my side with margin
                    targetX = Math.max(mySide * 250, Math.min(mySide * 50, predictX));
                }
                
                // Move toward target position
                let moveThreshold = 30 + (10 - cpuLevel) * 5; // Higher level = more precise
                if (Math.abs(targetX - this.x) > moveThreshold) {
                    if (targetX > this.x) r = 1;
                    else l = 1;
                }
                
                // Jump to hit ball when it's near
                let distToBall = Math.sqrt((ball.x - this.x) ** 2 + (ball.y - this.y) ** 2);
                let ballApproaching = (mySide === -1 && ball.vx < 0) || (mySide === 1 && ball.vx > 0);
                
                // Jump heuristics: easier levels still jump for obvious descending balls
                if (distToBall < 170 && ball.y < 170 && this.grounded) {
                    let obviousHigh = ball.y < this.y - 40; // Ball noticeably above character
                    let descending = ball.vy > -2; // Not rising too fast
                    if (ballApproaching || cpuLevel <= 3 || (obviousHigh && descending)) {
                        j = 1;
                    }
                }
                
                // Attack when ball is in range
                let attackRange = 90 + cpuLevel * 6; // Slightly larger to ensure easy hits
                let canAttack = distToBall < attackRange && ball.y < this.y + 50 && ball.y > this.y - 100;
                if (canAttack) {
                    // Decide attack direction based on ball position
                    if (ball.y < this.y - 30) u = 1; // Up attack for high balls
                    else if (ball.y > this.y + 30) d = 1; // Down attack for low balls
                    
                    // Directional attack based on where we want to hit
                    if (Math.abs(ball.x - this.x) < 100) {
                        // Close range - hit toward opponent's side
                        if (mySide === -1) r = 1; // Hit right
                        else l = 1; // Hit left
                    }
                    
                    a = 1; // Trigger attack
                    
                    // Miss chance scaled gently; very low levels still mostly succeed
                    if (cpuLevel <= 2 && Math.random() > 0.92) a = 0; // ~8% miss
                    else if (cpuLevel <= 4 && Math.random() > 0.95) a = 0; // ~5% miss
                }

                // Simple fallback swing for very easy levels when ball is close but canAttack false
                if (!canAttack && cpuLevel <= 3) {
                    if (distToBall < 140 && Math.abs(ball.x - this.x) < 120 && ball.y < this.y + 30) {
                        // Light adjust to center under ball
                        if (ball.x > this.x + 20) r = 1; else if (ball.x < this.x - 20) l = 1;
                        a = 1;
                        if (ball.y < this.y - 20) u = 1;
                    }
                }
                
                // Avoid drifting off net line unless not in attack situation
                if (!canAttack) {
                    let boundaryBuffer = 5;
                    if (mySide === -1 && this.x > -boundaryBuffer) l = 1;
                    if (mySide === 1 && this.x < boundaryBuffer) r = 1;
                }
            } else if (t) {
                let dx = t.x - this.x,
                    dy = t.y - this.y,
                    dist = Math.sqrt(dx * dx + dy * dy);
                if (this.y > 250 || Math.abs(this.x) > 700) {
                    if (this.x < 0) r = 1;
                    else l = 1;
                    if (this.jumps > 0 && this.vy > 0) j = 1;
                    if (this.jumps == 0) {
                        u = 1;
                        a = 1;
                    }
                } else {
                    if (Math.abs(dx) > 60) {
                        if (dx > 0) r = 1;
                        else l = 1;
                    }
                    if (dy < -100 && this.jumps > 0 && Math.random() < (cpuLevel * 0.02)) j = 1;
                    if (dist < 150 && Math.random() < (cpuLevel * 0.01)) {
                        a = 1;
                        if (dy > 50) d = 1;
                        else if (dy < -50) u = 1;
                        else if (Math.abs(dx) > 20) {
                            if (dx > 0) r = 1;
                            else l = 1;
                        }
                    }
                    if (cpuLevel > 6 && dist < 100 && t.box && t.box.act && Math.random() < 0.3) S = 1;
                    if (this.ult >= 100 && dist < 200 && cpuLevel > 5) U = 1;
                }
            }
        } else {
            if (this.id === 1) {
                const p1 = getControl('p1', 'left') || 'a';
                const p1r = getControl('p1', 'right') || 'd';
                const p1u = getControl('p1', 'up') || 'w';
                const p1d = getControl('p1', 'down') || 's';
                const p1a = getControl('p1', 'attack') || 'f';
                const p1ult = getControl('p1', 'ult') || 'q';
                const p1shield = getControl('p1', 'shield') || 'g';
                
                l = keys[p1] || touchInput.left;
                r = keys[p1r] || touchInput.right;
                u = keys[p1u] || touchInput.up;
                d = keys[p1d] || touchInput.down;
                a = keys[p1a] || touchInput.atk;
                j = keys[p1u] || touchInput.jump;
                U = keys[p1ult] || touchInput.ult;
                S = keys[p1shield] || touchInput.shield;
            } else {
                if (isOnline && isHost) {
                    // Use networked inputs for P2/P3/P4 on host
                    if (this.id === 2) {
                        l = netP2Inputs.l; r = netP2Inputs.r; u = netP2Inputs.u; d = netP2Inputs.d; a = netP2Inputs.a; j = netP2Inputs.j; U = netP2Inputs.U; S = netP2Inputs.S;
                    } else if (this.id === 3) {
                        l = netP3Inputs.l; r = netP3Inputs.r; u = netP3Inputs.u; d = netP3Inputs.d; a = netP3Inputs.a; j = netP3Inputs.j; U = netP3Inputs.U; S = netP3Inputs.S;
                    } else if (this.id === 4) {
                        l = netP4Inputs.l; r = netP4Inputs.r; u = netP4Inputs.u; d = netP4Inputs.d; a = netP4Inputs.a; j = netP4Inputs.j; U = netP4Inputs.U; S = netP4Inputs.S;
                    }
                } else {
                    const p2l = getControl('p2', 'left') || 'ArrowLeft';
                    const p2r = getControl('p2', 'right') || 'ArrowRight';
                    const p2u = getControl('p2', 'up') || 'ArrowUp';
                    const p2d = getControl('p2', 'down') || 'ArrowDown';
                    const p2a = getControl('p2', 'attack') || 'l';
                    const p2ult = getControl('p2', 'ult') || 'Shift';
                    const p2shield = getControl('p2', 'shield') || 'k';
                    l = keys[p2l]; r = keys[p2r]; u = keys[p2u]; d = keys[p2d]; a = keys[p2a]; j = keys[p2u]; U = keys[p2ult]; S = keys[p2shield];
                }
            }
        }
        if (this.confused > 0) {
            let temp = l;
            l = r;
            r = temp;
        }
        if (a && l) this.dir = !1;
        if (a && r) this.dir = !0;
        this.shielding = !1;
        if (S && !a && this.grounded && this.shieldHP > 0 && this.stun <= 0 && !isMemeBall) {
            this.shielding = !0;
            this.vx *= 0.5;
            this.shieldHP -= 0.5;
            if (l || r) {
                this.rolling = !0;
                this.rollDir = l ? -1 : 1;
                this.rollTime = 15;
                this.shielding = !1;
                this.inv = 15;
                sfx.play('roll');
                return;
            }
            if (this.shieldHP <= 0) {
                sfx.play('break');
                this.shielding = !1;
                this.stun = 180;
                this.vy = -10;
            }
        }
        if (U && this.ult >= 100 && !isMemeBall) this.fireUlt();
        const sp = 1.5 * this.stats.speed;
        if (!this.shielding && !this.isParrying) {
            if (l) {
                this.vx -= sp;
                this.dir = !1;
            }
            if (r) {
                this.vx += sp;
                this.dir = !0;
            }
        }
        this.vx *= this.friction;
        if (j && !this.pj && this.jumps > 0 && !this.shielding && !this.isParrying) {
            this.vy = -14 * this.stats.jump;
            this.jumps--;
            sfx.play('jump');
        }
        this.pj = j;
        if (this.cd > 0) this.cd--;
        else if (a && !this.shielding && !this.isParrying) this.atk(u, d, l, r);
        this.phys();
        if (this.inv > 0) this.inv--;
        this.chkItm();
        if (this.box && this.box.act) {
            this.box.f--;
            if (this.box.f <= 0) this.box.act = !1;
        }
    }
    fireUlt() {
        if (this.ult < 100) return; // Safety check
        this.ult = 0;
        this.cd = 30; // Add cooldown to prevent rapid re-fire
        sfx.play('ult');
        shake = 30;
        updateHUD();
        let t = players.find(p => p.id !== this.id);
        if (!t) return;
        
        // Debug: log which character is firing ult
        console.log(`Player ${this.id} (${this.stats.id}) firing ult`);
        
        if (this.stats.id === 'doge') ultEffects.push({
            t: 'moon',
            x: t.x,
            y: -500,
            l: 50
        });
        else if (this.stats.id === 'frog') {
            for (let i = 0; i < 20; i++) ultEffects.push({
                t: 'tear',
                x: Math.random() * 2000 - 1000,
                y: -200 - Math.random() * 500,
                l: 100
            });
        } else if (this.stats.id === 'sanic') {
            this.x = t.x;
            this.y = t.y;
            t.hit(0, -15, 30);
            this.inv = 60;
        } else if (this.stats.id === 'chad') {
            t.stun = 180;
            t.vx = 0;
            t.vy = 0;
        } else if (this.stats.id === '67kid') {
            t.vx = -t.vx;
            t.vy = -t.vy;
            t.stun = 60;
        } else if (this.stats.id === 'amogus') {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            t.hit(0, 0, 50);
        } else if (this.stats.id === 'thememe') {
            t.hit(0, -50, 999);
        } else if (this.stats.id === 'gps') {
            worldFlipped = !0;
            flipTimer = 600;
        } else if (this.stats.id === 'sahur') {
            t.stun = 180;
        } else if (this.stats.id === 'primo') {
            ultEffects.push({
                t: 'primo',
                owner: this.id,
                x: this.x,
                y: this.y - 50,
                vx: (this.dir ? 1 : -1) * 15,
                l: 100
            });
        } else if (this.stats.id === 'ocralito') {
            t.stun = 120;
        } else if (this.stats.id === 'mechabara') {
            ultEffects.push({
                t: 'moon',
                x: t.x,
                y: -500,
                l: 50
            });
        } else if (this.stats.id === 'bluedude') {
            this.box = {
                relX: this.dir ? 50 : -150,
                relY: -25,
                w: 100,
                h: 100,
                act: !0,
                own: this.id,
                kbx: 25,
                kby: -20,
                dmg: 35,
                f: 10
            };
        } else if (this.stats.id === 'johnpork') {
            ultEffects.push({
                t: 'pork',
                x: t.x,
                y: -600,
                l: 120
            });
        } else if (this.stats.id === 'luckyblock') {
            this.gamblingFever = true;
            this.gamblingFeverTimer = 1200;
            this.gamblingFeverLastRoll = 0;
            sfx.play('ult');
        } else if (this.stats.id === 'brokeboy') {
            this.mrbeastBoost = true;
            this.mrbeastTimer = 600;
            this.stats = {...this.stats, speed: this.stats.speed * 1.3, power: this.stats.power * 1.2};
            this.weight *= 1.5;
            this.alpha = 1;
            this.inv = 600;
            // Play ult animation for a short duration
            this.playAnimation('ult', 40);
            setTimeout(() => {
                if (this.mrbeastBoost) {
                    this.stats = {...this.stats, speed: this.stats.speed / 1.3, power: this.stats.power / 1.2};
                    this.weight /= 1.5;
                    this.mrbeastBoost = false;
                }
            }, 10000);
            sfx.play('ult');
        } else if (this.stats.id === 'jack') {
            // Everything Everywhere All At Once: Fire ALL ults!
            console.log('Jack ult: EVERYTHING EVERYWHERE ALL AT ONCE!');
            shake = 60;
            // Make Jack invincible during ult to prevent self-damage
            this.inv = 240; // 4 seconds of invincibility
            // Play Vivaldi Four Seasons Winter
            audioFiles.play('VIVALDI');
            
            // Fire every ult effect with extended delays for longer sequence
            setTimeout(() => ultEffects.push({t: 'moon', x: t.x, y: -500, l: 50}), 200); // Doge
            setTimeout(() => {
                for (let i = 0; i < 20; i++) ultEffects.push({
                    t: 'tear',
                    x: Math.random() * 1400 - 700,
                    y: -200 - Math.random() * 400,
                    l: 90
                });
            }, 400); // Frog
            setTimeout(() => { if (t && t.stocks > 0) { this.x = t.x; this.y = t.y; t.hit(0, -15, 30); } }, 600); // Sanic
            setTimeout(() => ultEffects.push({t: 'fire', owner: this.id, x: this.x, y: this.y, vx: 0, vy: 0, l: 70}), 800); // Chad
            setTimeout(() => { if (t) t.confused = 300; }, 1000); // Gps
            setTimeout(() => ultEffects.push({t: 'sword', owner: this.id, x: this.x, y: this.y - 20, l: 100}), 1200); // Sahur
            setTimeout(() => ultEffects.push({t: 'primo', owner: this.id, x: this.x, y: this.y - 50, vx: (this.dir ? 1 : -1) * 15, l: 110}), 1400); // Primo
            setTimeout(() => { if (t) t.stun = 180; }, 1600); // Ocralito/others
            setTimeout(() => ultEffects.push({t: 'pork', x: t.x, y: -600, l: 130}), 1800); // Johnpork
            setTimeout(() => {
                // Bluedude punch
                this.box = {
                    relX: this.dir ? 50 : -150,
                    relY: -25,
                    w: 120,
                    h: 120,
                    act: !0,
                    own: this.id,
                    kbx: 35,
                    kby: -28,
                    dmg: 50,
                    f: 10
                };
            }, 2000);
            // Giant combined FINALE - ONE SHOT KILL
            setTimeout(() => {
                shake = 100;
                for (let i = 0; i < 50; i++) {
                    particles.push({
                        x: this.x + this.w / 2,
                        y: this.y + this.h / 2,
                        vx: (Math.random() - 0.5) * 25,
                        vy: (Math.random() - 0.5) * 25,
                        size: 15,
                        life: 100,
                        color: ['#FFD700', '#FF4500', '#8B00FF', '#00CED1', '#FF1493', '#FFFFFF'][Math.floor(Math.random() * 6)]
                    });
                }
                // ONE SHOT: Deal 999 damage to guarantee kill
                if (t && t.stocks > 0) {
                    t.pct = 999;
                    t.hit(35 * (this.x < t.x ? 1 : -1), -40, 999);
                }
                // Stop Vivaldi after ult completes
                audioFiles.stop('VIVALDI');
            }, 2400);
            sfx.play('ult');
        } else t.hit(20 * (this.x < t.x ? 1 : -1), -20, 40);
    }
    atk(u, d, l, r) {
        this.cd = 30;
        sfx.play('hit');
        let ox = this.dir ? 50 : -60,
            dmg = 10,
            kbx = 10,
            kby = -10;
        const s = this.stats;
        if (this.hasLandmine) {
            this.hasLandmine = !1;
            let trap = new Item('landmine');
            trap.x = this.x;
            trap.y = this.y;
            trap.active = !0;
            trap.placed = !0;
            items.push(trap);
            return;
        }
        if (this.hasHammer) {
            this.hasHammer = !1;
            this.cd = 45;
            this.box = {
                relX: this.dir ? 0 : -40,
                relY: -20,
                w: 90,
                h: 70,
                act: !0,
                own: this.id,
                kbx: 25,
                kby: -15,
                dmg: 25,
                f: 5
            };
            return;
        }
        if (s.id === '67kid') {
            if (u) {
                this.pct += 67;
                this.stun = 60;
                return;
            }
            if (d) {
                this.vy = -20;
                setTimeout(() => this.vy = 25, 200);
                this.box = {
                    relX: -40,
                    relY: 20,
                    w: 130,
                    h: 40,
                    act: !0,
                    own: this.id,
                    kbx: 12 * s.power,
                    kby: 15 * s.power,
                    dmg: 10 * s.power,
                    f: 8
                };
                return;
            }
        } else if (s.id === 'amogus') {
            if (l || r) {
                this.x += (this.dir ? 100 : -100);
                return;
            }
            if (u) {
                this.vy = -20;
                ultEffects.push({
                    t: 'tear',
                    x: this.x,
                    y: this.y + 20,
                    l: 10
                });
                return;
            }
        } else if (s.id === 'gps') {
            if (d) {
                let t = players.find(p => p.id !== this.id);
                if (t) t.confused = 300;
                sfx.play('break');
                return;
            }
            if (u) {
                this.y -= 200;
                this.vy = 0;
                return;
            }
            if (l || r) {
                this.x += (this.dir ? 150 : -150);
                this.box = {
                    relX: -20,
                    relY: 0,
                    w: 40,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 10,
                    kby: -10,
                    dmg: 5,
                    f: 10
                };
                return;
            }
        } else if (s.id === 'sahur') {
            if (d) {
                this.vy = 10;
                this.box = {
                    relX: -75,
                    relY: 20,
                    w: 200,
                    h: 40,
                    act: !0,
                    own: this.id,
                    kbx: 15 * s.power,
                    kby: -15 * s.power,
                    dmg: 20 * s.power,
                    f: 10
                };
                sfx.play('break');
                this.cd = 60;
                return;
            }
            if (u) {
                this.vy = -10 * s.jump;
                this.box = {
                    relX: -25,
                    relY: 50,
                    w: 100,
                    h: 40,
                    act: !0,
                    own: this.id,
                    kbx: 5 * s.power,
                    kby: 20 * s.power,
                    dmg: 12 * s.power,
                    f: 5
                };
                sfx.play('hit');
                return;
            }
            if (l || r) {
                this.vx = (this.dir ? 1 : -1) * 10;
                this.box = {
                    relX: this.dir ? 40 : -90,
                    relY: -10,
                    w: 50,
                    h: 70,
                    act: !0,
                    own: this.id,
                    kbx: 20 * s.power,
                    kby: -10 * s.power,
                    dmg: 15 * s.power,
                    f: 8
                };
                this.cd = 45;
                return;
            }
        } else if (s.id === 'primo') {
            if (d) {
                this.box = {
                    relX: this.dir ? 0 : -100,
                    relY: 0,
                    w: 100,
                    h: 60,
                    act: !0,
                    own: this.id,
                    kbx: 12 * s.power,
                    kby: -10 * s.power,
                    dmg: 14 * s.power,
                    f: 10
                };
                this.cd = 40;
                return;
            }
            if (u) {
                this.vy = -12;
                this.vx = (this.dir ? 1 : -1) * 8;
                this.box = {
                    relX: -25,
                    relY: 0,
                    w: 100,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 10 * s.power,
                    kby: -15 * s.power,
                    dmg: 12 * s.power,
                    f: 15
                };
                this.cd = 50;
                return;
            }
            if (l || r) {
                this.vx = (this.dir ? 1 : -1) * 15;
                this.box = {
                    relX: this.dir ? 40 : -80,
                    relY: 0,
                    w: 40,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 18 * s.power,
                    kby: -8 * s.power,
                    dmg: 12 * s.power,
                    f: 8
                };
                this.cd = 40;
                return;
            }
        } else if (s.id === 'ocralito') {
            if (d) {
                this.box = {
                    relX: -50,
                    relY: 40,
                    w: 150,
                    h: 20,
                    act: !0,
                    own: this.id,
                    kbx: 10 * s.power,
                    kby: -10 * s.power,
                    dmg: 14 * s.power,
                    f: 5
                };
                this.vy = 10;
                this.cd = 40;
                return;
            }
            if (u) {
                this.vy = -15 * s.jump;
                this.box = {
                    relX: -25,
                    relY: -20,
                    w: 100,
                    h: 40,
                    act: !0,
                    own: this.id,
                    kbx: 5 * s.power,
                    kby: -15 * s.power,
                    dmg: 10 * s.power,
                    f: 8
                };
                this.cd = 45;
                return;
            }
            if (l || r) {
                this.vx = (this.dir ? 1 : -1) * 12;
                this.box = {
                    relX: this.dir ? 40 : -70,
                    relY: 20,
                    w: 30,
                    h: 30,
                    act: !0,
                    own: this.id,
                    kbx: 15 * s.power,
                    kby: -5 * s.power,
                    dmg: 8 * s.power,
                    f: 12
                };
                this.friction = 0.98;
                this.cd = 50;
                return;
            }
        } else if (s.id === 'mechabara') {
            if (d) {
                this.box = {
                    relX: -25,
                    relY: 50,
                    w: 100,
                    h: 20,
                    act: !0,
                    own: this.id,
                    kbx: 10 * s.power,
                    kby: 15 * s.power,
                    dmg: 16 * s.power,
                    f: 5
                };
                this.vy = 5;
                this.cd = 45;
                return;
            }
            if (u) {
                this.vy = -18 * s.jump;
                this.box = {
                    relX: -25,
                    relY: 0,
                    w: 100,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 5 * s.power,
                    kby: -15 * s.power,
                    dmg: 10 * s.power,
                    f: 12
                };
                this.cd = 50;
                return;
            }
            if (l || r) {
                this.vx = (this.dir ? 1 : -1) * 10;
                this.box = {
                    relX: this.dir ? 40 : -80,
                    relY: 0,
                    w: 40,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 16 * s.power,
                    kby: -5 * s.power,
                    dmg: 7 * s.power,
                    f: 15
                };
                this.cd = 50;
                return;
            }
        } else if (s.id === 'bluedude') {
            if (d) {
                this.isParrying = !0;
                this.parryTimer = 15;
                this.cd = 30;
                return;
            }
            if (u) {
                this.setAnimation("attack_up");
                this.vy = -16 * s.jump;
                this.box = {
                    relX: -25,
                    relY: -50,
                    w: 100,
                    h: 100,
                    act: !0,
                    own: this.id,
                    kbx: 8 * s.power,
                    kby: -18 * s.power,
                    dmg: 12 * s.power,
                    f: 8
                };
                this.cd = 50;
                return;
            }
            if (l || r) {
                this.setAnimation("attack_side");
                this.vx = (this.dir ? 1 : -1) * 12;
                this.box = {
                    relX: this.dir ? 50 : -90,
                    relY: 10,
                    w: 40,
                    h: 30,
                    act: !0,
                    own: this.id,
                    kbx: 14 * s.power,
                    kby: -5 * s.power,
                    dmg: 9 * s.power,
                    f: 6
                };
                this.cd = 40;
                return;
            }
        } else if (s.id === 'johnpork') {
            let t = players.find(p => p.id !== this.id);
            if (d) {
                if(t) t.hit(0, 0, 10);
                showNotification("CALL DECLINED", "Dealt 10 damage");
                this.cd = 60;
                return;
            }
            if (u) {
                const boosts = ['speed', 'power', 'jump'];
                const boost = boosts[Math.floor(Math.random() * boosts.length)];
                if (boost === 'speed') this.stats.speed *= 1.5;
                if (boost === 'power') this.stats.power *= 1.5;
                if (boost === 'jump') this.stats.jump *= 1.5;
                showNotification("CALL ACCEPTED", `+${boost.toUpperCase()} for 5s`);
                setTimeout(() => {
                    if (boost === 'speed') this.stats.speed /= 1.5;
                    if (boost === 'power') this.stats.power /= 1.5;
                    if (boost === 'jump') this.stats.jump /= 1.5;
                }, 5000);
                this.cd = 120;
                return;
            }
            if (l || r) {
                if(t) t.stun = 120;
                showNotification("RING RING", "Enemy Stunned!");
                this.cd = 180;
                return;
            }
        } else if (s.id === 'luckyblock') {
            // Mastery Lucky Block: buffed moves + replaced down move (Jackpot)
            if (l || r) {
                if (Math.random() < 0.5) {
                    let t = players.find(p => p.id !== this.id);
                    if (t) {
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                if (t && t.stocks > 0) {
                                    let kbm = (this.masteryActive ? 1.2 : 1);
                                    let dmgm = (this.masteryActive ? 1.2 : 1);
                                    t.hit((this.dir ? 1 : -1) * 8 * kbm, -5 * kbm, 100 * dmgm);
                                }
                            }, i * 100);
                        }
                        sfx.play('ult');
                    }
                } else {
                    sfx.play('break');
                }
                this.cd = this.masteryActive ? 50 : 60;
                return;
            }
            if (u) {
                let t = players.find(p => p.id !== this.id);
                if (t) {
                    let coin = new Item('coin');
                    coin.x = this.x;
                    coin.y = this.y - 30;
                    items.push(coin);
                    setTimeout(() => {
                        if (t && t.stocks > 0) {
                            let kbm = (this.masteryActive ? 1.2 : 1);
                            let dmgm = (this.masteryActive ? 1.5 : 1);
                            t.hit((this.x < t.x ? 1 : -1) * 5 * kbm, -8 * kbm, 10 * dmgm);
                        }
                    }, 300);
                }
                this.cd = this.masteryActive ? 40 : 50;
                return;
            }
            if (d) {
                if (this.masteryActive) {
                    // Replaced move: Jackpot Block
                    // Large sweeping hitbox with big knockback and a chance for a bonus effect
                    this.playAnimation("attack_down", 16);
                    this.box = {
                        relX: -60,
                        relY: -30,
                        w: 170,
                        h: 80,
                        act: !0,
                        own: this.id,
                        kbx: 22 * s.power,
                        kby: -25 * s.power,
                        dmg: 30 * s.power,
                        f: 10
                    };
                    // 30% chance to rain an extra coin hit shortly after
                    if (Math.random() < 0.3) {
                        setTimeout(() => {
                            let t = players.find(p => p.id !== this.id);
                            if (t && t.stocks > 0) {
                                t.hit((this.x < t.x ? 1 : -1) * 6, -10, 12);
                            }
                            let coin = new Item('coin');
                            coin.x = this.x + (this.dir ? 40 : -40);
                            coin.y = this.y - 40;
                            items.push(coin);
                        }, 200);
                    }
                    this.cd = 70;
                } else {
                    this.vy = -15;
                    this.cd = 80;
                    this.luckyBlockCrush = true;
                }
                return;
            }
        } else if (s.id === 'brokeboy') {
            if (l || r) {
                // Side attack: beg/boost chance; play side animation briefly
                this.playAnimation("attack_side", 18);
                if (Math.random() < 0.1) {
                    const boosts = ['speed', 'power', 'regen', 'knockback'];
                    const boost = boosts[Math.floor(Math.random() * boosts.length)];
                    if (boost === 'speed') {
                        this.stats = {...this.stats, speed: this.stats.speed * 1.3};
                        setTimeout(() => {
                            this.stats = {...this.stats, speed: this.stats.speed / 1.3};
                        }, 10000);
                    } else if (boost === 'power') {
                        this.stats = {...this.stats, power: this.stats.power * 1.3};
                        setTimeout(() => {
                            this.stats = {...this.stats, power: this.stats.power / 1.3};
                        }, 10000);
                    } else if (boost === 'regen') {
                        this.alpha = 1;
                        this.inv = 600;
                    } else if (boost === 'knockback') {
                        this.weight *= 1.5;
                        setTimeout(() => {
                            this.weight /= 1.5;
                        }, 10000);
                    }
                    sfx.play('ult');
                } else {
                    sfx.play('break');
                }
                this.cd = 60;
                return;
            }
            if (u) {
                // Up attack: use custom up-attack animation and lock for a bit
                this.playAnimation("attack_up", 20);
                if (Math.random() < 0.1) {
                    let t = players.find(p => p.id !== this.id);
                    if (t) {
                        t.stats = {...t.stats, speed: t.stats.speed * 1.2, power: t.stats.power * 1.2};
                        t.stun = 120;
                        t.hit(0, -5, 10);
                        setTimeout(() => {
                            if (t) {
                                t.stats = {...t.stats, speed: t.stats.speed / 1.2, power: t.stats.power / 1.2};
                            }
                        }, 2000);
                        sfx.play('ult');
                    }
                } else {
                    sfx.play('break');
                }
                this.cd = 50;
                return;
            }
            if (d) {
                if (Math.random() < 0.5) {
                    // Down special: Broken Sword parry uses shield animation
                    this.setAnimation("shield");
                    this.isParrying = !0;
                    this.parryTimer = 20;
                    this.cd = 30;
                    sfx.play('shield');
                } else {
                    sfx.play('break');
                    this.cd = 40;
                }
                return;
            }
        } else if (s.id === 'glitch') {
            if (l || r) {
                // Pixel Shift: 70% normal dash, 30% opposite direction
                if (Math.random() < 0.7) {
                    this.vx = (this.dir ? 1 : -1) * 12;
                    this.box = {
                        relX: this.dir ? 40 : -80,
                        relY: 0,
                        w: 40,
                        h: 50,
                        act: !0,
                        own: this.id,
                        kbx: 10 * s.power,
                        kby: -8 * s.power,
                        dmg: 10 * s.power,
                        f: 8
                    };
                } else {
                    // Glitch: dash opposite direction
                    this.vx = (this.dir ? -1 : 1) * 12;
                    this.box = {
                        relX: this.dir ? -80 : 40,
                        relY: 0,
                        w: 40,
                        h: 50,
                        act: !0,
                        own: this.id,
                        kbx: 15 * s.power,
                        kby: -10 * s.power,
                        dmg: 20 * s.power,
                        f: 8
                    };
                    sfx.play('ult');
                }
                this.cd = 40;
                return;
            }
            if (u) {
                // Data Corruption: Random teleport + 10% position swap
                let oldX = this.x;
                let oldY = this.y;
                this.y -= 150 + Math.random() * 100;
                this.vy = 0;
                this.box = {
                    relX: -40,
                    relY: oldY - this.y,
                    w: 80,
                    h: 60,
                    act: !0,
                    own: this.id,
                    kbx: 8 * s.power,
                    kby: -12 * s.power,
                    dmg: 12 * s.power,
                    f: 10
                };
                if (Math.random() < 0.1) {
                    let t = players.find(p => p.id !== this.id);
                    if (t) {
                        let tx = t.x;
                        let ty = t.y;
                        t.x = oldX;
                        t.y = oldY;
                        this.x = tx;
                        this.y = ty;
                        sfx.play('ult');
                    }
                }
                this.cd = 50;
                return;
            }
            if (d) {
                // Reality Break: 50% stun opponent 60f OR stun self 30f
                if (Math.random() < 0.5) {
                    let t = players.find(p => p.id !== this.id);
                    if (t) {
                        t.stun = 60;
                        t.hit(0, -8, 15);
                        sfx.play('hit');
                    }
                } else {
                    this.stun = 30;
                    sfx.play('break');
                }
                this.cd = 60;
                return;
            }
        } else if (s.id === 'jack') {
            if (l || r) {
                // Master Of None: Rush attack + stat comparison buff + projectile
                let t = players.find(p => p.id !== this.id);
                this.vx = (this.dir ? 1 : -1) * 15;
                this.box = {
                    relX: this.dir ? 40 : -80,
                    relY: 0,
                    w: 60,
                    h: 50,
                    act: !0,
                    own: this.id,
                    kbx: 12 * s.power,
                    kby: -8 * s.power,
                    dmg: 15 * s.power,
                    f: 10
                };
                // Get 0.5 better stats than opponent temporarily
                if (t && !this.jackStatBoost) {
                    this.jackStatBoost = true;
                    const oldSpeed = this.stats.speed;
                    const oldPower = this.stats.power;
                    const oldJump = this.stats.jump;
                    this.stats.speed = Math.max(this.stats.speed, t.stats.speed + 0.5);
                    this.stats.power = Math.max(this.stats.power, t.stats.power + 0.5);
                    this.stats.jump = Math.max(this.stats.jump, t.stats.jump + 0.5);
                    setTimeout(() => {
                        if (this.stats) {
                            this.stats.speed = oldSpeed;
                            this.stats.power = oldPower;
                            this.stats.jump = oldJump;
                            this.jackStatBoost = false;
                        }
                    }, 180);
                }
                // Throw projectile
                setTimeout(() => {
                    ultEffects.push({
                        t: 'tear',
                        x: this.x + (this.dir ? 30 : -30),
                        y: this.y,
                        l: 30
                    });
                }, 100);
                this.cd = 60;
                return;
            }
            if (d) {
                // Parry Combo: Hybrid of BlueDude and BrokeBoy parry with 50% buff chance
                this.isParrying = !0;
                this.parryTimer = 15;
                this.jackParryBonus = Math.random() < 0.5; // 50% chance for buff
                if (this.jackParryBonus) {
                    // Visual feedback for bonus
                    for (let i = 0; i < 5; i++) {
                        particles.push({
                            x: this.x + this.w / 2,
                            y: this.y + this.h / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            size: 6,
                            life: 30,
                            color: '#FFD700'
                        });
                    }
                }
                this.cd = 35;
                return;
            }
            if (u) {
                // Rising Mastery: Stat buff + low damage attack
                this.vy = -18 * s.jump;
                this.box = {
                    relX: -30,
                    relY: -20,
                    w: 60,
                    h: 70,
                    act: !0,
                    own: this.id,
                    kbx: 3 * s.power,
                    kby: -5 * s.power,
                    dmg: 5 * s.power,
                    f: 12
                };
                // Temporary stat boost
                if (!this.jackRisingBoost) {
                    this.jackRisingBoost = true;
                    const oldStats = {speed: this.stats.speed, power: this.stats.power, jump: this.stats.jump};
                    this.stats.speed += 0.3;
                    this.stats.power += 0.3;
                    this.stats.jump += 0.3;
                    setTimeout(() => {
                        if (this.stats) {
                            this.stats.speed = oldStats.speed;
                            this.stats.power = oldStats.power;
                            this.stats.jump = oldStats.jump;
                            this.jackRisingBoost = false;
                        }
                    }, 240);
                }
                this.cd = 50;
                return;
            }
        }
        if (!u && !d && !l && !r) {
            this.box = {
                relX: -30,
                relY: 0,
                w: 110,
                h: 50,
                act: !0,
                own: this.id,
                kbx: 10 * s.power,
                kby: -8 * s.power,
                dmg: 8 * s.power,
                f: 5
            };
            return;
        }
        if (d) {
            this.box = {
                relX: -40,
                relY: 20,
                w: 130,
                h: 40,
                act: !0,
                own: this.id,
                kbx: 12 * s.power,
                kby: 5 * s.power,
                dmg: 10 * s.power,
                f: 8
            };
            return;
        }
        if (u) {
            this.vy = -12 * s.jump;
            this.box = {
                relX: -20,
                relY: -50,
                w: 90,
                h: 60,
                act: !0,
                own: this.id,
                kbx: 5 * s.power,
                kby: -15 * s.power,
                dmg: 10 * s.power,
                f: 5
            };
            return;
        }
        if (l || r) {
            this.vx = (this.dir ? 1 : -1) * 5;
            dmg = 12;
            kbx = 15;
            this.box = {
                relX: ox,
                relY: 0,
                w: 60,
                h: 50,
                act: !0,
                own: this.id,
                kbx: kbx * s.power,
                kby: kby * s.power,
                dmg: dmg * s.power,
                f: 5
            };
            return;
        }
    }
    hit(kbx, kby, d) {
        if (this.autoParryNext && Math.random() < 0.2) {
            let attacker = players.find(p => p.box && p.box.act && p.id !== this.id);
            if (attacker) {
                attacker.stun = 120;
            }
            this.autoParryNext = false;
            sfx.play('shield');
            this.box = {
                relX: -25,
                relY: -25,
                w: 100,
                h: 100,
                act: !0,
                own: this.id,
                kbx: 20,
                kby: -20,
                dmg: 25,
                f: 5
            };
            return;
        }
        if (this.isParrying && this.parryTimer > 0) {
            let attacker = players.find(p => p.box && p.box.act && p.id !== this.id);
            if (attacker) {
                attacker.stun = 120;
                // Jack's Parry Combo bonus: 50% chance for permanent stat buff
                if (this.stats.id === 'jack' && this.jackParryBonus) {
                    const statChoices = ['speed', 'power', 'jump'];
                    const buffStat = statChoices[Math.floor(Math.random() * 3)];
                    this.stats[buffStat] += 0.5;
                    console.log(`Jack parry buff! +0.5 ${buffStat}`);
                    // Visual effect
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: this.x + this.w / 2,
                            y: this.y + this.h / 2,
                            vx: (Math.random() - 0.5) * 12,
                            vy: (Math.random() - 0.5) * 12,
                            size: 8,
                            life: 40,
                            color: '#FFD700'
                        });
                    }
                }
            }
            this.parryTimer = 0;
            this.isParrying = !1;
            sfx.play('shield');
            this.box = {
                relX: -25,
                relY: -25,
                w: 100,
                h: 100,
                act: !0,
                own: this.id,
                kbx: 20,
                kby: -20,
                dmg: 25,
                f: 5
            };
            return;
        }
        if (this.inv > 0 || (this.rolling && this.inv > 0)) return;
        if (this.gamblingFeverActive && Math.random() < 0.1) {
            d *= 1.5;
        }
        if (this.shielding) {
            this.shieldHP -= d * 2;
            sfx.play('shield');
            this.vx = kbx * 0.5;
            if (this.shieldHP <= 0) {
                sfx.play('break');
                this.shielding = !1;
                this.stun = 180;
                this.vy = -15;
            }
            return;
        }
        shake = Math.min(10, d * 0.5);
        particles.push({
            x: this.x + this.w / 2,
            y: this.y,
            text: `+${Math.floor(d)}%`,
            life: 60,
            vy: -2
        });
        for (let i = 0; i < 5; i++) {
            particles.push({
                x: this.x + this.w / 2,
                y: this.y + this.h / 2,
                vx: (Math.random() - 0.5) * 5 + kbx * 0.1,
                vy: (Math.random() - 0.5) * 5 + kby * 0.1,
                size: Math.random() * 5 + 2,
                life: 30,
                color: 'white'
            });
        }
        this.pct += d;
        this.ult = Math.min(100, this.ult + d);
        let sc = 0.5 + (this.pct * 0.025),
            wm = 1.0 / this.stats.weight;
        if (kbx !== 0) {
            let o = players.find(p => p.id !== this.id);
            this.vx = (this.x < (o ? o.x : 0) ? -1 : 1) * Math.abs(kbx * sc * wm);
        } else this.vx = (Math.random() - 0.5) * Math.abs(kbx * sc * wm);
        this.vy = kby * sc * wm;
        this.inv = 10;
        sfx.play(d > 15 ? 'hit' : 'hit');
        hitStop = 5;
        updateHUD();
    }
    phys() {
        let gv = 0.6;
        if (worldFlipped) gv = -0.6;
        if (!this.isParrying) {
            this.vy += gv;
            if (!worldFlipped && this.vy > 25) this.vy = 25;
            if (worldFlipped && this.vy < -25) this.vy = -25;
            this.x += this.vx;
            this.y += this.vy;
            this.grounded = !1;
        }
        if (isMemeBall) {
            if (this.id === 1) {
                this.x = Math.min(this.x, -10 - this.w);
            }
            if (this.id === 2) {
                this.x = Math.max(this.x, 10);
            }
        }
        for (let p of platforms) {
            if (p.t === 'lava') {
                if (this.y > p.y && this.y < p.y + p.h && this.x > p.x && this.x < p.x + p.w) {
                    this.hit(0, -20, 15);
                    this.y = p.y - 50;
                }
                continue;
            }
            if (p.t.startsWith('machine')) {
                let dx = (this.x + this.w / 2) - p.pivotX;
                let pStart = p.x;
                let pEnd = p.x + p.w;
                let pCenterX = this.x + this.w / 2;
                if (pCenterX >= pStart && pCenterX <= pEnd) {
                    let floorY = p.pivotY + (pCenterX - p.pivotX) * Math.tan(p.angle);
                    if (this.vy >= 0 && this.y + this.h >= floorY - 15 && this.y + this.h <= floorY + 15) {
                        this.y = floorY - this.h;
                        this.vy = 0;
                        this.grounded = !0;
                        this.jumps = 2;
                    }
                }
                continue;
            }
            let pt = p.y,
                ft = this.y + this.h;
            if (this.vy >= 0 && ft >= pt && ft <= pt + Math.max(25, this.vy + 10) && this.x + this.w > p.x && this.x < p.x + p.w) {
                this.y = p.y - this.h;
                this.vy = 0;
                this.grounded = !0;
                this.jumps = 2;
                if (p.vx) this.x += p.vx;
                if (p.vy) this.y += p.vy;
            }
            if (p.t === 'solid' && this.vy < 0 && this.x + this.w > p.x && this.x < p.x + p.w && this.y < p.y + p.h && ft > p.y + p.h) {
                this.y = p.y + p.h;
                this.vy = 0;
            }
        }
        if (this.y > 800 || this.y < -800) this.die();
    }
    die() {
        sfx.play('ko');
        this.stocks--;
        this.pct = 0;
        this.ult = 0;
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: this.x + this.w / 2,
                y: this.y + this.h / 2,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15 - 5,
                size: Math.random() * 8 + 3,
                life: 60,
                color: 'var(--ult)'
            });
        }
        if (this.stocks > 0) {
            this.x = 0;
            this.y = -200;
            this.vx = 0;
            this.vy = 0;
            shake = 20;
        }
        if (isSurvival) {
            let humanPlayers = players.filter(p => !p.cpu);
            let livingHumans = humanPlayers.filter(p => p.stocks > 0);
            if (livingHumans.length === 0 && gameState === 'GAME') {
                endGame(1);
            }
        } else if (this.stocks <= 0) {
            // Jack Of All Trades passive: Killer gains stats when Jack dies
            const killer = players.find(p => p.id !== this.id && p.stocks > 0);
            if (killer && killer.stats.id === 'jack') {
                if (!killer.jackKills) killer.jackKills = 0;
                if (!killer.jackBuffs) killer.jackBuffs = {speed: 0, power: 0, jump: 0};
                killer.jackKills++;
                // Random stat gets +3
                const statChoices = ['speed', 'power', 'jump'];
                const buffStat = statChoices[Math.floor(Math.random() * 3)];
                killer.jackBuffs[buffStat] += 3;
                killer.stats[buffStat] += 3;
                killer.stats.weight += 0.1; // Weight increases each kill
                console.log(`Jack gained +3 ${buffStat}, weight now ${killer.stats.weight.toFixed(1)}`);
            }
            if (gameState === 'GAME') endGame(this.id === 1 ? 2 : 1);
        }
        updateHUD();
    }
    chkItm() {
        items.forEach(i => {
            if (i.active && this.x < i.x + i.w && this.x + this.w > i.x && this.y < i.y + i.h && this.y + this.h > i.y) {
                if (i.type === 'hammer') {
                    this.hasHammer = !0;
                    i.active = !1;
                    sfx.play('coin');
                } else if (i.type === 'landmine') {
                    this.hasLandmine = !0;
                    i.active = !1;
                    sfx.play('coin');
                } else if (i.type === 'potion') {
                    this.alpha = 0.1;
                    this.inv = 600;
                    i.active = !1;
                    sfx.play('coin');
                } else if (i.type === 'tomato') {
                    this.friction = 0.99;
                    this.pct = Math.max(0, this.pct - 10);
                    i.active = !1;
                    sfx.play('coin');
                } else if (i.type === 'coin') {
                    if (this.id === 1 || !players.find(p => p.id === 1)) {
                        earnCoins(50);
                        sfx.play('coin');
                    }
                    i.active = !1;
                } else if (i.type === 'mega') {
                    if (this.id === 1 || !players.find(p => p.id === 1)) {
                        earnCoins(500);
                        sfx.play('ult');
                    }
                    i.active = !1;
                } else if (i.type === 'nyan') {
                    this.hit(20 * (i.vx > 0 ? 1 : -1), -10, 15);
                    i.active = !1;
                }
            }
        });
    }
    draw() {
        if (this.stocks <= 0) return;
        ctx.save();
        ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
        if (this.isBoss) ctx.scale(2.5, 2.5);
        // Base sprites face right; flip when facing left
        if (!this.dir) ctx.scale(-1, 1);
        if (this.confused > 0) {
            ctx.font = "20px Arial";
            ctx.fillText("‚ùì", 0, -40);
        }
        ctx.globalAlpha = this.alpha;
        ctx.font = "50px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const sprite = characterSprites[this.stats.id];
        if (saveData.goldMode && this.id === 1) {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
        } else {
            ctx.shadowBlur = 0;
        }
        if (this.stun > 0) {
            this.setAnimation("idle");
            ctx.fillText("üí´", 0, -10);
        } else if (this.rolling) {
            ctx.globalAlpha = 0.5;
            ctx.rotate(Date.now() / 50);
        }
        if (this.isParrying && this.parryTimer > 0) {
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.5;
        }
        if (sprite && sprite.idle) {
            const anim = sprite[this.animation] || sprite["idle"];
            if (anim) {
                this.frameTimer += this.animSpeed;
                if (this.frameTimer >= 1) {
                    this.frameTimer = 0;
                    this.frame = (this.frame + 1) % anim.length;
                    if (this.stats.id === 'brokeboy') {
                        console.log(`[ANIM] brokeboy ${this.animation} frame=${this.frame}/${anim.length}`);
                    }
                }
                const currentFrameSprite = anim[this.frame];
                if (currentFrameSprite) ctx.drawImage(currentFrameSprite, -this.w / 2, -this.h / 2, this.w, this.h);
            }
        } else if (sprite) {
            ctx.drawImage(sprite, -this.w / 2, -this.h / 2, this.w, this.h);
        } else {
            ctx.fillText(this.stats.icon, 0, 5);
        }
        if (saveData.goldMode && this.id === 1) {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            if (sprite && sprite.idle) {
                const anim = sprite[this.animation] || sprite["idle"];
                if (anim) ctx.drawImage(anim[this.frame], -this.w / 2, -this.h / 2, this.w, this.h);
            } else if (sprite) {
                ctx.drawImage(sprite, -this.w / 2, -this.h / 2, this.w, this.h);
            }
        }
        ctx.shadowBlur = 0;
        if (this.hasHammer) {
            ctx.font = "20px Arial";
            ctx.fillText('üî®', 25, -25);
        }
        if (this.hasLandmine) {
            ctx.font = "20px Arial";
            ctx.fillText('üí£', 25, -25);
        }
        if (this.id === 1 && equippedCosmetic) {
            ctx.font = "30px Arial";
            if (equippedCosmetic === 'tophat') ctx.fillText('üé©', 0, -30);
            if (equippedCosmetic === 'shades') ctx.fillText('üï∂Ô∏è', 5, 0);
            if (equippedCosmetic === 'crown') ctx.fillText('üëë', 0, -35);
        }
        if (this.shielding) {
            ctx.beginPath();
            ctx.arc(0, 0, 40 * (this.shieldHP / 100), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${255-this.shieldHP*2.55},${this.shieldHP*2.55},0,0.5)`;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        ctx.restore();
        if (this.box && this.box.act && showHitboxes) {
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillRect(this.x + this.box.relX, this.y + this.box.relY, this.box.w, this.box.h);
        }
        ctx.fillStyle = this.id === 1 ? '#3498db' : (this.isCpu ? '#9b59b6' : '#e74c3c');
        ctx.font = "bold 12px sans-serif";
        ctx.fillText(this.isCpu ? `CPU` : `P${this.id}`, this.x + 15, this.y - 10);
    }
}
const CHARACTERS = [{
    id: 'doge',
    name: 'Doge',
    icon: 'üêï',
    speed: 1.1,
    weight: 1.0,
    power: 1.0,
    jump: 1.0,
    desc: "Balanced",
    moves: {
        side: "Zoomies",
        up: "Moon Jump",
        down: "Heavy",
        ult: "MOON CRASH"
    },
    colors: {
        '0': null,
        '1': '#c19a6b'
    },
    animSheet: {
        "idle": {
            speed: 0.05,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"],
                ["0000000000000000", "0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "walk": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "jump": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "fall": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "stun": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "roll": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        },
        "shield": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
            ]
        }
    }
}, {
    id: 'frog',
    name: 'Pepe',
    icon: 'üê∏',
    speed: 0.8,
    weight: 1.4,
    power: 1.3,
    jump: 0.9,
    desc: "Heavy",
    moves: {
        side: "Ree Punch",
        up: "High Hop",
        down: "Stomp",
        ult: "TEAR FLOOD"
    }
}, {
    id: 'cat',
    name: 'Pop Cat',
    icon: 'üôÄ',
    speed: 1.4,
    weight: 0.7,
    power: 0.8,
    jump: 1.2,
    desc: "Speed",
    moves: {
        side: "Scratch",
        up: "Pop Jump",
        down: "Fast Fall",
        ult: "POP STORM"
    }
}, {
    id: 'capy',
    name: 'Capy',
    icon: 'ü•î',
    speed: 0.6,
    weight: 1.8,
    power: 1.5,
    jump: 0.8,
    desc: "Tank",
    moves: {
        side: "Headbutt",
        up: "Chill Rise",
        down: "Slam",
        ult: "PULL UP"
    }
}, {
    id: 'spongy',
    name: 'Spongy',
    icon: 'üßΩ',
    speed: 1.0,
    weight: 0.9,
    power: 1.1,
    jump: 1.3,
    desc: "Aerial",
    moves: {
        side: "Karate",
        up: "Rainbow",
        down: "Head Out",
        ult: "IMAGINATION"
    }
}, {
    id: 'sanic',
    name: 'Sanic',
    icon: 'ü¶î',
    speed: 1.8,
    weight: 0.8,
    power: 0.9,
    jump: 1.1,
    desc: "Fast",
    moves: {
        side: "Go Fast",
        up: "Spring",
        down: "Spindash",
        ult: "LIGHT SPEED"
    }
}, {
    id: 'chad',
    name: 'Chad',
    icon: 'üóø',
    speed: 0.5,
    weight: 2.0,
    power: 1.4,
    jump: 0.7,
    desc: "Boss",
    moves: {
        side: "Strut",
        up: "Chin Up",
        down: "Flex",
        ult: "GIGA STUN"
    }
}, {
    id: 'troll',
    name: 'Troll',
    icon: 'üë∫',
    speed: 1.2,
    weight: 1.0,
    power: 1.0,
    jump: 1.5,
    desc: "Tricky",
    moves: {
        side: "Problem?",
        up: "Float",
        down: "Glitch",
        ult: "U MAD?"
    }
}, {
    id: '67kid',
    name: '67 Kid',
    icon: 'üßí',
    speed: 1.0,
    weight: 0.9,
    power: 1.0,
    jump: 1.2,
    desc: "Chaotic",
    moves: {
        side: "Cringe",
        up: "Youtube Shorts",
        down: "67!!!",
        ult: "BRAIN ROT"
    }
}, {
    id: 'amogus',
    name: 'Amogus',
    icon: 'üïµÔ∏è',
    speed: 1.1,
    weight: 1.2,
    power: 1.2,
    jump: 1.0,
    desc: "Sus",
    moves: {
        side: "Vent",
        up: "Eject",
        down: "Sus Strike",
        ult: "EMERGENCY MEETING"
    }
}, {
    id: 'sahur',
    name: 'Sahur Drum',
    icon: 'ü•Å',
    speed: 0.7,
    weight: 1.7,
    power: 1.4,
    jump: 0.8,
    desc: "Heavy Hitter",
    moves: {
        side: "Loud Lunge",
        up: "Drum Pop",
        down: "TUNG TUNG!",
        ult: "DEAFENING BEAT"
    },
    colors: {
        '0': null,
        '1': '#000000',
        '2': '#1A1A1A',
        '3': '#7A4E28',
        '4': '#B37842',
        '5': '#FFFFFF'
    },
    spriteData: ["0000222222200000", "0002333333320000", "0023444444432000", "0234511441154200", "0234114444114200", "0234144444414200", "0234141111414200", "0234141441414200", "0234141441414200", "0234141441414200", "0234114444114200", "0234411441144200", "0023444444432000", "0002333333320000", "0000222002200000", "0000022002200000"]
}, {
    id: 'primo',
    name: 'Los Primos',
    icon: 'üß±',
    speed: 1.0,
    weight: 1.5,
    power: 1.3,
    jump: 1.0,
    desc: "Tag Team",
    moves: {
        side: "Primo Lunge",
        up: "Flying Elbow",
        down: "Stomp & Kick",
        ult: "TAG TEAM!"
    },
    colors: {
        '0': null,
        '1': '#000000',
        '2': '#1A1A1A',
        '3': '#4EC4FF',
        '4': '#FFFFFF',
        '5': '#E53030'
    },
    spriteData: ["0000000000000000", "0002222222222000", "0002333333332000", "0002341334132000", "0002411441142000", "0002444114442000", "0002222552222000", "0000222222220000", "0002244444422000", "0023344444433200", "0233244444423320", "0232222222222320", "0020232002320200", "0000242002420000", "0000222002220000", "0000000000000000"]
}, {
    id: 'ocralito',
    name: 'The Ocralito',
    icon: 'üêã',
    speed: 0.9,
    weight: 1.6,
    power: 1.2,
    jump: 1.0,
    desc: "Slippery",
    moves: {
        side: "Belly Slide",
        up: "Tail Splash",
        down: "Stomp",
        ult: "DEEP FREEZE"
    },
    colors: {
        '0': null,
        '1': '#000000',
        '2': '#1A1A1A',
        '3': '#0A0F25',
        '4': '#FFFFFF',
        '5': '#4EC4FF'
    },
    spriteData: ["0000222222200000", "0002333333320000", "0002344444432000", "0002411551142000", "0002411441142000", "0002441111442000", "0002221111222000", "0000222222220000", "0002244444422000", "0023344444433200", "0233244444423320", "0232222222222320", "0020332002330200", "0000242002420000", "0000222002220000", "0000000000000000"]
}, {
    id: 'mechabara',
    name: 'Mecha-Bara',
    icon: 'ü¶æ',
    speed: 0.7,
    weight: 2.2,
    power: 1.5,
    jump: 1.1,
    desc: "Programmed to chill.",
    moves: {
        side: "Drill Lunge",
        up: "Booster Jets",
        down: "Ground Laser",
        ult: "ORBITAL STRIKE"
    }
}, {
    id: 'bluedude',
    name: 'Bluedude',
    icon: '‚öîÔ∏è',
    speed: 1.3,
    weight: 0.8,
    power: 1.0,
    jump: 1.2,
    desc: "A fast swordsman.",
    moves: {
        side: "Blade Dash",
        up: "Rising Blade",
        down: "Parry",
        ult: "Zero Slash"
    },
    colors: {
        '0': "rgba(0,0,0,0)",
        '1': '#000000',
        '2': '#D9965A',
        '3': '#4FC5FF',
        '4': '#7B8694',
        '5': '#FFFFFF'
    },
    animSheet: {
        "idle": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                ["0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000"],
                ["0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
            ]
        },
        "walk": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000011000001000", "0000010000001100", "0000110000000100"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0050000000000000", "0050000000000000", "0050000000000000", "0050011111110000", "0444013333310000", "0020011531510000", "0021111131111100", "0000013333310100", "0000011111110100", "0000010000010000", "0000010000010000", "0000110000110000"]
            ]
        },
        "jump": {
            speed: 0.1,
            frames: [
                ["0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000"]
            ]
        },
        "fall": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
            ]
        },
        "attack_side": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000011000011000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000001111111", "0000000001333331", "0000400001153151", "0555422111113111", "0000400001333331", "0000000001111111", "0000000001000001", "0000000001000001", "0000000011000011"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000011111110", "0000000013333310", "0004000011531510", "0555422111113111", "0004000013333310", "0000000011111110", "0000000010000010", "0000000010000010", "0000000110000110"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000111111100", "0000000133333100", "0040000115315100", "0554221111131110", "0040000133333100", "0000000111111100", "0000000100000100", "0000000100000100", "0000001100001100"]
            ]
        },
        "attack_up": {
            speed: 0.15,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0500000000000000", "0500000000000000", "0500000000000000", "0444011111110000", "0021013333310000", "0020111535110000", "0001011131110000", "0000113333310000", "0000011111110000", "0000100000100000", "0000100000100000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0500000000000000", "0500000000000000", "0500000000000000", "0444011111110000", "0021013333310000", "0020111535110000", "0001011131110000", "0000113333310000", "0000011111110000", "0000100000100000", "0000100000100000"],
                ["0000000100000000", "0000001310000000", "0000013331000000", "0000013131000000", "0000013331000000", "0111113131001110", "0155113331111510", "0155513131155510", "0015555555551100", "0001115555511000", "0000011111100000", "0000013131000000", "0000013331000000", "0000001310000000", "0000000100000000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0050000000000000", "0050000000000000", "0050000000000000", "0444111111100000", "0020133333100000", "0020115351100000", "0011111311111000", "0000133333101000", "0000111111101000", "0000100000100000", "0000100000100000"]
            ]
        },
        "stun": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
            ]
        },
        "roll": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
            ]
        },
        "shield": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000001111111", "0000000001333331", "0000000001153151", "0000011111113111", "0001121001333331", "0014210001111111", "0154410001000001", "1555100001000001", "1551000011000011", "0110000000000000"]
            ]
        }
    }
}, {
    id: 'thememe',
    name: 'THE MEME',
    icon: 'ü§°',
    speed: 2.0,
    weight: 999,
    power: 999,
    jump: 2.0,
    desc: "GOD",
    moves: {
        side: "DEATH",
        up: "DEATH",
        down: "DEATH",
        ult: "DEATH"
    }
}, {
    id: 'gps',
    name: 'GPS',
    icon: 'üß≠',
    speed: 1.3,
    weight: 1.0,
    power: 1.0,
    jump: 1.1,
    desc: "Director",
    moves: {
        side: "Recalculating",
        up: "Uplink",
        down: "Turn Around",
        ult: "GLOBAL ROTATION"
    }
}, {
    id: 'johnpork',
    name: 'John Pork',
    icon: 'üìû',
    speed: 1.0,
    weight: 1.1,
    power: 1.1,
    jump: 1.0,
    desc: "He's calling...",
    moves: {
        side: "Yo Phone Linging",
        up: "Accept Call",
        down: "Decline Call",
        ult: "PIG SLAM"
    }
}, {
    id: 'luckyblock',
    name: 'Lucky Block',
    icon: 'üéÅ',
    speed: 1.2,
    weight: 1.0,
    power: 1.3,
    jump: 1.1,
    desc: "Ultra Rare",
    moves: {
        side: "Lucky Block OPEN",
        up: "Loan Debt",
        down: "Crushing Debt",
        ult: "Gambling Fever"
    },
    colors: {
        '0': "rgba(0,0,0,0)",
        '1': '#000000',
        '2': '#ff0000',
        '3': '#3c587c',
        '4': '#417ea4',
        '5': '#ffffff',
        '6': '#FF0000',
        '7': '#FFA500',
        '8': '#FFFF00',
        '9': '#00FF00',
        'A': '#00FFFF',
        'B': '#0000FF',
        'C': '#8000FF',
        'D': '#FF00FF',
        'E': '#964B00',
        'F': '#808080',
        'G': '#404040',
        'H': '#606060',
        'I': '#202020',
        'J': '#008000',
        'K': '#008080',
        'L': '#800000',
        'M': '#808000',
        'N': '#0080FF',
        'O': '#FF0080',
        'P': '#C0C0C0',
        'Q': '#A0A0A0',
        'R': '#303030',
        'S': '#101010',
        'T': '#FFD700',
        'U': '#ADFF2F',
        'V': '#4B0082'
    },
    spriteData: ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"]
}, {
    id: 'brokeboy',
    name: 'Broke Boy',
    icon: 'üí∏',
    speed: 0.9,
    weight: 0.8,
    power: 0.7,
    jump: 0.9,
    desc: "Common",
    moves: {
        side: "Please speed I need this",
        up: "Sucker Punch",
        down: "Broken Sword",
        ult: "Mrbeast"
    },
    colors: {
        '0': "rgba(0,0,0,0)",
        '1': '#000000',
        '2': '#eea0bf',
        '3': '#ecbbd3',
        '4': '#9c6d6d',
        '5': '#ffffff',
        '6': '#FF0000',
        '7': '#FFA500',
        '8': '#FFFF00',
        '9': '#00FF00',
        'A': '#00ff00',
        'B': '#00cc00',
        'C': '#00ff80',
        'D': '#FF00FF',
        'E': '#964B00',
        'F': '#c96500',
        'G': '#633200',
        'H': '#969600',
        'I': '#202020',
        'J': '#008000',
        'K': '#008080',
        'L': '#800000',
        'M': '#808000',
        'N': '#0080FF',
        'O': '#FF0080',
        'P': '#C0C0C0',
        'Q': '#A0A0A0',
        'R': '#303030',
        'S': '#101010',
        'T': '#FFD700',
        'U': '#ADFF2F',
        'V': '#4B0082'
    },
    spriteData: ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"],
    animSheet: {
        "idle": {
            speed: 0.1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"]
            ]
        },
        "attack_side": {
            speed: 4,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"]
            ]
        },
        "attack_up": {
            speed: 0.2,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "00000000CC990000", "0000SSSSC55B0000", "0000SFFEEEEES000", "0000SFFEEEEES000", "0000SEEEEEEGS000", "0000SEEEEEEGS000", "0000SEEEEGGGS000", "0000SSSSSSSSS000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CC99000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CC99000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CCBB000", "000000000C55B000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0000000000CCBB00", "0000000000C55B00", "0000000000C55B00", "0000000000955A00", "00000000009AAA00", "000000SSSS000000", "000000SFFEEEEES0", "000000SFFEEEEES0", "000000SEEEEEEGS0", "000000SEEEEEEGS0", "000000SEEEEGGGS0", "000000SSSSSSSSS0", "0000000000000000", "0000000000000000", "0000000000000000"],
                ["0000000000000000", "0000000000CCBB00", "0000000000C55B00", "0000000000C55B00", "0000000000955A00", "00000000009AAA00", "000000SSSS000000", "000000SFFEEEEES0", "000000SFFEEEEES0", "000000SEEEEEEGS0", "000000SEEEEEEGS0", "000000SEEEEGGGS0", "000000SSSSSSSSS0", "0000000000000000", "0000000000000000", "0000000000000000"]
            ]
        },
        "shield": {
            speed: 1,
            frames: [
                ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0SSSS00000000000", "0SFFEEEEES111100", "0SFFEEEEESCAA100", "0SEEEEEEGSC5A110", "0SEEEEEEGS555B10", "0SEEEEGGGS15BB10", "0SSSSSSSSS111110", "0000000000000000", "0000000000000000"]
            ]
        },
        "ult": {
            speed: 0.1,
            frames: [
                [
                    "0000IIIIIII00000",
                    "IIIIIOPPPPI00000",
                    "IIIIII110PII0000",
                    "777771211PPII000",
                    "777711221OPPII00",
                    "I77771110OOPIII0",
                    "0II11II00OOPIIII",
                    "0IROOOOOOOOPPPII",
                    "0IROOOOOOI3IIII0",
                    "0IRRROOOI3300000",
                    "0IIRRRROI3000000",
                    "000IIIROI6600000",
                    "00000IRROI660000",
                    "00000IIROOII0000",
                    "000000IIIII00000",
                    "0000000000000000"
                ]
            ]
        }
    },
    ultColors: {
        '0': "rgba(0,0,0,0)",
        '1': '#000000',
        '2': '#ffffff',
        '3': '#ecbbd3',
        '4': '#ffcae4',
        '5': '#b993a5',
        '6': '#af4141',
        '7': '#d1057c',
        '8': '#FFFF00',
        '9': '#00FF00',
        'A': '#00ff00',
        'B': '#00cc00',
        'C': '#00ff80',
        'D': '#FF00FF',
        'E': '#964B00',
        'F': '#c96500',
        'G': '#633200',
        'H': '#969600',
        'I': '#141010',
        'J': '#008000',
        'K': '#008080',
        'L': '#800000',
        'M': '#808000',
        'N': '#0080FF',
        'O': '#74b8fb',
        'P': '#9ee0ff',
        'Q': '#5c93c8',
        'R': '#7475fb',
        'S': '#101010',
        'T': '#FFD700',
        'U': '#ADFF2F',
        'V': '#4B0082'
    },
    ultSprite: ["0000IIIIIII00000", "IIIIIOPPPPI00000", "IIIIII110PII0000", "777771211PPII000", "777711221OPPII00", "I77771110OOPIII0", "0II11II00OOPIIII", "0IROOOOOOOOPPPII", "0IROOOOOOI3IIII0", "0IRRROOOI3300000", "0IIRRRROI3000000", "000IIIROI6600000", "00000IRROI660000", "00000IIROOII0000", "000000IIIII00000", "0000000000000000"]
}, {
    id: 'glitch',
    name: 'Glitch',
    icon: '‚ö°',
    speed: 1.3,
    weight: 0.7,
    power: 1.2,
    jump: 1.4,
    desc: "Unstable",
    moves: {
        side: "Pixel Shift",
        up: "Data Corruption",
        down: "Reality Break",
        ult: "SYSTEM CRASH"
    },
    colors: {
        '0': null,
        '1': '#ff0000',
        '2': '#00ff00',
        '3': '#0000ff',
        '4': '#ffff00',
        '5': '#ff00ff',
        '6': '#00ffff',
        '7': '#ffffff'
    },
    spriteData: ["0000000000000000", "0011111111110000", "0013456712340000", "0014567123450000", "0015671234560000", "0016712345610000", "0017123456120000", "0071234561230000", "0012345612340000", "0023456123450000", "0034561234560000", "0045612345610000", "0056123456120000", "0061234561230000", "0000000000000000", "0000000000000000"]
}, {
    id: 'jack',
    name: 'Jack Of All Trades',
    icon: 'üÉè',
    speed: 1.8,
    weight: 0.5,
    power: 2.0,
    jump: 2.0,
    desc: "Master of None",
    moves: {
        side: "Master Of None",
        up: "Rising Mastery",
        down: "Parry Combo",
        ult: "Everything Everywhere All At Once"
    },
    colors: {
        '0': "rgba(0,0,0,0)",
        '1': '#000000',
        '2': '#FFFFFF',
        '3': '#7B8694',
        '4': '#b27c4b',
        '5': '#d9965a',
        '6': '#FF0000',
        '7': '#ff0000',
        '8': '#cc0000',
        '9': '#ff8000',
        'A': '#00FFFF',
        'B': '#0000FF',
        'C': '#8000FF',
        'D': '#FF00FF',
        'E': '#964B00',
        'F': '#808080',
        'G': '#404040',
        'H': '#606060',
        'I': '#202020',
        'J': '#008000',
        'K': '#008080',
        'L': '#800000',
        'M': '#b30000',
        'N': '#4d0000',
        'O': '#804000',
        'P': '#C0C0C0',
        'Q': '#A0A0A0',
        'R': '#303030',
        'S': '#101010',
        'T': '#FFD700',
        'U': '#ADFF2F',
        'V': '#4B0082'
    },
    spriteData: ["0000000000000000", "0001111111111100", "0001M27272626100", "0001222222222100", "0001M2M272626100", "0001222222222100", "0001M2M2M2M26100", "0001222222222100", "0001L2M2M2M26100", "0001222222222100", "0001N28282826100", "0001222222222100", "0001N28282826100", "0001222222222100", "0001N2N2N2L26100", "0001111111111100"],
    jackKills: 0,
    jackBuffs: {speed: 0, power: 0, jump: 0}
}];
const MAPS = [{
    id: 'flat',
    c: '#546E7A'
}, {
    id: 'plat',
    c: '#2E7D32'
}, {
    id: 'edge',
    c: '#4e342e'
}, {
    id: 'machine',
    c: '#7f8c8d'
}];
let selectedMap = MAPS[0];
const characterSprites = {};
CHARACTERS.forEach(char => {
    // Prefer animations when available; fall back to static sprite
    if (char.animSheet) {
        characterSprites[char.id] = generateAnimationSheet(char.animSheet, char.colors);
    } else if (char.spriteData) {
        characterSprites[char.id] = generateSprite(char.spriteData, char.colors);
    }
});
const MASTER_TROPHY_LIST = {
    'kills_50': {
        name: "Horde Slayer",
        desc: "Get 50 total kills in Survival",
        icon: "üíÄ"
    },
    'flawless': {
        name: "Flawless",
        desc: "Win a VS match with 0% damage",
        icon: "‚ú®"
    },
    'buy_gold': {
        name: "High Roller",
        desc: "Buy the Gold Skin in the shop",
        icon: "üí∞"
    },
    'unlock_chad': {
        name: "Giga-Brain",
        desc: "Unlock Chad",
        icon: "üóø"
    },
    'unlock_meme': {
        name: "Secret Hunter",
        desc: "Unlock THE MEME",
        icon: "ü§°"
    },
    'unlock_gps': {
        name: "Recalculating...",
        desc: "Unlock GPS",
        icon: "üß≠"
    },
    'unlock_mechabara': {
        name: "Chill Protocol",
        desc: "Unlock Mecha-Bara",
        icon: "ü¶æ"
    },
    'unlock_bluedude': {
        name: "Pointy End",
        desc: "Unlock Bluedude",
        icon: "‚öîÔ∏è"
    },
    'unlock_johnpork': {
        name: "He Answered",
        desc: "Unlock John Pork",
        icon: "üìû"
    },
    'unlock_glitch': {
        name: "Reality Breaker",
        desc: "Unlock Glitch",
        icon: "‚ö°"
    }
};
function loadGame() {
    const d = localStorage.getItem(SAVE_KEY);
    if (d) saveData = JSON.parse(d);
    if (!saveData.unlocks) saveData.unlocks = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', '67kid', 'amogus', 'sahur', 'primo', 'ocralito'];
    if (!saveData.unlocks.includes('sahur')) saveData.unlocks.push('sahur');
    if (!saveData.unlocks.includes('primo')) saveData.unlocks.push('primo');
    if (!saveData.unlocks.includes('ocralito')) saveData.unlocks.push('ocralito');
    if (!saveData.cosmetics) saveData.cosmetics = [];
    if (!saveData.trophies) saveData.trophies = [];
    if (!saveData.titles) saveData.titles = [];
    if (!saveData.powerBoosters) saveData.powerBoosters = 0;
    if (saveData.mobileControls === undefined) saveData.mobileControls = !0;
    if (saveData.equipped) equippedCosmetic = saveData.equipped;
    updateCoinDisplay();
    updateMobileControlsSetting();
}
function saveGame() {
    saveData.equipped = equippedCosmetic;
    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    updateCoinDisplay();
}
function updateCoinDisplay() {
    const el = document.getElementById('coin-count');
    if (el) el.innerText = saveData.coins;
}
function earnCoins(amount) {
    saveData.coins += amount;
    saveGame();
    const pop = document.createElement('div');
    pop.className = 'coin-pop';
    pop.innerText = `+${amount} üí∞`;
    pop.style.left = '50%';
    pop.style.top = '50%';
    document.body.appendChild(pop);
    setTimeout(() => pop.remove(), 1000);
}
function showNotification(title, subtitle) {
    const el = document.getElementById('secret-unlock');
    el.innerHTML = `${title}<br><span id="secret-name" style="font-size:20px">${subtitle}</span>`;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 3000);
}
function unlockTrophy(id) {
    if (!saveData.trophies.includes(id)) {
        saveData.trophies.push(id);
        
        // Award Gacha Coins for special trophies
        const gachaCoinTrophies = ['first_blood', 'combo_master', 'survivor', 'perfect_victory', 'unlock_all', 'collector', 'unlock_meme'];
        if (gachaCoinTrophies.includes(id)) {
            saveData.gachaCoins = (saveData.gachaCoins || 0) + 1;
            showNotification("üé´ BONUS! üé´", "+1 Gacha Coin from Trophy!");
        }
        
        saveGame();
        sfx.play('ult');
        showNotification("üèÜ TROPHY UNLOCKED! üèÜ", MASTER_TROPHY_LIST[id].name);
    }
}
const SHOP_ITEMS = [{
    id: 'chad',
    name: 'UNLOCK CHAD',
    cost: 500,
    type: 'char'
}, {
    id: 'troll',
    name: 'UNLOCK TROLL',
    cost: 500,
    type: 'char'
}, {
    id: 'ocralito',
    name: 'UNLOCK OCRALITO',
    cost: 500,
    type: 'char'
}, {
    id: 'mechabara',
    name: 'UNLOCK MECHA-BARA',
    cost: 1500,
    type: 'char'
}, {
    id: 'tophat',
    name: 'TOP HAT',
    cost: 200,
    type: 'cosmetic',
    icon: 'üé©'
}, {
    id: 'shades',
    name: 'SHADES',
    cost: 300,
    type: 'cosmetic',
    icon: 'üï∂Ô∏è'
}, {
    id: 'crown',
    name: 'CROWN',
    cost: 1000,
    type: 'cosmetic',
    icon: 'üëë'
}, {
    id: 'gold',
    name: 'GOLD SKIN',
    cost: 2000,
    type: 'skin'
}];
function openShop() {
    sfx.init();
    music.init();
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('shop-screen').classList.remove('hidden');
    gameState = 'SHOP';
    renderShop();
    music.play('MENU');
    loop();
}
function closeShop() {
    document.getElementById('shop-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
    gameState = 'TITLE';
}
function cycleShopChar(dir) {
    shopCharIndex = (shopCharIndex + dir + CHARACTERS.length) % CHARACTERS.length;
    document.getElementById('shop-char-name').innerText = CHARACTERS[shopCharIndex].name;
    sfx.play('coin');
}
function renderShop() {
    const grid = document.getElementById('shop-grid');
    grid.innerHTML = '';
    SHOP_ITEMS.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item';
        if (shopSelectedItem && shopSelectedItem.id === item.id) div.classList.add('selected');
        let owned = !1;
        if (item.type === 'char' && saveData.unlocks.includes(item.id)) owned = !0;
        if (item.type === 'skin' && saveData.goldMode) owned = !0;
        if (item.type === 'cosmetic' && saveData.cosmetics.includes(item.id)) owned = !0;
        let iconHtml = '';
        const charForItem = CHARACTERS.find(c => c.id === item.id);
        if (item.type === 'char' && (characterSprites[item.id] || (charForItem && charForItem.icon))) {
            if (characterSprites[item.id]) {
                iconHtml = `<canvas width="16" height="16" id="shop-sprite-${item.id}"></canvas>`;
            } else {
                iconHtml = `<div style="font-size:30px">${charForItem.icon}</div>`;
            }
        } else {
            iconHtml = `<div style="font-size:30px">${item.icon||(owned?'‚úÖ':'üîí')}</div>`;
        }
        let content = `${iconHtml}<div style="font-size:10px">${item.name}</div>`;
        if (!owned) content += `<div class="shop-cost">${item.cost}</div>`;
        else content += `<div class="shop-cost" style="color:var(--on)">OWNED</div>`;
        div.innerHTML = content;
        div.onclick = () => selectShopItem(item);
        grid.appendChild(div);
        if (item.type === 'char' && characterSprites[item.id]) {
            const miniCanvas = document.getElementById(`shop-sprite-${item.id}`);
            if (miniCanvas) {
                const miniCtx = miniCanvas.getContext('2d');
                miniCtx.imageSmoothingEnabled = !1;
                const sprite = characterSprites[item.id];
                if (sprite.idle && sprite.idle[0]) {
                    miniCtx.drawImage(sprite.idle[0], 0, 0, miniCanvas.width, miniCanvas.height);
                } else if (sprite) {
                    miniCtx.drawImage(sprite, 0, 0, miniCanvas.width, miniCanvas.height);
                }
            }
        }
    });
    updateBuyButton();
}
function selectShopItem(item) {
    shopSelectedItem = item;
    renderShop();
    updateBuyButton();
    sfx.play('coin');
}
function updateBuyButton() {
    const btn = document.getElementById('buy-btn');
    const info = document.getElementById('shop-item-info');
    if (!shopSelectedItem) {
        btn.style.display = 'none';
        info.innerText = "SELECT ITEM";
        return;
    }
    btn.style.display = 'block';
    let owned = !1;
    if (shopSelectedItem.type === 'char' && saveData.unlocks.includes(shopSelectedItem.id)) owned = !0;
    if (shopSelectedItem.type === 'skin' && saveData.goldMode) owned = !0;
    if (shopSelectedItem.type === 'cosmetic' && saveData.cosmetics.includes(shopSelectedItem.id)) owned = !0;
    if (!owned) {
        btn.innerText = "BUY";
        btn.className = "btn-buy";
        btn.onclick = buyOrEquip;
        info.innerText = `COST: ${shopSelectedItem.cost} COINS`;
    } else {
        if (shopSelectedItem.type === 'cosmetic') {
            if (equippedCosmetic === shopSelectedItem.id) {
                btn.innerText = "UNEQUIP";
                btn.className = "btn-unequip";
            } else {
                btn.innerText = "EQUIP";
                btn.className = "btn-equip";
            }
            btn.onclick = buyOrEquip;
            info.innerText = "OWNED";
        } else {
            info.innerText = "UNLOCKED";
            btn.style.display = 'none';
        }
    }
}
function buyOrEquip() {
    const item = shopSelectedItem;
    let owned = !1;
    if (item.type === 'char' && saveData.unlocks.includes(item.id)) owned = !0;
    if (item.type === 'skin' && saveData.goldMode) owned = !0;
    if (item.type === 'cosmetic' && saveData.cosmetics.includes(item.id)) owned = !0;
    if (!owned) {
        if (saveData.coins >= item.cost) {
            saveData.coins -= item.cost;
            if (item.type === 'char') {
                saveData.unlocks.push(item.id);
                if (item.id === 'chad') unlockTrophy('unlock_chad');
                if (item.id === 'mechabara') unlockTrophy('unlock_mechabara');
                if (item.id === 'bluedude') unlockTrophy('unlock_bluedude');
            }
            if (item.type === 'skin') {
                saveData.goldMode = !0;
                unlockTrophy('buy_gold');
            }
            if (item.type === 'cosmetic') {
                saveData.cosmetics.push(item.id);
                equippedCosmetic = item.id;
            }
            sfx.play('ult');
            saveGame();
            renderShop();
        } else {
            sfx.play('break');
        }
    } else if (item.type === 'cosmetic') {
        if (equippedCosmetic === item.id) equippedCosmetic = null;
        else equippedCosmetic = item.id;
        sfx.play('shield');
        saveGame();
        renderShop();
    }
}
function openGacha() {
    sfx.init();
    music.init();
    audioFiles.init();
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('gacha-screen').classList.remove('hidden');
    gameState = 'GACHA';
    updateGachaDisplay();
    initBanner();
    
    // Update banner timer every second
    if (window.bannerTimerInterval) clearInterval(window.bannerTimerInterval);
    window.bannerTimerInterval = setInterval(updateBannerDisplay, 1000);
    
    music.play('MENU');
    loop();
}
function closeGacha() {
    if (window.bannerTimerInterval) clearInterval(window.bannerTimerInterval);
    document.getElementById('gacha-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
    gameState = 'TITLE';
}
function initBanner() {
    const now = Date.now();
    if (!saveData.bannerEndTime || now >= saveData.bannerEndTime) {
        // Start new banner
        const bannerChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'];
        saveData.currentBanner = bannerChars[Math.floor(Math.random() * bannerChars.length)];
        saveData.bannerEndTime = now + (60 * 60 * 1000); // 1 hour
        saveGame();
    }
    updateBannerDisplay();
}
function updateBannerDisplay() {
    const now = Date.now();
    const timerEl = document.getElementById('banner-timer');
    const btnEl = document.getElementById('gacha-banner-btn');
    const timeLeftEl = document.getElementById('banner-time-left');
    const charNameEl = document.getElementById('banner-char-name');
    
    if (saveData.bannerEndTime && now < saveData.bannerEndTime && saveData.currentBanner) {
        const remaining = saveData.bannerEndTime - now;
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        
        const charNames = {thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH'};
        const charIcons = {thememe: 'üí™', gps: 'üó∫Ô∏è', johnpork: 'üìû', mechabara: 'ü§ñ', bluedude: 'üó°Ô∏è', glitch: '‚ö°'};
        
        if (charNameEl) charNameEl.textContent = `${charIcons[saveData.currentBanner]} ${charNames[saveData.currentBanner]} ${charIcons[saveData.currentBanner]}`;
        if (timeLeftEl) timeLeftEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        if (timerEl) timerEl.style.display = 'block';
        if (btnEl) btnEl.style.display = 'block';
    } else {
        if (timerEl) timerEl.style.display = 'none';
        if (btnEl) btnEl.style.display = 'none';
        if (saveData.bannerEndTime && now >= saveData.bannerEndTime) {
            initBanner();
        }
    }
}
function rollBannerGacha() {
    if ((saveData.gachaCoins || 0) < 1) {
        sfx.play('break');
        alert('Not enough Gacha Coins! Convert 1000 coins or earn from achievements.');
        return;
    }
    if (!saveData.currentBanner) {
        initBanner();
        return;
    }
    
    saveData.gachaCoins -= 1;
    saveGame();
    updateGachaDisplay();
    sfx.play('ult');
    
    const display = document.getElementById('gacha-display');
    display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';
    
    let frameIndex = 0;
    const animInterval = setInterval(() => {
        const canvas = document.getElementById('gacha-anim-canvas');
        if (!canvas) {
            clearInterval(animInterval);
            return;
        }
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const frame = gachaAnimFrames[frameIndex];
        const pixelSize = 10;
        for (let y = 0; y < frame.length; y++) {
            for (let x = 0; x < frame[y].length; x++) {
                const colorKey = frame[y][x];
                if (gachaColors[colorKey] && colorKey !== '0') {
                    ctx.fillStyle = gachaColors[colorKey];
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
        }
        frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
    }, 100);
    
    setTimeout(() => {
        clearInterval(animInterval);
        
        const roll = Math.random() * 100;
        let reward, rarity, icon, name, desc;
        
        // Banner gacha: 50% featured character, 30% other ultra, 20% rare char
        if (roll < 50) {
            // 50% - Featured banner character
            reward = saveData.currentBanner;
            const charNames = {thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH'};
            name = charNames[reward];
            rarity = '‚≠ê BANNER FEATURED ‚≠ê';
            icon = 'üåü';
            desc = 'Limited Character!';
            if (!saveData.unlocks.includes(reward)) {
                saveData.unlocks.push(reward);
                showNotification("üåü BANNER FEATURED! üåü", `${name} UNLOCKED!`);
            } else {
                showNotification("üåü BANNER FEATURED! üåü", `${name} (Already Owned)`);
            }
        } else if (roll < 80) {
            // 30% - Other ultra rare characters
            const ultraChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'].filter(c => c !== saveData.currentBanner);
            const unlockedUltra = ultraChars.filter(c => !saveData.unlocks.includes(c));
            if (unlockedUltra.length > 0) {
                reward = unlockedUltra[Math.floor(Math.random() * unlockedUltra.length)];
                const charNames = {thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH'};
                name = charNames[reward];
                rarity = 'ULTRA RARE';
                icon = '‚ú®';
                desc = 'Character Unlocked!';
                saveData.unlocks.push(reward);
                showNotification("‚ú® ULTRA RARE! ‚ú®", `${name} UNLOCKED!`);
            } else {
                reward = 'crown';
                name = 'CROWN';
                rarity = 'RARE';
                icon = 'üëë';
                desc = 'Cosmetic!';
                if (!saveData.cosmetics.includes('crown')) saveData.cosmetics.push('crown');
            }
        } else {
            // 20% - Rare characters
            const rareChars = ['luckyblock', 'brokeboy'];
            const unlockedRare = rareChars.filter(c => !saveData.unlocks.includes(c));
            if (unlockedRare.length > 0) {
                reward = unlockedRare[Math.floor(Math.random() * unlockedRare.length)];
                const charNames = {luckyblock: 'LUCKY BLOCK', brokeboy: 'BROKE BOY'};
                name = charNames[reward];
                rarity = 'RARE';
                icon = 'üåü';
                desc = 'Character Unlocked!';
                saveData.unlocks.push(reward);
                showNotification("üåü RARE! üåü", `${name} UNLOCKED!`);
            } else {
                reward = 'shades';
                name = 'SHADES';
                rarity = 'RARE';
                icon = 'üï∂Ô∏è';
                desc = 'Cosmetic!';
                if (!saveData.cosmetics.includes('shades')) saveData.cosmetics.push('shades');
            }
        }
        
        saveGame();
        renderCharGrid && renderCharGrid();
        
        display.innerHTML = `
            <div class="gacha-result-icon" style="font-size:72px">${icon}</div>
            <div class="gacha-result-name">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity" style="color:#ff0">${rarity}</div>
        `;
    }, 2000);
}
function toggleGachaInfo() {
    const panel = document.getElementById('gacha-info-panel');
    if (!panel) return;
    
    if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        
        // Update pity counter display
        const pityEl = document.getElementById('gacha-pity-display');
        if (pityEl) {
            const pity = saveData.gachaPity || 0;
            const remaining = 200 - pity;
            pityEl.innerHTML = `<strong>Pity Counter:</strong> ${pity}/200 rolls (${remaining} until guaranteed Lucky Block)`;
        }
    } else {
        panel.classList.add('hidden');
    }
}
function updateGachaDisplay() {
    const btn = document.getElementById('gacha-roll-btn');
    const premiumBtn = document.getElementById('gacha-roll-premium-btn');
    const coinEl = document.getElementById('gacha-coin-count');
    const gachaEl = document.getElementById('gacha-coin-special-count');
    
    if (coinEl) coinEl.innerText = saveData.coins;
    if (gachaEl) gachaEl.innerText = saveData.gachaCoins || 0;
    
    if (btn) {
        if (saveData.coins >= 100) {
            btn.disabled = false;
            btn.innerText = `NORMAL GACHA (100üí∞)`;
        } else {
            btn.disabled = true;
            btn.innerText = `NOT ENOUGH COINS`;
        }
    }
    
    if (premiumBtn) {
        if ((saveData.gachaCoins || 0) >= 1) {
            premiumBtn.disabled = false;
        } else {
            premiumBtn.disabled = true;
        }
    }
}
const gachaAnimFrames = [
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010011111100100", "0010015322100100", "0010013355100100", "0010012222100100", "0010015555100100", "0010111111110100", "0010000000000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010000000000100", "0014400040440100", "0010040400000100", "0010000000000100", "0014000004000100", "0010444040440100", "0010000000000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010011111100100", "0010012222100100", "0010111515110100", "0011012222101100", "0010011111100100", "0010001001000100", "0010011011000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
    ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010000000000100", "0010001111000100", "0010001551000100", "0010001331000100", "0010001441000100", "0010001221000100", "0010001111000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"]
];
const gachaColors = {
    '0': "rgba(0,0,0,0)",
    '1': '#000000',
    '2': '#ff0000',
    '3': '#3c587c',
    '4': '#417ea4',
    '5': '#ffffff',
    '6': '#FF0000',
    '7': '#FFA500',
    '8': '#FFFF00',
    '9': '#00FF00',
    'A': '#00FFFF',
    'B': '#0000FF',
    'C': '#8000FF',
    'D': '#FF00FF',
    'E': '#964B00',
    'F': '#808080',
    'G': '#404040',
    'H': '#606060',
    'I': '#202020',
    'J': '#008000',
    'K': '#008080',
    'L': '#800000',
    'M': '#808000',
    'N': '#0080FF',
    'O': '#FF0080',
    'P': '#C0C0C0',
    'Q': '#A0A0A0',
    'R': '#303030',
    'S': '#101010',
    'T': '#FFD700',
    'U': '#ADFF2F',
    'V': '#4B0082'
};

function rollGacha() {
    const GACHA_COST = 100;
    if (saveData.coins < GACHA_COST) {
        sfx.play('break');
        return;
    }
    saveData.coins -= GACHA_COST;
    saveData.gachaPity = (saveData.gachaPity || 0) + 1;
    saveGame();
    updateCoinDisplay();
    updateGachaDisplay();
    sfx.play('coin');
    
    // Show animation
    const display = document.getElementById('gacha-display');
    display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';
    
    let frameIndex = 0;
    const animInterval = setInterval(() => {
        const canvas = document.getElementById('gacha-anim-canvas');
        if (!canvas) {
            clearInterval(animInterval);
            return;
        }
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const frame = gachaAnimFrames[frameIndex];
        const pixelSize = 10;
        for (let y = 0; y < frame.length; y++) {
            for (let x = 0; x < frame[y].length; x++) {
                const colorKey = frame[y][x];
                if (gachaColors[colorKey] && colorKey !== '0') {
                    ctx.fillStyle = gachaColors[colorKey];
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
        }
        
        frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
    }, 150);
    
    // After 2 seconds, show result
    setTimeout(() => {
        clearInterval(animInterval);
        
        // Check pity at 200 rolls for Lucky Block
        const pityTriggered = saveData.gachaPity >= 200;
        const roll = Math.random() * 100;
        let reward = null;
        let rarity = '';
        let icon = '';
        let name = '';
        let desc = '';
        
        if (pityTriggered) {
            reward = 'luckyblock';
            rarity = 'PITY ULTRA RARE';
            icon = 'üéÅ';
            name = 'LUCKY BLOCK';
            desc = 'Character Unlocked! (Pity at 200)';
            if (!saveData.unlocks.includes('luckyblock')) {
                saveData.unlocks.push('luckyblock');
                sfx.play('ult');
                showNotification("üéÅ PITY TRIGGERED! üéÅ", "LUCKY BLOCK UNLOCKED!");
            }
            saveData.gachaPity = 0;
        } else if (roll < 0.5) {
            reward = 'luckyblock';
            rarity = 'ULTRA RARE';
            icon = 'üéÅ';
            name = 'LUCKY BLOCK';
            desc = 'Character Unlocked!';
            if (!saveData.unlocks.includes('luckyblock')) {
                saveData.unlocks.push('luckyblock');
                sfx.play('ult');
                showNotification("üéÅ ULTRA RARE! üéÅ", "LUCKY BLOCK UNLOCKED!");
            }
            saveData.gachaPity = 0;
        } else if (roll < 1.005) {
            reward = 'title_restless_gambler';
            rarity = 'RARE';
            icon = 'üé∞';
            name = 'THE RESTLESS GAMBLER';
            desc = 'Title Unlocked!';
            if (!saveData.titles) saveData.titles = [];
            if (!saveData.titles.includes('restless_gambler')) {
                saveData.titles.push('restless_gambler');
                sfx.play('ult');
                showNotification("üé∞ RARE REWARD! üé∞", "TITLE: THE RESTLESS GAMBLER");
            }
        } else if (roll < 10.005) {
            reward = 'tophat';
            rarity = 'UNCOMMON';
            icon = 'üé©';
            name = 'TOP HAT';
            desc = 'Cosmetic Unlocked!';
            if (!saveData.cosmetics.includes('tophat')) {
                saveData.cosmetics.push('tophat');
                equippedCosmetic = 'tophat';
                sfx.play('ult');
                showNotification("üé© COSMETIC UNLOCKED! üé©", "TOP HAT");
            }
        } else if (roll < 30.005) {
            reward = 'power_booster';
            rarity = 'UNCOMMON';
            icon = '‚ö°';
            name = 'POWER BOOSTER';
            desc = 'Survival Boost Unlocked!';
            saveData.powerBoosters = (saveData.powerBoosters || 0) + 1;
            sfx.play('ult');
            showNotification("‚ö° POWER BOOSTER! ‚ö°", "Use in Survival Mode");
        } else {
            reward = 'brokeboy';
            rarity = 'COMMON';
            icon = 'üí∏';
            name = 'BROKE BOY';
            desc = 'Character Unlocked!';
            if (!saveData.unlocks.includes('brokeboy')) {
                saveData.unlocks.push('brokeboy');
                sfx.play('coin');
                showNotification("üí∏ COMMON REWARD üí∏", "BROKE BOY UNLOCKED");
            }
        }
        saveGame();
        display.innerHTML = `
            <div class="gacha-result-icon">${icon}</div>
            <div class="gacha-result-name ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${rarity}</div>
        `;
        updateGachaDisplay();
    }, 2000);
}

function rollPremiumGacha() {
    if ((saveData.gachaCoins || 0) < 1) {
        sfx.play('break');
        alert('Not enough Gacha Coins! Convert 1000 coins or earn from achievements.');
        return;
    }
    saveData.gachaCoins -= 1;
    saveGame();
    updateGachaDisplay();
    sfx.play('ult');
    
    const display = document.getElementById('gacha-display');
    display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';
    
    let frameIndex = 0;
    const animInterval = setInterval(() => {
        const canvas = document.getElementById('gacha-anim-canvas');
        if (!canvas) {
            clearInterval(animInterval);
            return;
        }
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const frame = gachaAnimFrames[frameIndex];
        const pixelSize = 10;
        for (let y = 0; y < frame.length; y++) {
            for (let x = 0; x < frame[y].length; x++) {
                const colorKey = frame[y][x];
                if (gachaColors[colorKey] && colorKey !== '0') {
                    ctx.fillStyle = gachaColors[colorKey];
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
        }
        frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
    }, 100);
    
    setTimeout(() => {
        clearInterval(animInterval);
        
        const roll = Math.random() * 100;
        let reward, rarity, icon, name, desc;
        
        // Premium gacha: guaranteed rare+ (characters and cosmetics)
        if (roll < 20) {
            // 20% - Ultra Rare Characters
            const ultraChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'];
            const unlockedUltra = ultraChars.filter(c => !saveData.unlocks.includes(c));
            if (unlockedUltra.length > 0) {
                reward = unlockedUltra[Math.floor(Math.random() * unlockedUltra.length)];
                const charNames = {thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH'};
                name = charNames[reward];
                rarity = 'ULTRA RARE';
                icon = '‚ú®';
                desc = 'Character Unlocked!';
                saveData.unlocks.push(reward);
                showNotification("‚ú® ULTRA RARE! ‚ú®", `${name} UNLOCKED!`);
            } else {
                reward = 'crown';
                name = 'CROWN';
                rarity = 'RARE';
                icon = 'üëë';
                desc = 'Cosmetic Unlocked!';
                if (!saveData.cosmetics.includes('crown')) saveData.cosmetics.push('crown');
            }
        } else if (roll < 50) {
            // 30% - Rare Characters (only unlockable ones)
            const rareChars = ['luckyblock', 'brokeboy'];
            const unlockedRare = rareChars.filter(c => !saveData.unlocks.includes(c));
            if (unlockedRare.length > 0) {
                reward = unlockedRare[Math.floor(Math.random() * unlockedRare.length)];
                const charNames = {luckyblock: 'LUCKY BLOCK', brokeboy: 'BROKE BOY'};
                name = charNames[reward];
                rarity = 'RARE';
                icon = 'üåü';
                desc = 'Character Unlocked!';
                saveData.unlocks.push(reward);
                showNotification("üåü RARE! üåü", `${name} UNLOCKED!`);
            } else {
                reward = 'shades';
                name = 'SHADES';
                rarity = 'RARE';
                icon = 'üï∂Ô∏è';
                desc = 'Cosmetic Unlocked!';
                if (!saveData.cosmetics.includes('shades')) saveData.cosmetics.push('shades');
            }
        } else {
            // 50% - Cosmetics guaranteed
            const cosmetics = ['tophat', 'shades', 'crown'];
            reward = cosmetics[Math.floor(Math.random() * cosmetics.length)];
            const cosNames = {tophat: 'TOP HAT', shades: 'SHADES', crown: 'CROWN'};
            const cosIcons = {tophat: 'üé©', shades: 'üï∂Ô∏è', crown: 'üëë'};
            name = cosNames[reward];
            icon = cosIcons[reward];
            rarity = 'UNCOMMON';
            desc = 'Cosmetic Unlocked!';
            if (!saveData.cosmetics.includes(reward)) saveData.cosmetics.push(reward);
        }
        
        saveGame();
        display.innerHTML = `
            <div class="gacha-result-icon">${icon}</div>
            <div class="gacha-result-name ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${rarity} - PREMIUM</div>
        `;
        updateGachaDisplay();
    }, 2000);
}

function convertCoinsToGacha() {
    if (saveData.coins < 1000) {
        sfx.play('break');
        alert('You need at least 1000 coins to convert!');
        return;
    }
    if (confirm('Convert 1000 üí∞ to 1 üé´ Gacha Coin?')) {
        saveData.coins -= 1000;
        saveData.gachaCoins = (saveData.gachaCoins || 0) + 1;
        saveGame();
        updateCoinDisplay();
        updateGachaDisplay();
        sfx.play('coin');
        showNotification("üé´ CONVERTED!", "+1 Gacha Coin");
    }
}


window.addEventListener('keydown', e => {
    let key = e.key;
    if (gameState === 'TITLE') {
        // Check each cheat code independently
        let matched = false;
        
        // Cheat Code 1: thememe
        if (key === cheatCode[cheatIndex]) {
            cheatIndex++;
            console.log('[DEBUG] cheatCode1 progress:', cheatIndex, '/', cheatCode.length);
            if (cheatIndex === cheatCode.length) {
                if (!saveData.unlocks.includes('thememe')) {
                    saveData.unlocks.push('thememe'); saveGame();
                    showNotification("SECRET UNLOCKED!", "THE MEME");
                    unlockTrophy('unlock_meme');
                }
                cheatIndex = 0;
            }
            matched = true;
        } else {
            cheatIndex = 0;
        }
        
        // Cheat Code 2: gps
        if (key === cheatCode2[cheatIndex2]) {
            cheatIndex2++;
            console.log('[DEBUG] cheatCode2 progress:', cheatIndex2, '/', cheatCode2.length);
            if (cheatIndex2 === cheatCode2.length) {
                if (!saveData.unlocks.includes('gps')) {
                    saveData.unlocks.push('gps'); saveGame();
                    showNotification("SECRET UNLOCKED!", "GPS");
                    unlockTrophy('unlock_gps');
                }
                cheatIndex2 = 0;
            }
            matched = true;
        } else {
            cheatIndex2 = 0;
        }
        
        // Cheat Code 3: mechabara
        if (key === cheatCode3[cheatIndex3]) {
            cheatIndex3++;
            console.log('[DEBUG] cheatCode3 progress:', cheatIndex3, '/', cheatCode3.length);
            if (cheatIndex3 === cheatCode3.length) {
                if (!saveData.unlocks.includes('mechabara')) {
                    saveData.unlocks.push('mechabara'); saveGame();
                    showNotification("SECRET UNLOCKED!", "MECHA-BARA");
                    unlockTrophy('unlock_mechabara');
                }
                cheatIndex3 = 0;
            }
            matched = true;
        } else {
            cheatIndex3 = 0;
        }
        
        // Cheat Code 4: bluedude
        if (key === cheatCode4[cheatIndex4]) {
            cheatIndex4++;
            console.log('[DEBUG] cheatCode4 progress:', cheatIndex4, '/', cheatCode4.length);
            if (cheatIndex4 === cheatCode4.length) {
                if (!saveData.unlocks.includes('bluedude')) {
                    saveData.unlocks.push('bluedude'); saveGame();
                    showNotification("SECRET UNLOCKED!", "BLUEDUDE");
                    unlockTrophy('unlock_bluedude');
                }
                cheatIndex4 = 0;
            }
            matched = true;
        } else {
            cheatIndex4 = 0;
        }
        
        // Cheat Code 5: glitch
        if (key === cheatCodeGlitch[cheatIndexGlitch]) {
            cheatIndexGlitch++;
            console.log('[DEBUG] cheatCodeGlitch progress:', cheatIndexGlitch, '/', cheatCodeGlitch.length);
            if (cheatIndexGlitch === cheatCodeGlitch.length) {
                if (!saveData.unlocks.includes('glitch')) {
                    saveData.unlocks.push('glitch'); saveGame();
                    showNotification("REALITY BREACHED!", "‚ö° GLITCH UNLOCKED ‚ö°");
                    unlockTrophy('unlock_glitch');
                }
                cheatIndexGlitch = 0;
            }
            matched = true;
        } else {
            cheatIndexGlitch = 0;
        }
        
        // Konami Code
        if (key === cheatCodeKonami[cheatIndexKonami]) {
            cheatIndexKonami++;
            console.log('[DEBUG] Konami progress:', cheatIndexKonami, '/', cheatCodeKonami.length, '- Key pressed:', key);
            if (cheatIndexKonami === cheatCodeKonami.length) {
                const allSecrets = ['thememe','gps','mechabara','bluedude','johnpork','glitch','luckyblock','brokeboy'];
                let unlocked = [];
                allSecrets.forEach(id => {
                    if (!saveData.unlocks.includes(id)) {
                        saveData.unlocks.push(id);
                        unlocked.push(id);
                    }
                });
                // Max mastery for all characters
                if (!saveData.mastery) saveData.mastery = {};
                CHARACTERS.forEach(ch => {
                    if (!saveData.mastery[ch.id]) saveData.mastery[ch.id] = {wins:0,matches:0,damage:0,level:0};
                    saveData.mastery[ch.id].wins = Math.max(saveData.mastery[ch.id].wins, 100);
                    saveData.mastery[ch.id].matches = Math.max(saveData.mastery[ch.id].matches, 100);
                    saveData.mastery[ch.id].level = 5;
                });
                unlocked.push('ALL MASTERIES');
                if (!saveData.goldMode) {
                    saveData.goldMode = true;
                    unlocked.push('gold mode');
                }
                const allCosmetics = ['tophat','shades','crown'];
                allCosmetics.forEach(cos => {
                    if (!saveData.cosmetics.includes(cos)) {
                        saveData.cosmetics.push(cos);
                        unlocked.push(cos);
                    }
                });
                saveData.coins += 2000;
                saveData.gachaCoins = (saveData.gachaCoins || 0) + 3;
                unlocked.push('2000 coins', '3 gacha coins');
                saveGame();
                updateCoinDisplay();
                renderCharGrid && renderCharGrid();
                // Check if Jack should be unlocked
                checkJackUnlock();
                showNotification("KONAMI CODE!", `SECRETS + MASTERIES!<br>${unlocked.map(u=>u.toUpperCase()).join(', ')}`);
                sfx.play('coin');
                cheatIndexKonami = 0;
                if (typeof renderMastery === 'function' && document.getElementById('mastery-screen') && !document.getElementById('mastery-screen').classList.contains('hidden')) {
                    renderMastery();
                }
            }
            matched = true;
        } else if (!matched) {
            cheatIndexKonami = 0;
        }
        
        // Pork Code
        if (key === cheatCodePork[cheatIndexPork]) {
            cheatIndexPork++;
            console.log('[DEBUG] cheatCodePork progress:', cheatIndexPork, '/', cheatCodePork.length);
            if (cheatIndexPork === cheatCodePork.length) {
                if (!saveData.unlocks.includes('johnpork')) {
                    saveData.unlocks.push('johnpork'); saveGame();
                    showNotification("SECRET UNLOCKED!", "JOHN PORK");
                    unlockTrophy('unlock_johnpork');
                    renderCharGrid();
                }
                cheatIndexPork = 0;
            }
            matched = true;
        } else {
            cheatIndexPork = 0;
        }
        
        // Gacha Code
        if (key === cheatCodeGacha[cheatIndexGacha]) {
            cheatIndexGacha++;
            console.log('[DEBUG] cheatCodeGacha progress:', cheatIndexGacha, '/', cheatCodeGacha.length);
            if (cheatIndexGacha === cheatCodeGacha.length) {
                console.log('[DEBUG] Gacha code complete! Current unlocks:', saveData.unlocks);
                if (!saveData.unlocks.includes('luckyblock')) {
                    saveData.unlocks.push('luckyblock'); 
                    saveGame();
                    showNotification("SECRET UNLOCKED!", "LUCKY BLOCK");
                    console.log('[DEBUG] Unlocked luckyblock. New unlocks:', saveData.unlocks);
                } else {
                    console.log('[DEBUG] luckyblock already unlocked');
                }
                if (!saveData.unlocks.includes('brokeboy')) {
                    saveData.unlocks.push('brokeboy'); 
                    saveGame();
                    showNotification("SECRET UNLOCKED!", "BROKE BOY");
                    console.log('[DEBUG] Unlocked brokeboy. New unlocks:', saveData.unlocks);
                } else {
                    console.log('[DEBUG] brokeboy already unlocked');
                }
                renderCharGrid();
                cheatIndexGacha = 0;
            }
            matched = true;
        } else {
            cheatIndexGacha = 0;
        }
    }
    keys[key] = !0;
    if (gameState === 'GAME' && (key === 'Escape' || key === 'p')) togglePause();
});
window.addEventListener('keyup', e => {
    keys[e.key] = !1;
    if (isTraining) {
        if (e.key === '1') {
            trainingCpuMode = (trainingCpuMode + 1) % 4;
            const m = ["STAND", "JUMP", "ATK", "EVADE"];
            document.getElementById('train-cpu-mode').innerText = m[trainingCpuMode];
        }
        if (e.key === '2') {
            players.forEach(p => p.pct = 0);
            updateHUD();
            sfx.play('coin');
        }
        if (e.key === '3') {
            players[0].x = -200;
            players[0].y = 0;
            players[0].vx = 0;
            players[1].x = 200;
            players[1].y = 0;
            players[1].vx = 0;
            sfx.play('jump');
        }
        if (e.key === '4') {
            toggleHitboxSetting();
            document.getElementById('train-hitbox').innerText = showHitboxes ? "ON" : "OFF";
        }
    }
});
function startLocal() {
    music.init();
    sfx.init();
    isSurvival = !1;
    isTraining = !1;
    isMemeBall = !1;
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('char-select').classList.remove('hidden');
    document.getElementById('cpu-controls').classList.remove('hidden');
    renderCharGrid();
    music.play('MENU');
}
function startOnline() {
    music.init();
    audioFiles.init();
    sfx.init();
    isSurvival = !1; isTraining = !1; isMemeBall = !1; isOnline = true; isHost = false; netPeerReady = false;
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('online-screen').classList.remove('hidden');
    document.getElementById('online-status').textContent = '';
}
function hideOnline() {
    document.getElementById('online-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
    try { if (netSocket) { netSocket.close(); netSocket = null; } } catch(e) {}
    isOnline = false; isHost = false; netRoom = null; netPeerReady = false;
}
function hostRoom() {
    const nickInput = document.getElementById('online-nickname');
    const nickname = (nickInput && nickInput.value.trim()) || 'Host';
    isHost = true; isOnline = true; netRoom = Math.random().toString(36).slice(2,8).toUpperCase(); netReadyCount = 0; netPeerReady = false;
    netConnectedPlayers = [{id:'host', name:nickname + ' (Host)', ready:true}];
    netGameMode = '1v1';
    document.getElementById('online-room-code').textContent = netRoom;
    const box = document.getElementById('online-start-box'); if (box) box.style.display='none';
    const lobby = document.getElementById('online-lobby-list'); if (lobby) lobby.style.display='none';
    initSocket();
}
function joinRoom() {
    const code = (document.getElementById('online-join-code').value||'').trim().toUpperCase();
    if (!code) { document.getElementById('online-status').textContent = 'Enter a room code'; return; }
    const nickInput = document.getElementById('online-nickname');
    const nickname = (nickInput && nickInput.value.trim()) || 'Player';
    isHost = false; isOnline = true; netRoom = code; netReadyCount = 0; netPeerReady = false;
    netConnectedPlayers = [];
    const box = document.getElementById('online-start-box'); if (box) box.style.display='none';
    const lobby = document.getElementById('online-lobby-list'); if (lobby) lobby.style.display='none';
    initSocket();
}
function normalizeWSURL(raw) {
    let u = (raw || '').trim();
    if (!u) return 'ws://localhost:8080';
    // Convert http/https schemes
    if (u.startsWith('http://')) u = 'ws://' + u.slice(7);
    else if (u.startsWith('https://')) u = 'wss://' + u.slice(8);
    // If user pasted a railway/render domain without protocol
    if (!u.startsWith('ws://') && !u.startsWith('wss://')) {
        // Prefer ws for local dev, wss for remote
        if (u.startsWith('localhost') || u.startsWith('127.') || u.startsWith('192.168.') ) {
            u = 'ws://' + u;
        } else {
            u = 'wss://' + u;
        }
    }
    return u;
}
function initSocket() {
    netOpened = false;
    try {
        const urlInput = document.getElementById('online-ws-url');
        const WS_URL = normalizeWSURL(urlInput && urlInput.value ? urlInput.value : 'ws://localhost:8080');
        const st = document.getElementById('online-status');
        if (st) st.textContent = 'Connecting to ' + WS_URL + ' ...';
        netSocket = new WebSocket(WS_URL);
        netSocket.onerror = () => {
            const st2 = document.getElementById('online-status');
            if (st2) st2.textContent = 'Connection failed. Ensure a WebSocket server is running at that URL (use wss:// for hosted domains).';
        };
        netSocket.onclose = () => {
            // Only show Disconnected if connection was previously opened
            const st = document.getElementById('online-status');
            if (netOpened && st && isOnline) {
                st.textContent = 'Disconnected';
                // If disconnect happens mid-match, pause and show notification
                if (gameState === 'GAME' && !netDisconnected) {
                    netDisconnected = true;
                    gameState = 'PAUSED';
                    showDisconnectNotification();
                }
            }
        };
    } catch(e) {
        const st = document.getElementById('online-status');
        if (st) st.textContent = 'Server connection failed. Check server URL and availability.';
        return;
    }
    netSocket.onopen = () => {
        netOpened = true;
        const nickInput = document.getElementById('online-nickname');
        const nickname = (nickInput && nickInput.value.trim()) || 'Player';
        sendNet({t:'join', room: netRoom, host: !!isHost, nickname: nickname});
        document.getElementById('online-status').textContent = 'Joined relay. Negotiating room...';
    };
    netSocket.onmessage = ev => {
        let msg; try { msg = JSON.parse(ev.data); } catch(e) { return; }
        if (msg.t === 'joined') {
            document.getElementById('online-status').textContent = 'Room created. Waiting for players...';
            updateLobbyList();
            initOnlineCharSelect();
        } else if (msg.t === 'playerlist') {
            // Server sends updated player list
            if (msg.players) {
                const oldCount = netConnectedPlayers.length;
                netConnectedPlayers = msg.players;
                const newCount = netConnectedPlayers.length;
                // If player left during match, pause and notify
                if (gameState === 'GAME' && newCount < oldCount && !netDisconnected) {
                    netDisconnected = true;
                    gameState = 'PAUSED';
                    showDisconnectNotification();
                }
                netReadyCount = msg.players.length;
                updateLobbyList();
                if (isHost) {
                    const minPlayers = (netGameMode === '2v2') ? 4 : 2;
                    if (netReadyCount >= minPlayers) {
                        netPeerReady = true;
                        document.getElementById('online-status').textContent = `Ready! ${netReadyCount}/${minPlayers} players`;
                        const box = document.getElementById('online-start-box'); if (box) box.style.display='flex';
                        initOnlineCharSelect();
                    } else {
                        document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers} players`;
                        const box = document.getElementById('online-start-box'); if (box) box.style.display='none';
                    }
                } else {
                    document.getElementById('online-status').textContent = 'Connected! Waiting for host...';
                    netPeerReady = true;
                }
            }
        } else if (msg.t === 'ready') {
            // Legacy ready handling (fallback if server doesn't send playerlist)
            netReadyCount++;
            if (isHost) {
                const minPlayers = (netGameMode === '2v2') ? 4 : 2;
                if (netReadyCount >= minPlayers) {
                    netPeerReady = true;
                    document.getElementById('online-status').textContent = `Player joined! ${netReadyCount}/${minPlayers}`;
                    const box = document.getElementById('online-start-box'); if (box) box.style.display='flex';
                } else {
                    document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers}`;
                }
            } else {
                document.getElementById('online-status').textContent = 'Connected! Waiting for host...';
                netPeerReady = true;
            }
        } else if (msg.t === 'inp' && isHost) {
            // Host maps client inputs to player slots (P2, P3, P4) by playerId
            const k = msg.k; const v = msg.v ? 1 : 0;
            const pid = msg.playerId;
            
            // Assign player slot based on connection order
            let slot = 'p2'; // default
            const playerIndex = netConnectedPlayers.findIndex(p => p.id === pid);
            if (playerIndex === 1) slot = 'p2';
            else if (playerIndex === 2) slot = 'p3';
            else if (playerIndex === 3) slot = 'p4';
            
            try {
                // All online players use WASD by default
                const left = getControl(slot,'left') || 'a';
                const right = getControl(slot,'right') || 'd';
                const up = getControl(slot,'up') || 'w';
                const down = getControl(slot,'down') || 's';
                const attack = getControl(slot,'attack') || 'f';
                const ult = getControl(slot,'ult') || 'r';
                const shield = getControl(slot,'shield') || 'g';
                const eq = (a,b) => (a===b) || (a && b && a.toLowerCase && b.toLowerCase && a.toLowerCase()===b.toLowerCase());
                
                let targetInputs = netP2Inputs;
                if (slot === 'p3') targetInputs = netP3Inputs;
                else if (slot === 'p4') targetInputs = netP4Inputs;
                
                if (eq(k,left)) targetInputs.l = v;
                if (eq(k,right)) targetInputs.r = v;
                if (eq(k,up)) { targetInputs.u = v; targetInputs.j = v; }
                if (eq(k,down)) targetInputs.d = v;
                if (eq(k,attack)) targetInputs.a = v;
                if (eq(k,ult)) targetInputs.U = v;
                if (eq(k,shield)) targetInputs.S = v;
            } catch(e) {}
        } else if (msg.t === 'start') {
            // Host instructs client to start with chosen settings
            isMemeBall = msg.mode === 'meme'; isSurvival = false; isTraining = false;
            netGameMode = msg.gameMode || '1v1'; // Receive mode from host
            p1Char = CHARACTERS.find(c=>c.id===msg.p1);
            p2Char = CHARACTERS.find(c=>c.id===msg.p2);
            selectedMap = MAPS.find(m=>m.id===msg.map) || MAPS[0];
            customStocks = msg.stocks || 3;
            rulesItemsEnabled = msg.items !== undefined ? msg.items : true;
            rulesHazardsEnabled = msg.hazards !== undefined ? msg.hazards : true;
            rulesTeamAttack = msg.teamAttack || false;
            const ts = document.getElementById('title-screen'); if (ts) ts.classList.add('hidden');
            const os = document.getElementById('online-screen'); if (os) os.classList.add('hidden');
            const sb = document.getElementById('online-start-box'); if (sb) sb.style.display='none';
            const hud = document.getElementById('hud'); if (hud) hud.classList.remove('hidden');
            // Initialize scene but as client renderer
            if (isMemeBall) beginMemeBall(); else startGame();
        } else if (msg.t === 'state') {
            applyNetState(msg.s);
        } else if (msg.t === 'ping') {
            sendNet({t:'pong'});
        }
    };
    netSocket.onclose = () => {
        if (isOnline) document.getElementById('online-status').textContent = 'Disconnected';
    };
}
function showDisconnectNotification(isHostDisconnect = false) {
    // Create overlay notification
    const overlay = document.createElement('div');
    overlay.id = 'disconnect-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center';
    const title = document.createElement('div');
    title.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#ff4444;margin-bottom:20px";
    title.textContent = isHostDisconnect ? 'HOST DISCONNECTED' : 'PLAYER DISCONNECTED';
    const msg = document.createElement('div');
    msg.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#fff;margin-bottom:30px;text-align:center;max-width:500px;line-height:1.8";
    msg.textContent = isHostDisconnect ? 'The host has left the match.' : 'A player has disconnected from the match.';
    const btn = document.createElement('button');
    btn.className = 'menu-btn';
    btn.textContent = 'RETURN TO LOBBY';
    btn.onclick = () => {
        document.body.removeChild(overlay);
        hideOnline();
        showTitle();
    };
    overlay.appendChild(title);
    overlay.appendChild(msg);
    overlay.appendChild(btn);
    document.body.appendChild(overlay);
}
function showDisconnectNotification(isHostDisconnect = false) {
    // Create overlay notification
    const overlay = document.createElement('div');
    overlay.id = 'disconnect-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center';
    const title = document.createElement('div');
    title.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#ff4444;margin-bottom:20px";
    title.textContent = isHostDisconnect ? 'HOST DISCONNECTED' : 'PLAYER DISCONNECTED';
    const msg = document.createElement('div');
    msg.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#fff;margin-bottom:30px;text-align:center;max-width:500px;line-height:1.8";
    msg.textContent = isHostDisconnect ? 'The host has left the match.' : 'A player has disconnected from the match.';
    const btn = document.createElement('button');
    btn.className = 'menu-btn';
    btn.textContent = 'RETURN TO LOBBY';
    btn.onclick = () => {
        document.body.removeChild(overlay);
        hideOnline();
        showTitle();
    };
    overlay.appendChild(title);
    overlay.appendChild(msg);
    overlay.appendChild(btn);
    document.body.appendChild(overlay);
}
function sendNet(obj) { try { if (netSocket && netSocket.readyState===1) netSocket.send(JSON.stringify(obj)); } catch(e) {} }

function selectOnlineMode(mode) {
    if (!isHost) return;
    netGameMode = mode;
    // Update button styles
    const btn1v1 = document.getElementById('mode-1v1-btn');
    const btn2v2 = document.getElementById('mode-2v2-btn');
    if (mode === '1v1') {
        if (btn1v1) { btn1v1.style.background = '#0f0'; btn1v1.style.color = '#000'; }
        if (btn2v2) { btn2v2.style.background = ''; btn2v2.style.color = ''; }
    } else {
        if (btn1v1) { btn1v1.style.background = ''; btn1v1.style.color = ''; }
        if (btn2v2) { btn2v2.style.background = '#0f0'; btn2v2.style.color = '#000'; }
    }
    // Re-check player count requirement
    const minPlayers = (netGameMode === '2v2') ? 4 : 2;
    if (netReadyCount >= minPlayers) {
        netPeerReady = true;
        document.getElementById('online-status').textContent = `Ready! ${netReadyCount}/${minPlayers} players`;
        const box = document.getElementById('online-start-box'); if (box) box.style.display='flex';
    } else {
        netPeerReady = false;
        document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers} players`;
        const box = document.getElementById('online-start-box'); if (box) box.style.display='none';
    }
}

function updateLobbyList() {
    const listEl = document.getElementById('online-player-list');
    const lobbyEl = document.getElementById('online-lobby-list');
    const ctrlEl = document.getElementById('online-controls-help');
    if (!listEl || !lobbyEl) return;
    
    if (netConnectedPlayers.length > 0) {
        lobbyEl.style.display = 'flex';
        if (ctrlEl) ctrlEl.style.display = 'flex';
        let html = '';
        netConnectedPlayers.forEach((p, i) => {
            const icon = p.ready ? '‚úì' : '‚óã';
            const color = p.ready ? '#0f0' : '#888';
            html += `<div style="color:${color}">${icon} ${p.name || 'Player ' + (i+1)}</div>`;
        });
        listEl.innerHTML = html;
    } else {
        lobbyEl.style.display = 'none';
        if (ctrlEl) ctrlEl.style.display = 'none';
    }
}

function initOnlineCharSelect() {
    try {
        const p1Sel = document.getElementById('online-p1-char');
        const p2Sel = document.getElementById('online-p2-char');
        if (!p1Sel || !p2Sel) return;
        // Populate options
        const makeOpts = sel => {
            sel.innerHTML = '';
            CHARACTERS.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id; opt.textContent = `${c.icon} ${c.name}`;
                sel.appendChild(opt);
            });
        };
        makeOpts(p1Sel); makeOpts(p2Sel);
        // Set defaults
        p1Sel.value = (p1Char && p1Char.id) || 'doge';
        p2Sel.value = (p2Char && p2Char.id) || 'chad';
        const prev = document.getElementById('online-picked-preview');
        const renderPrev = () => {
            const c1 = CHARACTERS.find(x=>x.id===p1Sel.value);
            const c2 = CHARACTERS.find(x=>x.id===p2Sel.value);
            if (prev) prev.textContent = `P1: ${c1 ? (c1.icon+ ' ' + c1.name) : p1Sel.value} | P2: ${c2 ? (c2.icon+ ' ' + c2.name) : p2Sel.value}`;
        };
        p1Sel.onchange = renderPrev; p2Sel.onchange = renderPrev; renderPrev();
    } catch(e) {}
}

function onlineStart(mode) {
    if (!isHost || !netPeerReady) return;
    try {
        // Default characters if not chosen yet
        const p1Sel = document.getElementById('online-p1-char');
        const p2Sel = document.getElementById('online-p2-char');
        const p1Pick = p1Sel && p1Sel.value ? p1Sel.value : ((p1Char && p1Char.id) || 'doge');
        const p2Pick = p2Sel && p2Sel.value ? p2Sel.value : ((p2Char && p2Char.id) || 'chad');
        p1Char = CHARACTERS.find(c=>c.id===p1Pick) || CHARACTERS.find(c=>c.id==='doge') || CHARACTERS[0];
        p2Char = CHARACTERS.find(c=>c.id===p2Pick) || CHARACTERS.find(c=>c.id==='chad') || CHARACTERS[1];
        const stageSel = document.getElementById('online-stage-sel');
        const stocksInput = document.getElementById('online-stocks');
        const stageId = (stageSel && stageSel.value) || 'flat';
        const stocks = (stocksInput && parseInt(stocksInput.value)) || 3;
        customStocks = stocks; // Set global for host
        // Read custom rules
        const itemsCheck = document.getElementById('online-items');
        const hazardsCheck = document.getElementById('online-hazards');
        const teamAttackCheck = document.getElementById('online-teamattack');
        rulesItemsEnabled = itemsCheck ? itemsCheck.checked : true;
        rulesHazardsEnabled = hazardsCheck ? hazardsCheck.checked : true;
        rulesTeamAttack = teamAttackCheck ? teamAttackCheck.checked : false;
        selectedMap = MAPS.find(m=>m.id===stageId) || MAPS[0];
        sendNet({t:'start', mode: mode === 'meme' ? 'meme' : 'vs', gameMode: netGameMode, p1: p1Char.id, p2: p2Char.id, map: selectedMap.id, stocks: stocks, items: rulesItemsEnabled, hazards: rulesHazardsEnabled, teamAttack: rulesTeamAttack});
        document.getElementById('online-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        isSurvival = false; isTraining = false; isMemeBall = (mode === 'meme');
        if (isMemeBall) beginMemeBall(); else startGame();
    } catch(e) {}
}

// Client: capture inputs and send to host
window.addEventListener('keydown', e => {
    if (isOnline && !isHost && netPeerReady) sendNet({t:'inp', k:e.key, v:1});
});
window.addEventListener('keyup', e => {
    if (isOnline && !isHost && netPeerReady) sendNet({t:'inp', k:e.key, v:0});
});

function applyNetState(s) {
    try {
        if (!isOnline || isHost) return;
        // players - sync all received player states
        if (players && s.players) {
            const numPlayers = Math.min(players.length, s.players.length);
            for (let i=0; i<numPlayers; i++) {
                const sp = s.players[i];
                if (!players[i] || !sp) continue;
                players[i].x = sp.x; players[i].y = sp.y; players[i].vx = sp.vx; players[i].vy = sp.vy;
                players[i].pct = sp.pct; players[i].stocks = sp.stocks; players[i].ult = sp.ult;
            }
            // Refresh HUD to reflect authoritative host values (damage %, stocks, ult charge)
            if (typeof updateHUD === 'function') updateHUD();
        }
        if (typeof isMemeBall !== 'undefined' && s.ball && ball) {
            ball.x = s.ball.x; ball.y = s.ball.y; ball.vx = s.ball.vx; ball.vy = s.ball.vy;
            ball.inPlay = s.ball.inPlay; ball.hasCrossedNet = s.ball.cross;
        }
        if (typeof p1Score !== 'undefined' && s.score) {
            p1Score = s.score[0]; p2Score = s.score[1];
            const sc = document.getElementById('game-score-val'); if (sc) sc.innerText = `${p1Score} - ${p2Score}`;
        }
    } catch(e) {}
}
function startSurvival() {
    music.init();
    sfx.init();
    isSurvival = !0;
    isTraining = !1;
    isMemeBall = !1;
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('char-select').classList.remove('hidden');
    document.getElementById('cpu-controls').classList.remove('hidden');
    document.getElementById('select-instruction').innerText = "CHOOSE YOUR HEROES";
    renderCharGrid();
    music.play('MENU');
}
function startTraining() {
    music.init();
    sfx.init();
    isTraining = !0;
    isSurvival = !1;
    isMemeBall = !1;
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('char-select').classList.remove('hidden');
    document.getElementById('cpu-controls').classList.add('hidden');
    document.getElementById('select-instruction').innerText = "CHOOSE HERO";
    renderCharGrid();
    music.play('MENU');
}
function startSpectator() {
    music.init();
    sfx.init();
    isTraining = !1;
    isSurvival = !1;
    isMemeBall = !1;
    
    // Auto-select two random unlocked characters
    const unlocked = CHARACTERS.filter(c => saveData.unlocks.includes(c.id));
    if (unlocked.length < 2) {
        alert('Unlock more characters to use Spectator Mode!');
        return;
    }
    
    p1Char = unlocked[Math.floor(Math.random() * unlocked.length)];
    p2Char = unlocked[Math.floor(Math.random() * unlocked.length)];
    while (p2Char.id === p1Char.id) {
        p2Char = unlocked[Math.floor(Math.random() * unlocked.length)];
    }
    
    // Set both to CPU
    p2IsCpu = true;
    
    // Random map
    selectedMap = MAPS[Math.floor(Math.random() * MAPS.length)];
    
    showNotification('SPECTATOR MODE', `${p1Char.name} VS ${p2Char.name}`);
    
    // Start immediately
    document.getElementById('title-screen').classList.add('hidden');
    setTimeout(() => {
        document.getElementById('hud').classList.remove('hidden');
        initGame();
        saveMatchSettings();
        gameState = 'GAME';
        music.play('BATTLE');
        loop();
    }, 1000);
}
function startMemeBall() {
    music.init();
    sfx.init();
    isMemeBall = !0;
    isSurvival = !1;
    isTraining = !1;
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('char-select').classList.remove('hidden');
    document.getElementById('cpu-controls').classList.add('hidden');
    document.getElementById('select-instruction').innerText = "CHOOSE PLAYER";
    renderCharGrid();
    music.play('MENU');
}
function showMoves() {
        sfx.init();
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('moves-screen').classList.remove('hidden');
    // Hide overlapping HUD elements while viewing moves
    const coin = document.getElementById('coin-display'); if (coin) coin.dataset.prevDisplay = coin.style.display, coin.style.display='none';
    const warn = document.getElementById('mega-warning'); if (warn) warn.dataset.prevDisplay = warn.style.display, warn.style.display='none';
    const secret = document.getElementById('secret-unlock'); if (secret) secret.dataset.prevDisplay = secret.style.display, secret.style.display='none';
        const c = document.getElementById('moves-content');
        c.innerHTML = `
        <div>
            <h3>Universal Moves (All Characters)</h3>
            <ul>
                <li><strong>Neutral Attack</strong> (F/L): 8% dmg ‚Ä¢ low KB ‚Ä¢ 30f CD.</li>
                <li><strong>Side Attack</strong> (‚Üê/‚Üí + F/L): 12% dmg ‚Ä¢ med-high horiz KB ‚Ä¢ 30f CD.</li>
                <li><strong>Up Attack</strong> (‚Üë + F/L): 10% dmg ‚Ä¢ high vertical KB ‚Ä¢ 30f CD.</li>
                <li><strong>Down Attack</strong> (‚Üì + F/L): 10% dmg ‚Ä¢ pop-up ‚Ä¢ 30f CD.</li>
            </ul>
        </div>
        <h3>Roster Details</h3>
        <div class="moves-grid" id="moves-grid"></div>
        `;

            // Add CSS to make modal work properly
            const styleTagId = 'moves-modal-style';
            if (!document.getElementById(styleTagId)) {
                const style = document.createElement('style');
                style.id = styleTagId;
                style.textContent = `
                    #moves-screen { padding-top: 20px; }
                    #move-detail { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 500; }
                    #move-detail.show { display: flex; }
                    .move-card { cursor: pointer; transition: transform 0.2s; }
                    .move-card:hover { transform: scale(1.02); }
                `;
                document.head.appendChild(style);
            }

            // Define complete character detail content map before cards are built
            window._moveDetailContent = {
                'doge': {
                    specials: 'Uses universal moveset.',
                    ult: 'Moon Crash: Summon falling moon at opponent; strong projectile for pressure and kills.'
                },
                'frog': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'cat': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'capy': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'spongy': {
                    specials: 'Uses universal moveset. Low weight makes combo-friendly.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'troll': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'sanic': {
                    specials: 'Universal standard attacks.',
                    ult: 'Light Speed: Teleport to opponent, 30% hit, 1s invincibility.'
                },
                'chad': {
                    specials: 'Universal; high power/weight amplify effectiveness.',
                    ult: 'Giga Stun: 180f stun; guaranteed follow-up setup.'
                },
                '67kid': {
                    specials: 'Up: Self 67% dmg + stun. Down: Ground pound, 10% dmg, strong vertical KB.',
                    ult: 'Brain Rot: Reverse opponent velocity + 60f stun; gimp recoveries.'
                },
                'amogus': {
                    specials: 'Side: Vent dash (no hitbox). Up: High vertical recovery.',
                    ult: 'Emergency Meeting: Screen nuke ~50% dmg.'
                },
                'sahur': {
                    specials: 'Down: 200x40 hitbox, 20% dmg. Up: 12% dmg, very high vertical KB. Side: 15% dmg high KB.',
                    ult: 'Deafening Beat: 180f stun; setup tool.'
                },
                'primo': {
                    specials: 'Down: Wide ground-pound. Up: Diagonal recovery with hitbox. Side: Fast dash 12% dmg.',
                    ult: 'Tag Team: Summon projectile Primo across screen.'
                },
                'ocralito': {
                    specials: 'Down: 150px belly flop 14%. Up: Safe vertical recovery 10%. Side: Belly slide reduces friction to 0.98.',
                    ult: 'Deep Freeze: 120f stun.'
                },
                'mechabara': {
                    specials: 'Down: Ground Laser pops up (16%). Up: Huge vertical jump (10%). Side: Drill Lunge multi-hit.',
                    ult: 'Orbital Strike: Falling projectile (moon style).'
                },
                'bluedude': {
                    specials: 'Down: 15f parry + 25% counter. Up: 100x100 spin 12%. Side: Blade Dash 9%.',
                    ult: 'Zero Slash: Massive close-range slash, 35%.'
                },
                'johnpork': {
                    specials: 'Down: Global 10%. Up: Random buff 5s. Side: 120f stun.',
                    ult: 'Pig Slam: Falling pig, extreme KB, 100%.'
                },
                'thememe': {
                    specials: 'All stats 999; universal moves overpower.',
                    ult: 'DEATH: 999%.'
                },
                'gps': {
                    specials: 'Down: Confuse 5s. Up: Vertical teleport. Side: Horizontal teleport.',
                    ult: 'Global Rotation: Flip stage physics ~10s.'
                },
                'luckyblock': {
                    specials: 'Side: 50% chance for 5x rapid 100% hits. Up: Spawn coin + delayed hit. Down: Crush from above.',
                    ult: 'Gambling Fever: Random slot machine buffs for 20s.'
                },
                'brokeboy': {
                    specials: 'Side: Beg/boost chance; side animation. Up: Sucker Punch with custom animation. Down: Parry (shield).',
                    ult: 'Mrbeast: Temporary power/speed/weight/inv boost; plays unique ult animation.'
                },
                'glitch': {
                    specials: 'Side: Pixel Shift (70% forward/30% reverse dash). Up: Data Corruption (random teleport + 10% position swap). Down: Reality Break (50% stun opponent 60f OR self 30f).',
                    ult: 'System Crash: Reverse opponent controls 3s + 1.5x damage.'
                }
            };

            // Build roster cards if not already and attach handlers
            const grid = document.getElementById('moves-grid');
            if (grid) {
                // If grid is empty, build from available CHARACTERS
                if (!grid.children.length && typeof CHARACTERS !== 'undefined' && Array.isArray(CHARACTERS)) {
                    const toCard = (ch) => {
                        const stats = `<span class=statline>Speed: ${ch.speed} ‚Ä¢ Power: ${ch.power} ‚Ä¢ Jump: ${ch.jump} ‚Ä¢ Weight: ${ch.weight}</span>`;
                        return `
                        <div class="move-card" data-char-key="${ch.id}">
                          <div class="move-thumb"><canvas width="16" height="16" id="moves-thumb-${ch.id}" style="width:48px;height:48px"></canvas></div>
                          <div class="move-details">
                            <div class="move-title">${ch.name}</div>
                            ${stats}
                            <div><span class="badge">SIDE</span>${ch.moves.side}</div>
                            <div><span class="badge">UP</span>${ch.moves.up}</div>
                            <div><span class="badge">DOWN</span>${ch.moves.down}</div>
                            <div><span class="badge">ULT</span>${ch.moves.ult}</div>
                          </div>
                        </div>`;
                    };
                    grid.innerHTML = CHARACTERS.map(toCard).join('');
                    // Render thumbnails
                    CHARACTERS.forEach(ch => {
                        const cvs = document.getElementById(`moves-thumb-${ch.id}`);
                        if (!cvs) return;
                        const mctx = cvs.getContext('2d');
                        mctx.imageSmoothingEnabled = !1;
                        const spr = characterSprites[ch.id];
                        if (spr) {
                            if (spr.idle && spr.idle[0]) {
                                mctx.drawImage(spr.idle[0], 0, 0, cvs.width, cvs.height);
                            } else {
                                mctx.drawImage(spr, 0, 0, cvs.width, cvs.height);
                            }
                        } else {
                            mctx.font = "16px Arial";
                            mctx.textAlign = "center";
                            mctx.textBaseline = "middle";
                            mctx.fillText(ch.icon || '?', 8, 8);
                        }
                    });
                }

                const openModal = (ch, entry) => {
                    const modalEl = document.getElementById('move-detail');
                    if (!modalEl) return;
                    document.getElementById('move-detail-title').innerText = ch?.name || 'Character';
                    document.getElementById('move-detail-stats').innerHTML = `Speed: ${ch?.speed || '‚Äî'} ‚Ä¢ Power: ${ch?.power || '‚Äî'} ‚Ä¢ Jump: ${ch?.jump || '‚Äî'} ‚Ä¢ Weight: ${ch?.weight || '‚Äî'}`;
                    document.getElementById('move-detail-universal').innerHTML = `<strong>Universal Attacks</strong><br>Neutral: 8% dmg ‚Ä¢ low KB ‚Ä¢ 30f CD<br>Side: 12% dmg ‚Ä¢ med-high horiz KB ‚Ä¢ 30f CD<br>Up: 10% dmg ‚Ä¢ high vertical KB ‚Ä¢ 30f CD<br>Down: 10% dmg ‚Ä¢ pop-up ‚Ä¢ 30f CD`;
                    document.getElementById('move-detail-specials').innerHTML = `<strong>Special Moves</strong><br>${entry.specials}`;
                    document.getElementById('move-detail-ult').innerHTML = `<strong>Ultimate</strong><br>${entry.ult}`;
                    modalEl.classList.add('show');
                };

                const closeModal = () => {
                    const modalEl = document.getElementById('move-detail');
                    if (modalEl) modalEl.classList.remove('show');
                };
                // Make closeModal available globally for the CLOSE button
                window.closeMoveDetail = closeModal;

                // Close handlers
                const closeBtn = document.getElementById('move-detail-close');
                if (closeBtn) closeBtn.onclick = closeModal;
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeModal();
                });
                document.getElementById('move-detail')?.addEventListener('click', (e) => {
                    if (e.target.id === 'move-detail') closeModal();
                });

                // Card click handlers
                Array.from(grid.children).forEach((el) => {
                    if (!el.dataset.bound) {
                        el.dataset.bound = '1';
                        el.addEventListener('click', () => {
                            const key = el.getAttribute('data-char-key');
                            const ch = CHARACTERS.find(c => c.id === key);
                            const entry = window._moveDetailContent?.[key] || { specials: 'Uses universal moves.', ult: 'Default ult' };
                            openModal(ch, entry);
                        });
                    }
                });
            }
        // Old card build removed to prevent duplicate variable declarations and handlers
}
function hideMoves() {
    document.getElementById('moves-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
    // Restore HUD elements
    const coin = document.getElementById('coin-display'); if (coin) coin.style.display = coin.dataset.prevDisplay || '';
    const warn = document.getElementById('mega-warning'); if (warn) warn.style.display = warn.dataset.prevDisplay || '';
    const secret = document.getElementById('secret-unlock'); if (secret) secret.style.display = secret.dataset.prevDisplay || '';
}
function openMoveDetail(id){
    const ch = CHARACTERS.find(c=>c.id===id);
    if (!ch) return;
    const md = document.getElementById('move-detail');
    md.style.display = 'flex';
    document.getElementById('move-detail-title').innerText = ch.name;
    document.getElementById('move-detail-stats').innerHTML = `Speed: ${ch.speed} ‚Ä¢ Power: ${ch.power} ‚Ä¢ Jump: ${ch.jump} ‚Ä¢ Weight: ${ch.weight}`;
    const uni = document.getElementById('move-detail-universal');
    uni.innerHTML = `<strong>Universal Attacks</strong><br>Neutral 8% ‚Ä¢ Side 12% ‚Ä¢ Up 10% ‚Ä¢ Down 10% ‚Ä¢ Typical CD: 30f`;
    const spec = document.getElementById('move-detail-specials');
    const ult = document.getElementById('move-detail-ult');
    const entry = (window._moveDetailContent||{})[id]||{specials:'Uses universal moves.',ult:'Default ult'};
    spec.innerHTML = `<strong>Specials</strong><br>${entry.specials}`;
    ult.innerHTML = `<strong>Ult</strong><br>${entry.ult}`;
    // Render thumb
    const cvs = document.getElementById('move-detail-thumb');
    const ctx2 = cvs.getContext('2d');
    ctx2.clearRect(0,0,cvs.width,cvs.height);
    ctx2.imageSmoothingEnabled = !1;
    const spr = characterSprites[id];
    if (spr) {
        if (spr.idle && spr.idle[0]) ctx2.drawImage(spr.idle[0], 0, 0, cvs.width, cvs.height);
        else ctx2.drawImage(spr, 0, 0, cvs.width, cvs.height);
    } else {
        ctx2.font = "48px Arial"; ctx2.textAlign='center'; ctx2.textBaseline='middle'; ctx2.fillText(ch.icon||'?', cvs.width/2, cvs.height/2);
    }
}
function closeMoveDetail(){
    document.getElementById('move-detail').style.display = 'none';
}
function openSettings() {
    sfx.init();
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('settings-screen').classList.remove('hidden');
    updateMobileControlsSetting();
}
function closeSettings() {
    document.getElementById('settings-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
}
function deleteSaveFile() {
    if (confirm('Are you sure you want to delete your save file? This will reset all progress, coins, unlocks, and cosmetics. This action cannot be undone!')) {
        localStorage.removeItem(SAVE_KEY);
        alert('Save file deleted! The game will now reload.');
        location.reload();
    }
}
function toggleHitboxSetting() {
    showHitboxes = !showHitboxes;
    const b = document.getElementById('btn-hitbox');
    if (showHitboxes) {
        b.innerText = "ON";
        b.className = "toggle-btn toggle-on";
    } else {
        b.innerText = "OFF";
        b.className = "toggle-btn toggle-off";
    }
    sfx.play('coin');
}
function toggleMusicSetting() {
    let e = music.toggle();
    const b = document.getElementById('btn-music');
            if (u) {
                // Up attack: use custom up-attack animation and lock for a bit
                this.playAnimation("attack_up", 36);
    } else {
        b.innerText = "OFF";
        b.className = "toggle-btn toggle-off";
    }
    sfx.play('coin');
}
function toggleMobileSetting() {
    saveData.mobileControls = !saveData.mobileControls;
    saveGame();
    updateMobileControlsSetting();
    sfx.play('coin');
}
function updateMobileControlsSetting() {
    const b = document.getElementById('btn-mobile');
    const controls = document.getElementById('mobile-controls');
    const touchCapable = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (b) {
        if (saveData.mobileControls) {
            b.innerText = "ON";
            b.className = "toggle-btn toggle-on";
        } else {
            b.innerText = "OFF";
            b.className = "toggle-btn toggle-off";
        }
    }
    if (saveData.mobileControls && touchCapable) {
        controls.style.display = 'block';
    } else {
        controls.style.display = 'none';
    }
}
function showTrophies() {
    sfx.init();
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('trophy-screen').classList.remove('hidden');
    renderTrophies();
}
function hideTrophies() {
    document.getElementById('trophy-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
}

// ========== MASTERY SYSTEM ==========
function initMastery(charId) {
    if (!saveData.mastery) saveData.mastery = {};
    if (!saveData.mastery[charId]) {
        saveData.mastery[charId] = {wins: 0, matches: 0, damage: 0, level: 0};
    }
}
function trackMatch(charId, won, damageDealt) {
    initMastery(charId);
    saveData.mastery[charId].matches++;
    if (won) saveData.mastery[charId].wins++;
    saveData.mastery[charId].damage += Math.floor(damageDealt);
    
    // Calculate level: Bronze(5), Silver(15), Gold(30), Diamond(50), Master(100)
    const wins = saveData.mastery[charId].wins;
    let oldLevel = saveData.mastery[charId].level;
    if (wins >= 100) saveData.mastery[charId].level = 5;
    else if (wins >= 50) saveData.mastery[charId].level = 4;
    else if (wins >= 30) saveData.mastery[charId].level = 3;
    else if (wins >= 15) saveData.mastery[charId].level = 2;
    else if (wins >= 5) saveData.mastery[charId].level = 1;
    
    saveGame();
    return saveData.mastery[charId].level > oldLevel;
}
function getMasteryRank(level) {
    const ranks = ['UNRANKED', 'BRONZE', 'SILVER', 'GOLD', 'DIAMOND', 'MASTER'];
    const colors = ['#666', '#cd7f32', '#c0c0c0', '#ffd700', '#b9f2ff', '#ff00ff'];
    const icons = ['', 'ü•â', 'ü•à', 'ü•á', 'üíé', 'üëë'];
    return {name: ranks[level], color: colors[level], icon: icons[level]};
}
function showMastery() {
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('mastery-screen').classList.remove('hidden');
    renderMastery();
}
function hideMastery() {
    document.getElementById('mastery-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
}
function renderMastery() {
    const grid = document.getElementById('mastery-grid');
    grid.innerHTML = '';
    
    CHARACTERS.forEach(char => {
        initMastery(char.id);
        const m = saveData.mastery[char.id];
        const rank = getMasteryRank(m.level);
        const winRate = m.matches > 0 ? ((m.wins / m.matches) * 100).toFixed(1) : 0;
        
        const card = document.createElement('div');
        card.style.cssText = `background:#222;border:3px solid ${rank.color};padding:20px;border-radius:10px;`;
        card.innerHTML = `
            <div style="display:flex;align-items:center;gap:15px;margin-bottom:15px">
                <div style="font-size:48px">${char.icon}</div>
                <div>
                    <div style="font-family:'Press Start 2P';font-size:16px;color:#fff">${char.name}</div>
                    <div style="font-family:'Press Start 2P';font-size:12px;color:${rank.color};margin-top:5px">${rank.icon} ${rank.name}</div>
                </div>
            </div>
            <div style="font-family:'Press Start 2P';font-size:10px;color:#aaa;line-height:1.8">
                <div>WINS: <span style="color:#0f0">${m.wins}</span></div>
                <div>MATCHES: <span style="color:#fff">${m.matches}</span></div>
                <div>WIN RATE: <span style="color:#ffd700">${winRate}%</span></div>
                <div>DAMAGE DEALT: <span style="color:#f00">${m.damage}</span></div>
            </div>
            <div style="margin-top:10px;background:#333;border-radius:5px;height:10px;overflow:hidden">
                <div style="background:${rank.color};height:100%;width:${(m.wins % (rank.name === 'MASTER' ? 100 : [5,10,15,20,50][m.level]))/([5,10,15,20,50,100][m.level])*100}%"></div>
            </div>
            <div style="font-family:'Press Start 2P';font-size:8px;color:#666;margin-top:5px;text-align:right">
                ${m.level < 5 ? `Next: ${[5,15,30,50,100][m.level]} wins` : 'MAX RANK!'}
            </div>
        `;
        grid.appendChild(card);
    });
}

// ========== FRIEND CODE SYSTEM ==========
function generateFriendCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 8; i++) {
        if (i === 4) code += '-';
        code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
}
function initFriendCode() {
    if (!saveData.friendCode) {
        saveData.friendCode = generateFriendCode();
        saveGame();
    }
}
function showFriends() {
    initFriendCode();
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('friends-screen').classList.remove('hidden');
    document.getElementById('your-friend-code').textContent = saveData.friendCode;
    renderFriends();
}
function hideFriends() {
    document.getElementById('friends-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
}
function copyFriendCode() {
    navigator.clipboard.writeText(saveData.friendCode).then(() => {
        showNotification('COPIED!', 'Friend code copied to clipboard');
        sfx.play('coin');
    });
}
function addFriend() {
    const input = document.getElementById('friend-code-input');
    const code = input.value.trim().toUpperCase();
    
    if (!code) {
        alert('Please enter a friend code');
        return;
    }
    if (code === saveData.friendCode) {
        alert("You can't add yourself!");
        return;
    }
    if (saveData.friends.some(f => f.code === code)) {
        alert('Friend already added!');
        return;
    }
    
    // In a real implementation, this would fetch from a server
    saveData.friends.push({
        code: code,
        name: `Player ${code.substr(0, 4)}`,
        addedAt: Date.now()
    });
    saveGame();
    input.value = '';
    renderFriends();
    showNotification('FRIEND ADDED!', code);
    sfx.play('coin');
}
function removeFriend(code) {
    if (confirm('Remove this friend?')) {
        saveData.friends = saveData.friends.filter(f => f.code !== code);
        saveGame();
        renderFriends();
        sfx.play('break');
    }
}
function renderFriends() {
    const list = document.getElementById('friends-list');
    if (!saveData.friends || saveData.friends.length === 0) {
        list.innerHTML = '<div style="text-align:center;color:#666;font-family:Press Start 2P;font-size:12px;padding:40px">No friends yet. Share your code!</div>';
        return;
    }
    
    list.innerHTML = saveData.friends.map(f => `
        <div style="background:#222;border:2px solid #555;padding:15px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center">
            <div>
                <div style="font-family:'Press Start 2P';font-size:14px;color:#fff">${f.name}</div>
                <div style="font-family:'Press Start 2P';font-size:10px;color:#666;margin-top:5px">${f.code}</div>
            </div>
            <button class="menu-btn danger-btn" onclick="removeFriend('${f.code}')" style="font-size:10px;padding:8px 16px">REMOVE</button>
        </div>
    `).join('');
}

// ========== SOUND TEST ==========
function showSoundTest() {
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('sound-test-screen').classList.remove('hidden');
    renderSoundTest();
}
function hideSoundTest() {
    document.getElementById('sound-test-screen').classList.add('hidden');
    document.getElementById('title-screen').classList.remove('hidden');
    music.stop();
}
function renderSoundTest() {
    const musicList = document.getElementById('music-list');
    const sfxList = document.getElementById('sfx-list');
    
    const musicTracks = ['MENU', 'GAME', 'BOSS'];
    musicList.innerHTML = musicTracks.map(track => `
        <button class="menu-btn" onclick="music.play('${track}')" style="font-size:12px;padding:12px">
            üéµ ${track}
        </button>
    `).join('');
    
    const sfxNames = ['hit', 'jump', 'coin', 'shield', 'break', 'ult', 'parry'];
    sfxList.innerHTML = sfxNames.map(name => `
        <button class="menu-btn" onclick="sfx.play('${name}')" style="font-size:12px;padding:12px">
            üîä ${name.toUpperCase()}
        </button>
    `).join('');
}

// ========== CONTROL REMAPPING ==========
let remappingPlayer = null;
let remappingAction = null;
function showControlsConfig() {
    document.getElementById('settings-screen').classList.add('hidden');
    document.getElementById('controls-config-screen').classList.remove('hidden');
    loadControlsDisplay();
}
function hideControlsConfig() {
    document.getElementById('controls-config-screen').classList.add('hidden');
    document.getElementById('settings-screen').classList.remove('hidden');
}
function loadControlsDisplay() {
    if (!saveData.customControls) {
        saveData.customControls = {
            p1: {left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'q', shield: 'g'},
            p2: {left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g'},
            p3: {left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g'},
            p4: {left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g'}
        };
    }
    
    // Update button displays
    for (const player of ['p1', 'p2', 'p3', 'p4']) {
        for (const action in saveData.customControls[player]) {
            const btn = document.querySelector(`button[onclick="remapKey('${player}','${action}')"]`);
            if (btn) btn.textContent = saveData.customControls[player][action];
        }
    }
}
function remapKey(player, action) {
    remappingPlayer = player;
    remappingAction = action;
    const btn = document.querySelector(`button[onclick="remapKey('${player}','${action}')"]`);
    if (btn) {
        btn.classList.add('remapping');
        btn.textContent = 'PRESS KEY...';
    }
    
    const handler = (e) => {
        e.preventDefault();
        const key = e.key;
        
        if (!saveData.customControls) saveData.customControls = {p1: {}, p2: {}};
        saveData.customControls[player][action] = key;
        saveGame();
        
        if (btn) {
            btn.classList.remove('remapping');
            btn.textContent = key;
        }
        
        document.removeEventListener('keydown', handler);
        remappingPlayer = null;
        remappingAction = null;
        sfx.play('coin');
    };
    
    document.addEventListener('keydown', handler);
}
function resetControls() {
    saveData.customControls = null;
    saveGame();
    loadControlsDisplay();
    showNotification('CONTROLS RESET', 'Default controls restored');
    sfx.play('coin');
}
function getControl(player, action) {
    if (!saveData.customControls) return null;
    return saveData.customControls[player] && saveData.customControls[player][action];
}

// ========== REMATCH SYSTEM ==========
let lastMatchSettings = null;
function rematch() {
    if (!lastMatchSettings) {
        location.reload();
        return;
    }
    
    // Restore previous match settings
    p1Char = lastMatchSettings.p1Char;
    p2Char = lastMatchSettings.p2Char;
    selectedMap = lastMatchSettings.stage;
    p2IsCpu = lastMatchSettings.isCpu;
    cpuLevel = lastMatchSettings.cpuLevel;
    
    // Hide game over, start new match
    document.getElementById('game-over').classList.add('hidden');
    startGameLoop();
}
function saveMatchSettings() {
    lastMatchSettings = {
        p1Char: p1Char,
        p2Char: p2Char,
        stage: selectedMap,
        isCpu: p2IsCpu,
        cpuLevel: cpuLevel
    };
}

function renderTrophies() {
    const grid = document.getElementById('trophy-grid');
    grid.innerHTML = '';
    for (const id in MASTER_TROPHY_LIST) {
        const trophy = MASTER_TROPHY_LIST[id];
        const unlocked = saveData.trophies.includes(id);
        const div = document.createElement('div');
        div.className = unlocked ? 'trophy-item unlocked' : 'trophy-item locked';
        if (unlocked) {
            div.innerHTML = `<div class="trophy-icon">${trophy.icon}</div><div class="trophy-name">${trophy.name}</div><div class="trophy-desc">${trophy.desc}</div>`;
        } else {
            div.innerHTML = `<div class="trophy-icon">‚ùì</div><div class="trophy-name">LOCKED</div><div class="trophy-desc">???</div>`;
        }
        grid.appendChild(div);
    }
}
function toggleCpu() {
    p2IsCpu = !p2IsCpu;
    document.getElementById('cpu-toggle').innerText = p2IsCpu ? "P2: CPU" : "P2: HUMAN";
    document.getElementById('cpu-toggle').classList.toggle('cpu-active', p2IsCpu);
    document.getElementById('cpu-level-container').style.display = p2IsCpu ? 'flex' : 'none';
}
function updateCpuLevel(v) {
    cpuLevel = parseInt(v);
    document.getElementById('cpu-level-val').innerText = cpuLevel;
}
function renderCharGrid() {
    const g = document.getElementById('char-grid');
    g.innerHTML = '';
    CHARACTERS.forEach(c => {
        const d = document.createElement('div');
        d.className = 'char-card';
        d.id = `card-${c.id}`;
        let iconHtml;
        if (characterSprites[c.id]) {
            iconHtml = `<canvas width="16" height="16" id="sprite-${c.id}"></canvas>`;
        } else {
            iconHtml = `<span class="char-icon" style="font-size: 40px;">${c.icon}</span>`;
        }
        if (!saveData.unlocks.includes(c.id)) {
            d.classList.add('locked');
            d.innerHTML = `<div class="lock-icon">üîí</div>${iconHtml}`;
        } else {
            d.innerHTML = iconHtml;
            d.onclick = () => selectCharacter(c);
        }
        g.appendChild(d);
        if (characterSprites[c.id]) {
            const miniCanvas = document.getElementById(`sprite-${c.id}`);
            if (miniCanvas) {
                const miniCtx = miniCanvas.getContext('2d');
                miniCtx.imageSmoothingEnabled = !1;
                const sprite = characterSprites[c.id];
                if (sprite.idle && sprite.idle[0]) {
                    miniCtx.drawImage(sprite.idle[0], 0, 0, miniCanvas.width, miniCanvas.height);
                } else if (sprite) {
                    miniCtx.drawImage(sprite, 0, 0, miniCanvas.width, miniCanvas.height);
                }
            }
        }
    });
    updateMasteryToggles();
}

function isCharMastered(charId) {
    try {
        initMastery(charId);
        return saveData.mastery[charId].level >= 5;
    } catch (e) {
        return false;
    }
}

function checkJackUnlock() {
    // Check if Jack is already unlocked
    if (saveData.unlocks.includes('jack')) return false;
    
    // Get all characters except Jack
    const nonJackChars = CHARACTERS.filter(c => c.id !== 'jack');
    
    // Check if ALL non-Jack characters are mastered
    const allMastered = nonJackChars.every(c => isCharMastered(c.id));
    
    if (allMastered) {
        saveData.unlocks.push('jack');
        saveGame();
        // Show unlock notification
        showJackUnlock();
        return true;
    }
    return false;
}

function showJackUnlock() {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:10000;display:flex;flex-direction:column;align-items:center;justify-content:center;animation:fadeIn 0.5s';
    
    const icon = document.createElement('div');
    icon.style.cssText = "font-size:120px;margin-bottom:30px;animation:bounce 1s infinite";
    icon.textContent = 'üÉè';
    
    const title = document.createElement('div');
    title.style.cssText = "font-family:'Press Start 2P';font-size:32px;color:#FFD700;margin-bottom:20px;text-align:center";
    title.textContent = 'CHARACTER UNLOCKED!';
    
    const charName = document.createElement('div');
    charName.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#fff;margin-bottom:40px;text-align:center";
    charName.textContent = 'JACK OF ALL TRADES';
    
    const desc = document.createElement('div');
    desc.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#aaa;margin-bottom:40px;text-align:center;max-width:600px;line-height:2";
    desc.innerHTML = 'Master of None<br/>You have mastered every character!<br/>The ultimate fighter awaits...';
    
    const btn = document.createElement('button');
    btn.className = 'menu-btn';
    btn.textContent = 'CONTINUE';
    btn.onclick = () => {
        document.body.removeChild(overlay);
        renderCharGrid();
    };
    
    overlay.appendChild(icon);
    overlay.appendChild(title);
    overlay.appendChild(charName);
    overlay.appendChild(desc);
    overlay.appendChild(btn);
    document.body.appendChild(overlay);
    
    // Add animations
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
    `;
    document.head.appendChild(style);
}

function updateMasteryToggles() {
    const b1 = document.getElementById('p1-mastery-toggle');
    const b2 = document.getElementById('p2-mastery-toggle');
    if (b1) {
        if (p1Char && isCharMastered(p1Char.id)) {
            b1.style.display = 'inline-block';
            b1.innerText = `P1 MASTERY: ${useMasteryP1 ? 'ON' : 'OFF'}`;
        } else {
            b1.style.display = 'none';
        }
    }
    if (b2) {
        if (p2Char && isCharMastered(p2Char.id)) {
            b2.style.display = 'inline-block';
            b2.innerText = `P2 MASTERY: ${useMasteryP2 ? 'ON' : 'OFF'}`;
        } else {
            b2.style.display = 'none';
        }
    }
}

function toggleMastery(player) {
    if (player === 1 && p1Char && isCharMastered(p1Char.id)) {
        useMasteryP1 = !useMasteryP1;
    } else if (player === 2 && p2Char && isCharMastered(p2Char.id)) {
        useMasteryP2 = !useMasteryP2;
    }
    updateMasteryToggles();
    sfx.play('coin');
}
function highlightChar(id, p) {
    const cards = document.getElementsByClassName('char-card');
    for (let c of cards) c.classList.remove(`selected-p${p}`);
    document.getElementById(`card-${id}`)?.classList.add(`selected-p${p}`);
}
function selectCharacter(c) {
    sfx.play('coin');
    if (isSurvival) {
        if (!p1Char) {
            p1Char = c;
            highlightChar(c.id, 1);
            try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch(e) {}
            updateMasteryToggles();
            document.getElementById('select-instruction').innerText = "P2 CHOOSE";
            document.getElementById('select-instruction').style.color = "var(--p2)";
        } else if (!p2Char) {
            p2Char = c;
            highlightChar(c.id, 2);
            try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch(e) {}
            updateMasteryToggles();
            document.getElementById('char-select').classList.add('hidden');
            selectedMap = MAPS[2];
            beginSurvival();
        }
    } else if (isTraining) {
        p1Char = c;
        p2Char = CHARACTERS.find(ch => ch.id === 'chad');
        try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch(e) {}
        try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch(e) {}
        document.getElementById('char-select').classList.add('hidden');
        goToMapSelect();
    } else if (isMemeBall) {
        p1Char = c;
        let normalChars = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', 'chad', 'troll', '67kid', 'amogus', 'sahur', 'primo', 'ocralito', 'mechabara', 'bluedude', 'johnpork'];
        let enemyCharId = normalChars[Math.floor(Math.random() * normalChars.length)];
        p2Char = CHARACTERS.find(c => c.id === enemyCharId);
        try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch(e) {}
        try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch(e) {}
        document.getElementById('char-select').classList.add('hidden');
        selectedMap = MAPS[0];
        beginMemeBall();
    } else {
        if (!p1Char) {
            p1Char = c;
            highlightChar(c.id, 1);
            try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch(e) {}
            updateMasteryToggles();
            document.getElementById('select-instruction').innerText = "P2 CHOOSE";
            document.getElementById('select-instruction').style.color = "var(--p2)";
        } else if (!p2Char) {
            p2Char = c;
            highlightChar(c.id, 2);
            try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch(e) {}
            updateMasteryToggles();
            setTimeout(goToMapSelect, 500);
        }
    }
}
function goToMapSelect() {
    document.getElementById('char-select').classList.add('hidden');
    document.getElementById('map-select').classList.remove('hidden');
    const g = document.getElementById('map-grid');
    g.innerHTML = '';
    MAPS.forEach(m => {
        const d = document.createElement('div');
        d.className = 'map-card';
        d.innerHTML = `<div style="font-size:40px">üó∫Ô∏è</div><div>${m.id.toUpperCase()}</div>`;
        d.onclick = () => {
            selectedMap = m;
            document.getElementById('map-select').classList.add('hidden');
            startGame();
        };
        g.appendChild(d);
    });
}
function startGame() {
    document.getElementById('hud').classList.remove('hidden');
    audioFiles.init();
    initGame();
    saveMatchSettings();
    gameState = 'GAME';
    music.play('BATTLE');
    loop();
}
const startGameLoop = startGame;
function beginSurvival() {
    killCount = 0;
    survivalWave = 1;
    spawnTimer = 0;
    document.getElementById('hud').classList.remove('hidden');
    if (p2IsCpu || p2Char) {
        document.getElementById('p2-hud-box').style.display = 'block';
    } else {
        document.getElementById('p2-hud-box').style.display = 'none';
    }
    document.getElementById('game-mode-hud').style.display = 'block';
    document.getElementById('game-mode-title').innerText = "CO-OP SURVIVAL";
    document.getElementById('game-score-val').innerText = "KILLS: 0";
    platforms = [];
    items = [];
    ultEffects = [];
    players = [];
    backgrounds = [];
    itemTimer = 0;
    megaCoinSpawned = !1;
    worldFlipped = !1;
    mapTimer = 0;
    particles = [];
    targets = [];
    for (let i = 0; i < 20; i++) backgrounds.push({
        x: Math.random() * 2000 - 1000,
        y: Math.random() * 600 - 300,
        s: Math.random() * 30 + 20,
        sp: Math.random() * 0.5 + 0.1
    });
    platforms.push({
        x: -200,
        y: 200,
        w: 400,
        h: 500,
        t: 'solid',
        c: '#4e342e',
        vx: 0,
        vy: 0,
        angle: 0
    });
    platforms.push({
        x: -1000,
        y: 400,
        w: 2000,
        h: 200,
        t: 'lava',
        c: '#e74c3c',
        vx: 0,
        vy: -0.2,
        angle: 0
    });
    players = [new Fighter(1, p1Char, -100, 0, !0, !1)];
    if (p2Char) {
        players.push(new Fighter(2, p2Char, 100, 0, !p2IsCpu, p2IsCpu));
    }
    players.forEach(p => p.stocks = 3);
    if (saveData.powerBoosters > 0) {
        const boost = 1.2;
        players.forEach(p => {
            if (!p.cpu) {
                const originalStats = p.stats;
                p.stats = {
                    ...originalStats,
                    speed: originalStats.speed * boost,
                    power: originalStats.power * boost,
                    jump: originalStats.jump * boost,
                    weight: Math.max(0.5, originalStats.weight / boost)
                };
            }
        });
        saveData.powerBoosters = Math.max(0, (saveData.powerBoosters || 0) - 1);
        saveGame();
        setTimeout(() => {
            showNotification("‚ö° POWER BOOSTER ACTIVATED! ‚ö°", "Speed, Attack, Health, Regen Boosted!");
        }, 500);
    }
    document.getElementById('p1-name').innerText = p1Char.name;
    if (p2Char) document.getElementById('p2-name').innerText = p2Char.name;
    updateHUD();
    gameState = 'GAME';
    music.play('BOSS');
    loop();
}
function beginMemeBall() {
    p1Score = 0;
    p2Score = 0;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-mode-hud').style.display = 'block';
    document.getElementById('game-mode-title').innerText = "FIRST TO 5";
    document.getElementById('game-score-val').innerText = "0 - 0";
    platforms = [];
    items = [];
    ultEffects = [];
    players = [];
    backgrounds = [];
    itemTimer = 0;
    megaCoinSpawned = !1;
    worldFlipped = !1;
    mapTimer = 0;
    particles = [];
    targets = [];
    for (let i = 0; i < 20; i++) backgrounds.push({
        x: Math.random() * 2000 - 1000,
        y: Math.random() * 600 - 300,
        s: Math.random() * 30 + 20,
        sp: Math.random() * 0.5 + 0.1
    });
    platforms.push({
        x: -600,
        y: 200,
        w: 1200,
        h: 500,
        t: 'solid',
        c: '#546E7A'
    });
    platforms.push({
        x: -10,
        y: -100,
        w: 20,
        h: 300,
        t: 'solid',
        c: '#FFF'
    });
    players = [new Fighter(1, p1Char, -200, 0, !0, !1), new Fighter(2, p2Char, 200, 0, !1, isOnline ? !1 : !0)];
    try {
        players[0].masteryActive = (isCharMastered(p1Char.id) && useMasteryP1);
        players[1].masteryActive = (isCharMastered(p2Char.id) && useMasteryP2);
    } catch(e) {}
    players[1].stats.speed *= 1.3;
    players.forEach(p => {
        p.stocks = 99;
    });
    ball = new Ball();
    ball.reset(1);
    gameState = 'GAME';
    music.play('BATTLE');
    loop();
}
function initGame() {
    if (!p1Char) p1Char = CHARACTERS[0];
    if (!p2Char) p2Char = CHARACTERS[1];
    platforms = [];
    items = [];
    ultEffects = [];
    targets = [];
    itemTimer = 0;
    megaCoinSpawned = !1;
    backgrounds = [];
    particles = [];
    worldFlipped = !1;
    flipTimer = 0;
    const gy = 200;
    for (let i = 0; i < 20; i++) backgrounds.push({
        x: Math.random() * 2000 - 1000,
        y: Math.random() * 600 - 300,
        s: Math.random() * 30 + 20,
        sp: Math.random() * 0.5 + 0.1
    });
    if (selectedMap.id === 'flat') platforms.push({
        x: -600,
        y: gy,
        w: 1200,
        h: 500,
        t: 'solid',
        c: selectedMap.c,
        vx: 0,
        vy: 0,
        angle: 0,
        pivotX: 0,
        pivotY: 0
    });
    else if (selectedMap.id === 'plat') {
        platforms.push({
            x: -500,
            y: gy,
            w: 1000,
            h: 500,
            t: 'solid',
            c: selectedMap.c,
            vx: 0,
            vy: 0,
            angle: 0
        });
        platforms.push({
            x: -300,
            y: gy - 150,
            w: 150,
            h: 20,
            t: 'pass',
            c: '#ddd',
            vx: 1,
            vy: 0,
            angle: 0
        });
        platforms.push({
            x: 150,
            y: gy - 150,
            w: 150,
            h: 20,
            t: 'pass',
            c: '#ddd',
            vx: -1,
            vy: 0,
            angle: 0
        });
        platforms.push({
            x: -75,
            y: gy - 280,
            w: 150,
            h: 20,
            t: 'pass',
            c: '#ddd',
            vx: 0,
            vy: 0,
            angle: 0
        });
    } else if (selectedMap.id === 'edge') {
        platforms.push({
            x: -200,
            y: gy,
            w: 400,
            h: 500,
            t: 'solid',
            c: selectedMap.c,
            vx: 0,
            vy: 0,
            angle: 0
        });
        if (rulesHazardsEnabled) {
            platforms.push({
                x: -1000,
                y: 400,
                w: 2000,
                h: 200,
                t: 'lava',
            c: '#e74c3c',
            vx: 0,
            vy: -0.2,
            angle: 0
            });
        }
    } else if (selectedMap.id === 'machine') {
        platforms.push({
            x: -400,
            y: 300,
            w: 400,
            h: 20,
            t: 'machine_left',
            c: '#95a5a6',
            vx: 0,
            vy: 0,
            angle: 0,
            pivotX: -400,
            pivotY: 300
        });
        platforms.push({
            x: 0,
            y: 300,
            w: 400,
            h: 20,
            t: 'machine_right',
            c: '#95a5a6',
            vx: 0,
            vy: 0,
            angle: 0,
            pivotX: 400,
            pivotY: 300
        });
    } else platforms.push({
        x: -600,
        y: gy,
        w: 1200,
        h: 500,
        t: 'solid',
        c: selectedMap.c
    });
    let p2C = !p2IsCpu && !isTraining;
    let p2CPU = p2IsCpu || isTraining;
    
    // Determine player count based on mode
    const playerCount = (isOnline && netGameMode === '2v2') ? 4 : 2;
    
    if (playerCount === 4) {
        // 2v2: 4 fighters
        const p3Char = CHARACTERS.find(c => c.id === 'pepe') || CHARACTERS[2] || CHARACTERS[0];
        const p4Char = CHARACTERS.find(c => c.id === 'wojak') || CHARACTERS[3] || CHARACTERS[1];
        players = [
            new Fighter(1, p1Char, -300, 0, true, false),   // Team 1
            new Fighter(2, p2Char, 300, 0, true, false),    // Team 2
            new Fighter(3, p3Char, -150, 0, true, false),   // Team 1
            new Fighter(4, p4Char, 150, 0, true, false)     // Team 2
        ];
        players[0].team = 1; players[2].team = 1;  // P1 & P3 = Team 1
        players[1].team = 2; players[3].team = 2;  // P2 & P4 = Team 2
            // Ensure no boss behavior in online
            players.forEach(p => { p.isBoss = false; console.log(`P${p.id}: ${p.stats.id}, isBoss=${p.isBoss}`); });
        // Apply custom stocks if in online mode
        if (isOnline && typeof customStocks !== 'undefined') {
            players.forEach(p => p.stocks = customStocks);
        }
    } else {
        // 1v1: 2 fighters
        players = [new Fighter(1, p1Char, -200, 0, true, false), new Fighter(2, p2Char, 200, 0, p2C, p2CPU)];
            // Ensure no boss behavior in online
            if (isOnline) players.forEach(p => { p.isBoss = false; console.log(`P${p.id}: ${p.stats.id}, isBoss=${p.isBoss}`); });
        // Apply custom stocks if in online mode
        if (isOnline && typeof customStocks !== 'undefined') {
            players.forEach(p => p.stocks = customStocks);
        }
    }
    
    // Ensure mastery flags reflect latest toggles
    try {
        players[0].masteryActive = (isCharMastered(p1Char.id) && useMasteryP1);
        if (players.length > 1) players[1].masteryActive = (isCharMastered(p2Char.id) && useMasteryP2);
    } catch(e) {}
    document.getElementById('p1-name').innerText = p1Char.name;
    document.getElementById('p2-name').innerText = p2Char.name;
    document.getElementById('p2-hud-box').style.display = 'block';
    updateHUD();
    document.getElementById('game-mode-hud').style.display = 'none';
}
function updateHUD() {
    players.forEach(p => {
        const x = p.id === 1 ? 'p1' : 'p2';
        if (document.getElementById(`${x}-pct`)) {
            document.getElementById(`${x}-pct`).innerText = Math.floor(p.pct) + '%';
            document.getElementById(`${x}-stocks`).innerText = '‚óè'.repeat(p.stocks);
            const b = document.getElementById(`${x}-ult-bar`);
            b.style.width = p.ult + '%';
            if (p.ult >= 100) b.parentNode.classList.add('ult-ready');
            else b.parentNode.classList.remove('ult-ready');
        }
    });
}
function endGame(w) {
    gameState = 'GAMEOVER';
    document.getElementById('game-over').classList.remove('hidden');
    
    // Track mastery for both players
    let masteryMsg = '';
    if (!isSurvival && !isMemeBall && players.length >= 2) {
        const p1Damage = players[1].pct; // Damage dealt to opponent
        const p2Damage = players[0].pct;
        
        const p1LeveledUp = trackMatch(p1Char.id, w === 1, p1Damage);
        const p2LeveledUp = trackMatch(p2Char.id, w === 2, p2Damage);
        
        if (p1LeveledUp) {
            const rank = getMasteryRank(saveData.mastery[p1Char.id].level);
            masteryMsg += `\n${p1Char.name}: ${rank.icon} ${rank.name}!`;
        }
        if (p2LeveledUp) {
            const rank = getMasteryRank(saveData.mastery[p2Char.id].level);
            masteryMsg += `\n${p2Char.name}: ${rank.icon} ${rank.name}!`;
        }
        
        if (masteryMsg) {
            document.getElementById('mastery-progress').innerHTML = `<div style="color:#ffd700">MASTERY UP!</div>${masteryMsg}`;
            // Check if Jack should be unlocked
            setTimeout(() => checkJackUnlock(), 1000);
        } else {
            document.getElementById('mastery-progress').innerHTML = '';
            // Still check for Jack unlock even without level up
            checkJackUnlock();
        }
    }
    
    if (isSurvival) {
        document.getElementById('winner-display').innerText = `KILLS: ${killCount}`;
        if (killCount >= 50) unlockTrophy('kills_50');
    } else if (isMemeBall) {
        if (w === 1) {
            earnCoins(100);
            document.getElementById('winner-display').innerText = "P1 WINS!";
        } else {
            document.getElementById('winner-display').innerText = "CPU WINS!";
        }
    } else {
        if (w === 1) {
            earnCoins(50);
            document.getElementById('winner-display').innerText = `GAME!\n${p1Char.name} WINS`;
            if (players.length > 0 && players[0].pct === 0) unlockTrophy('flawless');
        } else {
            document.getElementById('winner-display').innerText = `GAME!\n${p2Char.name} WINS`;
            if (players.length > 1 && players[1].pct === 0) unlockTrophy('flawless');
        }
    }
    document.getElementById('winner-display').style.color = "";
    for (let i = 0; i < 50; i++) confetti.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: (Math.random() - 0.5) * 20,
        vy: (Math.random() - 0.5) * 20,
        c: `hsl(${Math.random()*360},100%,50%)`
    });
}
function loop() {
    if (gameState === 'SHOP') {
        drawShop();
        requestAnimationFrame(loop);
        return;
    }
    if (gameState === 'PAUSED') return;
    if (gameState === 'GAMEOVER') {
        draw();
        requestAnimationFrame(loop);
        return;
    }
    if (gameState !== 'GAME') return;
    if (hitStop > 0) {
        hitStop--;
        draw();
        requestAnimationFrame(loop);
        return;
    }
    mapTimer++;
    if (selectedMap.id === 'plat') {
        platforms[1].x = -300 + Math.sin(mapTimer * 0.05) * 100;
        platforms[1].vx = Math.cos(mapTimer * 0.05) * 5;
        platforms[2].x = 150 - Math.sin(mapTimer * 0.05) * 100;
        platforms[2].vx = -Math.cos(mapTimer * 0.05) * 5;
    } else if (selectedMap.id === 'edge') {
        platforms[1].y = 400 + Math.sin(mapTimer * 0.02) * 100;
    } else if (selectedMap.id === 'machine') {
        let cycle = mapTimer % 1800;
        let targetAngle = 0;
        if (cycle > 480 && cycle < 840) {
            targetAngle = -0.5;
        } else if (cycle > 1320 && cycle < 1680) {
            targetAngle = 0.5;
        }
        platforms[0].angle += (targetAngle - platforms[0].angle) * 0.01;
        platforms[1].angle += (-targetAngle - platforms[1].angle) * 0.01;
    }
    if (!isMemeBall) {
        itemTimer++;
        if (itemTimer > 400) {
            if (rulesItemsEnabled && Math.random() < 0.7) items.push(new Item());
            itemTimer = 0;
        }
        if (!megaCoinSpawned && selectedMap.id !== 'machine' && mapTimer > 600 && Math.random() < 0.01) {
            items.push(new Item('mega'));
            megaCoinSpawned = !0;
            const warn = document.getElementById('mega-warning');
            warn.style.display = 'block';
            sfx.play('ult');
            setTimeout(() => warn.style.display = 'none', 3000);
        }
    }
    if (worldFlipped) {
        flipTimer--;
        if (flipTimer <= 0) worldFlipped = !1;
    }
    
    // Handle Meme Ball serving
    if (isMemeBall && isServing) {
        const server = players.find(p => p.id === servingPlayer);
        if (server) {
            // CPU auto-serve logic
            if (server.cpu) {
                serveCharge += 2;
                if (serveCharge >= 40 + Math.random() * 40) {
                    ball.serve(serveCharge, servingPlayer);
                    serveCharge = 0;
                }
            } else {
                // Check for serve input (attack button)
                const controls = servingPlayer === 1 ? 
                    {atk: getControl('p1', 'attack') || 'f'} : 
                    {atk: getControl('p2', 'attack') || 'l'};
                
                if (keys[controls.atk]) {
                    serveCharge = Math.min(serveCharge + 3, 100);
                } else if (serveCharge > 0) {
                    // Release serve
                    ball.serve(serveCharge, servingPlayer);
                    serveCharge = 0;
                }
            }
        }
    }
    
    if (isSurvival) {
        spawnTimer++;
        let playersAlive = players.filter(p => p.stocks > 0 && !p.cpu).length;
        let rate = Math.max(60, 120 - (killCount * 2));
        if (playersAlive > 1) rate = Math.max(30, 80 - (killCount * 2));
        if (spawnTimer > rate && players.filter(p => p.cpu).length < 5) {
            let normalChars = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', 'chad', 'troll', '67kid', 'amogus', 'sahur', 'primo', 'ocralito', 'mechabara', 'bluedude', 'johnpork'];
            let enemyCharId = normalChars[Math.floor(Math.random() * normalChars.length)];
            let enemyChar = CHARACTERS.find(c => c.id === enemyCharId);
            let enemy = new Fighter(players.length + 1, enemyChar, Math.random() * 600 - 300, -300, !1, !0);
            enemy.stocks = 1;
            enemy.pct = killCount * 5;
            players.push(enemy);
            spawnTimer = 0;
        }
    }
    if (isMemeBall) ball.update();
    let livingPlayers = 0;
    for (let i = players.length - 1; i >= 0; i--) {
        if (players[i].stocks <= 0) {
            if (isSurvival) {
                if (players[i].cpu) {
                    killCount++;
                    earnCoins(5);
                    sfx.play('coin');
                    document.getElementById('game-score-val').innerText = `KILLS: ${killCount}`;
                    players.splice(i, 1);
                }
            }
        } else {
            livingPlayers++;
        }
    }
    if (!isSurvival && gameState === 'GAME') {
        let p1 = players.find(p => p.id === 1);
        let p2 = players.find(p => p.id === 2);
        if (p1 && p1.stocks <= 0) {
            endGame(2);
            return;
        }
        if (p2 && p2.stocks <= 0) {
            endGame(1);
            return;
        }
    } else if (isSurvival && gameState === 'GAME') {
        let livingHumans = players.filter(p => !p.cpu && p.stocks > 0).length;
        if (livingHumans === 0) {
            endGame(2);
            return;
        }
    }
    players.forEach(p => p.update());
    items.forEach(i => i.update());
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.life--;
        if (p.life <= 0) {
            particles.splice(i, 1);
        } else {
            if (p.text) {
                p.y += p.vy;
            } else {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
            }
        }
    }
    for (let i = ultEffects.length - 1; i >= 0; i--) {
        let e = ultEffects[i];
        e.l--;
        if (e.t === 'moon') {
            e.y += 15;
            players.forEach(p => {
                if (p.stocks > 0 && Math.abs(p.x - e.x) < 100 && Math.abs(p.y - e.y) < 100) p.hit(0, 20, 2);
            });
        } else if (e.t === 'tear') {
            e.y += 10;
            players.forEach(p => {
                if (p.stocks > 0 && Math.abs(p.x - e.x) < 30 && Math.abs(p.y - e.y) < 30) p.hit(10, 0, 1);
            });
        } else if (e.t === 'primo') {
            e.x += e.vx;
            players.forEach(p => {
                if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 50 && Math.abs(p.y - e.y) < 50) p.hit(e.vx, -10, 25);
            });
        } else if (e.t === 'pork') {
            e.y += 25;
            ctx.font = "200px Arial";
            ctx.fillText('üêñ', e.x - 100, e.y);
            players.forEach(p => {
                if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - (e.x-50)) < 100 && Math.abs(p.y - e.y) < 100) {
                    p.hit(0, -30, 100);
                    e.l = 0;
                }
            });
        }
        if (e.l <= 0) ultEffects.splice(i, 1);
    }
    players.forEach(atk => {
        if (atk.box && atk.box.act) {
            let ax = atk.x + atk.box.relX,
                ay = atk.y + atk.box.relY;
            players.forEach(def => {
                // Skip if same player, or same team in 2v2 mode (unless team attack enabled)
                const sameTeam = (atk.team && def.team && atk.team === def.team);
                const skipTeammate = sameTeam && !rulesTeamAttack;
                if (def.stocks > 0 && atk.id !== def.id && !skipTeammate && ax < def.x + def.w && ax + atk.box.w > def.x && ay < def.y + def.h && ay + atk.box.h > def.y) {
                    let d = atk.dir ? 1 : -1;
                    // Mastery Lucky Block global buffs to all moves
                    let kbx = atk.box.kbx;
                    let kby = atk.box.kby;
                    let dmg = atk.box.dmg;
                    if (atk.masteryActive && atk.stats && atk.stats.id === 'luckyblock') {
                        kbx *= 1.2;
                        kby *= 1.15;
                        dmg *= 1.2;
                    }
                    def.hit(Math.abs(kbx) * d, kby, dmg);
                    atk.box.act = !1;
                }
            });
        }
    });
    let targetsArr = players.filter(p => p.stocks > 0);
    if (targetsArr.length === 0 && players[0]) targetsArr = [players[0]];
    let mx = 0,
        my = 0;
    if (targetsArr.length > 0) {
        mx = targetsArr.reduce((sum, p) => sum + p.x, 0) / targetsArr.length;
        my = targetsArr.reduce((sum, p) => sum + p.y, 0) / targetsArr.length;
    }
    let d = 0;
    if (targetsArr.length > 1) d = Math.sqrt(Math.pow(targetsArr[1].x - targetsArr[0].x, 2));
    let tz = Math.max(0.5, Math.min(1.2, 1000 / (d + 200)));
    if (targetsArr.length === 1) tz = 0.8;
    my = Math.max(my, -400);
    my = Math.min(my, 400);
    camera.x += (mx - camera.x) * 0.1;
    camera.y += (my - camera.y) * 0.1;
    camera.zoom += (tz - camera.zoom) * 0.05;
    // Online client: render-only
    if (isOnline && !isHost) {
        draw();
        requestAnimationFrame(loop);
        return;
    }
    // Host: broadcast state to client at ~30Hz
    if (isOnline && isHost && netPeerReady) {
        if ((netTick++ % 2) === 0) {
            const snap = {
                players: players.map(p => ({x:p.x,y:p.y,vx:p.vx,vy:p.vy,pct:p.pct,stocks:p.stocks,ult:p.ult})),
                score: [p1Score, p2Score]
            };
            if (isMemeBall && ball) {
                snap.ball = {x:ball.x,y:ball.y,vx:ball.vx,vy:ball.vy,inPlay:ball.inPlay,cross:ball.hasCrossedNet};
            }
            sendNet({t:'state', s:snap});
        }
    }
    draw();
    requestAnimationFrame(loop);
}
function draw() {
    ctx.imageSmoothingEnabled = !1;
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    const scrollX = mapTimer * 0.2;
    for (let i = 0; i < backgrounds.length; i++) {
        const b = backgrounds[i];
        ctx.fillStyle = isSurvival ? 'rgba(255,100,100,0.1)' : 'rgba(255,255,255,0.1)';
        let bx = b.x - (camera.x * 0.2) - scrollX * b.sp;
        if (bx < -1500) b.x += 3000;
        let by = b.y - (camera.y * 0.1);
        ctx.beginPath();
        ctx.arc(400 + bx, 300 + by, b.s, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
    if (isTraining) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 50) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y < canvas.height; y += 50) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
    }
    ctx.save();
    ctx.imageSmoothingEnabled = !1;
    ctx.translate(canvas.width / 2, canvas.height / 2);
    if (worldFlipped) ctx.rotate(Math.PI);
    if (shake > 0) {
        ctx.translate(Math.random() * shake - shake / 2, Math.random() * shake - shake / 2);
        shake *= 0.9;
    }
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
    platforms.forEach(p => {
        if (p.t.startsWith('machine')) {
            ctx.save();
            ctx.translate(p.pivotX, p.pivotY);
            ctx.rotate(p.angle);
            let drawX = p.x - p.pivotX;
            ctx.fillStyle = p.c;
            ctx.fillRect(drawX, 0, p.w, p.h);
            ctx.restore();
        } else {
            ctx.fillStyle = p.c;
            ctx.fillRect(p.x, p.y, p.w, p.h);
        }
    });
    items.forEach(i => i.draw());
    targets.forEach(t => {
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.arc(t.x + 20, t.y + 20, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(t.x + 20, t.y + 20, 10, 0, Math.PI * 2);
        ctx.fill()
    });
    ultEffects.forEach(e => {
        if (e.t === 'moon') {
            ctx.font = "200px Arial";
            ctx.fillText('üåö', e.x - 100, e.y)
        } else if (e.t === 'tear') {
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(e.x, e.y, 10, 0, Math.PI * 2);
            ctx.fill()
        } else if (e.t === 'primo') {
            ctx.save();
            ctx.translate(e.x, e.y);
            if (e.vx < 0) ctx.scale(-1, 1);
            const sprite = characterSprites['primo'];
            if (sprite) {
                ctx.drawImage(sprite, -25, -25, 50, 50);
            } else {
                ctx.font = "50px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('üß±', 0, 0);
            }
            ctx.restore();
        } else if (e.t === 'pork') {
            ctx.font = "200px Arial";
            ctx.fillText('üêñ', e.x - 100, e.y);
        }
    });
    players.forEach(p => p.draw());
    if (isMemeBall && ball) ball.draw();
    
    // Draw serve indicator
    if (isMemeBall && isServing) {
        const server = players.find(p => p.id === servingPlayer);
        if (server) {
            ctx.save();
            ctx.font = "20px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Serve prompt
            ctx.fillStyle = '#ff0';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            const promptY = server.y - 120;
            ctx.strokeText('HOLD TO CHARGE', server.x, promptY);
            ctx.fillText('HOLD TO CHARGE', server.x, promptY);
            
            // Power bar
            if (serveCharge > 0) {
                const barW = 100;
                const barH = 10;
                const barX = server.x - barW / 2;
                const barY = server.y - 100;
                
                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barW, barH);
                
                // Power fill
                const powerColor = serveCharge < 50 ? '#0f0' : serveCharge < 80 ? '#ff0' : '#f00';
                ctx.fillStyle = powerColor;
                ctx.fillRect(barX, barY, (serveCharge / 100) * barW, barH);
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barW, barH);
            }
            
            ctx.restore();
        }
    }
    
    particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life / 60;
        if (p.text) {
            ctx.fillStyle = 'red';
            ctx.font = "bold 30px 'Black Ops One'";
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 5;
            ctx.fillText(p.text, p.x, p.y);
            ctx.shadowBlur = 0;
        } else {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.restore();
    });
    if (gameState === 'GAMEOVER') {
        confetti.forEach(c => {
            c.x += c.vx;
            c.y += c.vy;
            c.vy += 0.5;
            ctx.fillStyle = c.c;
            ctx.fillRect(c.x, c.y, 10, 10);
        });
    }
    ctx.restore();
}
function drawShop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const pb = document.getElementById('shop-right');
    if (pb) {
        const r = pb.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2 - 50;
        ctx.save();
        ctx.imageSmoothingEnabled = !1;
        ctx.translate(cx, cy);
        ctx.scale(5, 5);
        const c = CHARACTERS[shopCharIndex];
        const sprite = characterSprites[c.id];
        if (saveData.goldMode) {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
        } else {
            ctx.shadowBlur = 0;
        }
        if (sprite && sprite.idle) {
            ctx.drawImage(sprite.idle[0], -25, -25, 50, 50);
        } else if (sprite) {
            ctx.drawImage(sprite, -25, -25, 50, 50);
        } else {
            ctx.font = "50px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(c.icon, 0, 0);
        }
        if (saveData.goldMode) {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            if (sprite && sprite.idle) {
                ctx.drawImage(sprite.idle[0], -25, -25, 50, 50);
            } else if (sprite) {
                ctx.drawImage(sprite, -25, -25, 50, 50);
            }
        }
        ctx.shadowBlur = 0;
        let cos = equippedCosmetic;
        if (shopSelectedItem && shopSelectedItem.type === 'cosmetic') cos = shopSelectedItem.id;
        ctx.fillStyle = 'white';
        ctx.font = "30px Arial";
        if (cos === 'tophat') ctx.fillText('üé©', 0, -30);
        if (cos === 'shades') ctx.fillText('üï∂Ô∏è', 5, 0);
        if (cos === 'crown') ctx.fillText('üëë', 0, -35);
        ctx.restore();
    }
}
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = !1;
}
window.addEventListener('resize', resize);
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    const b = (id, k) => {
        const e = document.getElementById(id);
        e.addEventListener('touchstart', e => {
            e.preventDefault();
            touchInput[k] = !0
        });
        e.addEventListener('touchend', e => {
            e.preventDefault();
            touchInput[k] = !1
        })
    };
    b('btn-left', 'left');
    b('btn-right', 'right');
    b('btn-up', 'up');
    b('btn-down', 'down');
    b('btn-atk', 'atk');
    b('btn-jump', 'jump');
    b('btn-ult', 'ult');
    b('btn-shield', 'shield');
}
loadGame();
resize();
</script>
</body>
</html>
