<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Meme Bros: Sprite Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Press+Start+2P&family=Roboto:wght@700&display=swap');

        :root {
            --p1: #3498db;
            --p2: #e74c3c;
            --cpu: #9b59b6;
            --ult: #f1c40f;
            --boss: #c0392b;
            --on: #2ecc71;
            --off: #e74c3c;
            --gold: #ffd700;
            --glitch: #ff00ff;
        }

        body {
            margin: 0;
            background: #111;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10;
            transition: opacity 0.3s;
            overflow-y: auto;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-family: 'Black Ops One';
            font-size: 40px;
            background: -webkit-linear-gradient(#eee, #999);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 15px 0;
            text-align: center;
            line-height: 1.1;
        }

        h2 {
            font-family: 'Press Start 2P';
            color: #fff;
            margin-bottom: 30px;
            font-size: 20px;
        }

        .menu-btn {
            font-family: 'Press Start 2P';
            padding: 10px 20px;
            font-size: 13px;
            background: transparent;
            color: white;
            border: 3px solid white;
            cursor: pointer;
            margin: 5px;
            transition: 0.2s;
            text-transform: uppercase;
        }

        .menu-btn:hover {
            background: white;
            color: black;
            transform: scale(1.1);
        }

        .menu-btn.boss-btn {
            border-color: var(--boss);
            color: var(--boss);
        }

        .menu-btn.boss-btn:hover {
            background: var(--boss);
            color: white;
        }

        .menu-btn.gold-btn {
            border-color: var(--gold);
            color: var(--gold);
        }

        .menu-btn.gold-btn:hover {
            background: var(--gold);
            color: white;
        }

        .menu-btn.dojo-btn {
            border-color: var(--p1);
            color: var(--p1);
        }

        .menu-btn.dojo-btn:hover {
            background: var(--p1);
            color: white;
        }

        .menu-btn.danger-btn {
            border-color: var(--off);
            color: var(--off);
        }

        .menu-btn.danger-btn:hover {
            background: var(--off);
            color: white;
        }

        #shop-screen {
            flex-direction: row !important;
            justify-content: center;
            align-items: center;
            padding: 50px;
            box-sizing: border-box;
        }

        #shop-container {
            display: flex;
            width: 100%;
            max-width: 1000px;
            height: 80%;
            gap: 30px;
        }

        #shop-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        #shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            overflow-y: auto;
            padding-right: 10px;
            max-height: 400px;
        }

        .shop-item {
            background: #222;
            border: 2px solid #555;
            padding: 15px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
        }

        .shop-item:hover {
            border-color: white;
            transform: scale(1.05);
        }

        .shop-item.selected {
            border-color: var(--gold);
            box-shadow: 0 0 15px var(--gold);
            background: #332200;
        }

        .shop-item.bought {
            border-color: var(--on);
            opacity: 0.5;
            pointer-events: none;
        }

        .shop-item.owned .shop-cost {
            color: var(--on);
        }

        #shop-right {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #fff;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            position: relative;
        }

        .preview-title {
            font-family: 'Press Start 2P';
            color: #aaa;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .char-cycler {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            font-family: 'Press Start 2P';
            font-size: 14px;
            z-index: 2;
        }

        .cycle-btn {
            cursor: pointer;
            font-size: 20px;
            user-select: none;
        }

        .cycle-btn:hover {
            color: var(--gold);
        }

        #buy-btn {
            width: 100%;
            padding: 20px;
            font-size: 20px;
            font-family: 'Black Ops One';
            border: none;
            cursor: pointer;
            transition: 0.2s;
            margin-top: auto;
            z-index: 2;
        }

        .btn-buy {
            background: var(--gold);
            color: black;
        }

        .btn-buy:hover {
            background: white;
        }

        .btn-equip {
            background: var(--on);
            color: white;
        }

        .btn-equip:hover {
            background: white;
            color: black;
        }

        .btn-unequip {
            background: var(--off);
            color: white;
        }

        .btn-unequip:hover {
            background: white;
            color: black;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
            font-family: 'Black Ops One';
        }

        .player-hud {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 180px;
            border-top: 5px solid #fff;
        }

        .p1-hud {
            border-color: var(--p1);
        }

        .p2-hud {
            border-color: var(--p2);
        }

        .p2-cpu {
            border-color: var(--cpu) !important;
        }

        .percent {
            font-size: 48px;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        .ult-bar {
            height: 10px;
            width: 0%;
            background: #555;
            margin-top: 10px;
        }

        .ult-ready .ult-bar {
            background: var(--ult);
            box-shadow: 0 0 10px var(--ult);
        }

        #coin-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P';
            color: var(--gold);
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            z-index: 20;
        }

        .coin-pop {
            position: absolute;
            color: var(--gold);
            font-family: 'Black Ops One';
            font-size: 30px;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 2px 2px 0 #000;
        }

        #mega-warning {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-family: 'Black Ops One';
            font-size: 40px;
            color: var(--gold);
            text-shadow: 4px 4px 0 #000;
            pointer-events: none;
            display: none;
            animation: flashWarn 0.5s infinite;
            z-index: 15;
        }

        #secret-unlock {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-family: 'Black Ops One';
            font-size: 50px;
            color: var(--glitch);
            text-shadow: 5px 5px 0 #000;
            pointer-events: none;
            display: none;
            z-index: 100;
            animation: glitchText 0.2s infinite;
        }

        #pause-menu {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 30;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 10px;
            font-family: 'Press Start 2P';
            font-size: 12px;
            color: white;
        }

        #training-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Press Start 2P';
            font-size: 10px;
            color: #ccc;
            line-height: 1.8;
            display: none;
            border: 1px solid #fff;
        }

        #game-mode-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            display: none;
            pointer-events: none;
        }

        .game-mode-score {
            font-family: 'Black Ops One';
            font-size: 50px;
            color: var(--boss);
            text-shadow: 2px 2px 0 #fff;
        }

        .game-mode-title {
            font-family: 'Press Start 2P';
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        .char-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 800px;
        }

        .char-card {
            background: #333;
            border: 4px solid #555;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .char-card.locked {
            opacity: 0.5;
            filter: grayscale(1);
        }

        .lock-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            display: none;
        }

        .char-card.locked .lock-icon {
            display: block;
        }

        .selected-p1 {
            border-color: var(--p1) !important;
        }

        .selected-p2 {
            border-color: var(--p2) !important;
        }

        .char-card canvas {
            width: 40px;
            height: 40px;
        }

        .map-grid {
            display: flex;
            gap: 20px;
        }

        .map-card {
            width: 200px;
            height: 150px;
            background: #444;
            border: 3px solid #666;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            flex-direction: column;
        }

        .map-card:hover {
            border-color: #fff;
        }

        .map-preview {
            font-size: 40px;
            margin-bottom: 10px;
        }

        #moves-content {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            height: 70%;
            overflow-y: auto;
            background: #222;
            border: 2px solid #555;
            padding: 20px;
            display: block;
            box-sizing: border-box;
        }

        .moves-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .move-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            display: flex;
            gap: 15px;
            cursor: pointer;
            border: 1px solid #444;
            border-radius: 10px;
        }

        .move-icon {
            font-size: 40px;
            min-width: 50px;
        }

        .move-details {
            text-align: left;
            font-size: 12px;
            line-height: 1.8;
            color: #ccc;
            width: 100%;
        }

        .move-input {
            color: #e74c3c;
            font-weight: bold;
            font-size: 10px;
            background: #444;
            padding: 2px 5px;
            border-radius: 4px;
            margin-right: 5px;
        }

        /* Move detail modal */
        #move-detail {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        #move-detail .box {
            width: 90%;
            max-width: 900px;
            background: #111;
            border: 2px solid #555;
            border-radius: 12px;
            padding: 24px;
            box-sizing: border-box;
            color: #fff;
        }

        #move-detail h3 {
            font-family: 'Black Ops One';
            margin: 0 0 10px 0;
        }

        #move-detail .grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 16px;
        }

        #move-detail .stat {
            font-family: 'Press Start 2P';
            font-size: 12px;
            color: #aaa;
        }

        #move-detail .section {
            margin-top: 12px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            font-family: 'Press Start 2P';
            font-size: 16px;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            font-family: 'Press Start 2P';
            font-size: 12px;
        }

        .control-key {
            padding: 10px 20px;
            font-family: 'Press Start 2P';
            font-size: 12px;
            background: #333;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            min-width: 80px;
        }

        .control-key:hover {
            background: #555;
        }

        .control-key.remapping {
            background: #ff0;
            color: #000;
            animation: pulse 0.5s infinite;
        }

        .toggle-btn {
            width: 100px;
            padding: 10px;
            cursor: pointer;
            border: 2px solid white;
            font-family: 'Press Start 2P';
        }

        .toggle-on {
            background: var(--on);
        }

        .toggle-off {
            background: var(--off);
        }

        #cpu-controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #cpu-toggle {
            font-size: 14px;
            padding: 10px 20px;
            border-color: var(--p2);
            color: var(--p2);
        }

        #cpu-toggle.cpu-active {
            background: var(--cpu);
            color: white;
            border-color: white;
        }

        #cpu-level-container {
            display: none;
            align-items: center;
            gap: 10px;
            font-family: 'Press Start 2P';
            font-size: 12px;
            color: var(--cpu);
        }

        input[type=range] {
            width: 150px;
            accent-color: var(--cpu);
            cursor: pointer;
        }

        #trophy-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            width: 90%;
            max-width: 900px;
            height: 70%;
            overflow-y: auto;
            background: #222;
            border: 2px solid #555;
            padding: 20px;
        }

        .trophy-item {
            background: #333;
            border: 2px solid #555;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }

        .trophy-item.unlocked {
            border-color: var(--gold);
            box-shadow: 0 0 10px var(--gold);
        }

        .trophy-icon {
            font-size: 50px;
        }

        .trophy-name {
            font-family: 'Press Start 2P';
            font-size: 14px;
            color: #fff;
            margin-top: 10px;
        }

        .trophy-desc {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        .trophy-item.locked .trophy-name {
            color: #777;
        }

        .trophy-item.locked .trophy-icon {
            filter: grayscale(1) brightness(0.5);
        }

        /* Edgerunner Story Mode Styles */
        #story-screen {
            flex-direction: column;
            background: linear-gradient(135deg, #0a0015 0%, #1a0028 50%, #0d001a 100%);
        }
        #story-screen h2 {
            font-family: 'Black Ops One';
            color: #ff003c;
            text-shadow: 0 0 20px #ff003c, 0 0 40px #ff003c;
            font-size: 28px;
            margin-bottom: 5px;
            letter-spacing: 4px;
        }
        #story-screen .story-subtitle {
            font-family: 'Press Start 2P';
            color: #ffe135;
            font-size: 10px;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        .quest-card {
            background: rgba(20, 0, 40, 0.9);
            border: 2px solid #333;
            padding: 16px 20px;
            margin: 6px 0;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 15px;
            width: 90%;
            max-width: 600px;
            position: relative;
            overflow: hidden;
            min-height: 60px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .quest-card:hover { transform: translateX(5px); border-color: #ff003c; }
        .quest-card.available { border-color: #ffe135; }
        .quest-card.active { border-color: #0ff; animation: questPulse 2s infinite; }
        .quest-card.completed { border-color: #0f0; opacity: 0.7; }
        .quest-card.locked { opacity: 0.4; cursor: default; border-color: #333; }
        .quest-card .quest-num {
            font-family: 'Black Ops One';
            font-size: 28px;
            color: #ff003c;
            min-width: 40px;
            text-align: center;
        }
        .quest-card .quest-info { flex: 1; overflow: hidden; }
        .quest-card .quest-title {
            font-family: 'Black Ops One';
            font-size: 14px;
            color: #fff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .quest-card .quest-desc {
            font-family: 'Press Start 2P';
            font-size: 7px;
            color: #aaa;
            line-height: 1.5;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .quest-card .quest-reward {
            font-family: 'Press Start 2P';
            font-size: 7px;
            color: #ffe135;
            margin-top: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .quest-card .quest-status {
            font-family: 'Press Start 2P';
            font-size: 8px;
            min-width: 80px;
            text-align: right;
        }
        @keyframes questPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0,255,255,0.3); }
            50% { box-shadow: 0 0 20px rgba(0,255,255,0.6); }
        }

        /* Dialogue Box */
        #dialogue-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 40px;
        }
        #dialogue-overlay.active { display: flex; }
        .dialogue-box {
            background: linear-gradient(180deg, rgba(10,0,30,0.95) 0%, rgba(20,0,40,0.98) 100%);
            border: 2px solid #ff003c;
            max-width: 700px;
            width: 90%;
            padding: 20px 25px;
            position: relative;
            box-shadow: 0 0 30px rgba(255,0,60,0.3);
        }
        .dialogue-speaker {
            font-family: 'Black Ops One';
            font-size: 16px;
            color: #ff003c;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ff003c;
        }
        .dialogue-text {
            font-family: 'Press Start 2P';
            font-size: 11px;
            color: #ddd;
            line-height: 2.2;
            min-height: 50px;
            word-spacing: 6px;
            letter-spacing: 0.5px;
            white-space: pre-wrap;
        }
        .dialogue-continue {
            font-family: 'Press Start 2P';
            font-size: 7px;
            color: #ffe135;
            text-align: right;
            margin-top: 10px;
            animation: blink 1s infinite;
        }
        .dialogue-portrait {
            position: absolute;
            top: -80px;
            left: 20px;
            font-size: 60px;
            filter: drop-shadow(0 0 10px rgba(255,0,60,0.5));
        }
        @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        @keyframes flashWarn {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes glitchText {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(5px, -5px);
            }

            50% {
                transform: translate(-5px, 5px);
            }

            75% {
                transform: translate(5px, 5px);
            }

            100% {
                transform: translate(-5px, -5px);
            }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #mobile-controls {
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .touch-btn {
            pointer-events: auto;
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            backdrop-filter: blur(2px);
        }

        .dpad {
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-left {
            bottom: 30px;
            left: 20px;
        }

        #btn-right {
            bottom: 30px;
            left: 90px;
        }

        #btn-up {
            bottom: 100px;
            left: 55px;
        }

        #btn-down {
            bottom: 30px;
            left: 55px;
        }

        #btn-jump {
            bottom: 40px;
            right: 30px;
            width: 100px;
            height: 100px;
            font-size: 24px;
        }

        #btn-atk {
            bottom: 60px;
            right: 150px;
            width: 80px;
            height: 80px;
            font-size: 20px;
        }

        #btn-ult {
            bottom: 160px;
            right: 40px;
            width: 60px;
            height: 60px;
            font-size: 18px;
        }

        #btn-shield {
            bottom: 160px;
            right: 120px;
            width: 60px;
            height: 60px;
            font-size: 18px;
        }

        #gacha-screen {
            flex-direction: column !important;
            justify-content: center;
            align-items: center;
            padding: 50px;
            box-sizing: border-box;
        }

        #gacha-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            max-width: 600px;
            width: 100%;
        }

        #gacha-display {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid var(--gold);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .gacha-result-icon {
            font-size: 100px;
            margin-bottom: 20px;
        }

        .gacha-result-name {
            font-family: 'Black Ops One';
            font-size: 32px;
            color: var(--gold);
            margin-bottom: 10px;
        }

        .gacha-result-desc {
            font-family: 'Press Start 2P';
            font-size: 12px;
            color: #aaa;
        }

        #gacha-roll-btn {
            width: 100%;
            padding: 25px;
            font-size: 24px;
            font-family: 'Black Ops One';
            border: 4px solid var(--gold);
            background: transparent;
            color: var(--gold);
            cursor: pointer;
            transition: 0.2s;
        }

        #gacha-roll-btn:hover {
            background: var(--gold);
            color: black;
            transform: scale(1.05);
        }

        #gacha-roll-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #gacha-roll-premium-btn {
            width: 100%;
            padding: 25px;
            font-size: 24px;
            font-family: 'Black Ops One';
            animation: glow 1.5s ease-in-out infinite;
        }

        #gacha-roll-premium-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            animation: none;
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 0 5px #ff00ff;
            }

            50% {
                box-shadow: 0 0 20px #ff00ff, 0 0 30px #ff00ff;
            }
        }

        .gacha-cost {
            font-family: 'Press Start 2P';
            font-size: 16px;
            color: var(--gold);
            margin-top: 10px;
        }

        .gacha-rarity {
            font-family: 'Press Start 2P';
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
        }

        .gacha-ultra-rare {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .gacha-rare {
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
        }

        .gacha-common {
            color: #999;
        }

        /* Moves Guide UI */
        .moves-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
        }

        .move-card {
            background: #111;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 14px;
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .move-thumb {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .move-details {
            font-family: 'Press Start 2P';
            font-size: 10px;
            color: #ddd;
            line-height: 1.6;
        }

        .move-title {
            font-family: 'Black Ops One';
            font-size: 16px;
            color: #fff;
            margin-bottom: 6px;
        }

        .badge {
            display: inline-block;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 3px 6px;
            font-size: 10px;
            margin-right: 6px;
            color: #aaa;
        }

        .statline {
            color: #aaa;
            font-size: 10px;
            margin: 6px 0;
        }
    </style>
</head>

<body>
    <div id="game-container"><canvas id="gameCanvas"></canvas></div>
    <div id="coin-display">💰 <span id="coin-count">0</span></div>
    <div id="mega-warning">⚠️ A MEGA 💰 HAS SPAWNED! ⚠️</div>
    <div id="secret-unlock">SECRET UNLOCKED!<br><span id="secret-name">THE MEME</span></div>
    <div id="game-mode-hud">
        <div class="game-mode-score"><span id="game-score-val">0</span></div>
        <div class="game-mode-title" id="game-mode-title">SURVIVE</div>
    </div>
    <div id="training-hud">
        <div>DOJO</div><br>
        [1] CPU: <span id="train-cpu-mode">STAND</span><br>[2] RESET DMG<br>[3] RESET POS<br>[4] HITBOX: <span
            id="train-hitbox">OFF</span>
    </div>
    <div id="hud" class="hidden">
        <div class="player-hud p1-hud">
            <div id="p1-name">P1</div>
            <div class="percent" id="p1-pct">0%</div>
            <div class="stocks" id="p1-stocks">●●●</div>
            <div class="ult-container">
                <div id="p1-ult-bar" class="ult-bar"></div>
            </div>
        </div>
        <div class="player-hud p2-hud" id="p2-hud-box">
            <div id="p2-name">P2</div>
            <div class="percent" id="p2-pct">0%</div>
            <div class="stocks" id="p2-stocks">●●●</div>
            <div class="ult-container">
                <div id="p2-ult-bar" class="ult-bar"></div>
            </div>
        </div>
    </div>
    <div id="title-screen" class="screen">
        <h1>SUPER<br>MEME BROS<br>ULTIMATE</h1>
        <button class="menu-btn pulse" onclick="startLocal()">FIGHT (VS)</button>
        <button class="menu-btn boss-btn" onclick="startSurvival()">SURVIVAL</button>
        <button class="menu-btn" onclick="startMemeBall()">MEME BALL</button>
        <button class="menu-btn dojo-btn" onclick="startTraining()">TRAINING</button>
        <button class="menu-btn" onclick="startSpectator()">SPECTATOR</button>
        <button class="menu-btn gold-btn" onclick="openShop()">MEME SHOP</button>
        <button id="cyberware-btn" class="menu-btn" style="border-color:#ffe135;color:#ffe135;display:none"
            onclick="openCyberware()">CYBERWARE</button>
        <button id="story-btn" class="menu-btn" style="border-color:#ff003c;color:#ff003c;display:none"
            onclick="openStory()">STORY MODE</button>
        <button class="menu-btn" style="border-color: #ff00ff; color: #ff00ff;" onclick="openGacha()"
            onmouseover="this.style.background='#ff00ff';this.style.color='white';"
            onmouseout="this.style.background='transparent';this.style.color='#ff00ff';">GACHA 🎰</button>
        <button class="menu-btn" onclick="showMoves()">MOVES LIST</button>
        <button class="menu-btn" onclick="showTrophies()">TROPHIES</button>
        <button class="menu-btn" onclick="showMastery()">MASTERY</button>
        <button class="menu-btn" onclick="showFriends()">FRIENDS</button>
        <button class="menu-btn" onclick="showSoundTest()">SOUND TEST</button>
        <button class="menu-btn" onclick="startOnline()">ONLINE (BETA)</button>
        <button class="menu-btn" onclick="openSettings()">SETTINGS</button>
        <button class="menu-btn" onclick="openFeedback()">FEEDBACK</button>
    </div>
    <div id="pause-menu" class="screen hidden">
        <h1>PAUSED</h1>
        <div class="volume-control">MUSIC: <input type="range" min="0" max="1" step="0.1" value="0.5"
                oninput="music.setVol(this.value)"></div>
        <div class="volume-control">SFX: <input type="range" min="0" max="1" step="0.1" value="0.5"
                oninput="sfx.setVol(this.value)"></div>
        <button class="menu-btn" onclick="togglePause()">RESUME</button>
        <button class="menu-btn danger-btn" onclick="location.reload()">QUIT</button>
    </div>
    <div id="shop-screen" class="screen hidden">
        <div style="position:absolute;top:20px;left:30px;font-size:24px;font-family:'Black Ops One';color:var(--gold)">
            MEME SHOP</div>
        <div id="shop-discount" style="position:absolute;top:55px;left:30px;font-family:'Press Start 2P';font-size:8px;color:#00ff88"></div>
        <div id="shop-container">
            <div id="shop-left">
                <div id="shop-grid"></div>
            </div>
            <div id="shop-right">
                <div class="preview-title">DRESSING ROOM</div>
                <div class="preview-spacer"></div>
                <div class="char-cycler"><span class="cycle-btn" onclick="cycleShopChar(-1)">◀</span><span
                        id="shop-char-name">DOGE</span><span class="cycle-btn" onclick="cycleShopChar(1)">▶</span></div>
                <div id="shop-item-info"
                    style="text-align:center;min-height:60px;font-size:14px;font-family:'Press Start 2P';z-index:2">
                    SELECT ITEM</div>
                <button id="buy-btn" class="btn-buy" onclick="buyOrEquip()">BUY</button>
            </div>
        </div>
        <button class="menu-btn" style="position:absolute;bottom:20px;left:30px;z-index:20"
            onclick="closeShop()">BACK</button>
    </div>
    <div id="cyberware-screen" class="screen hidden" style="flex-direction:column">
        <h2 style="font-family:'Black Ops One';color:#ffe135;text-shadow:0 0 10px #ffe135;margin-bottom:20px">CYBERWARE
            IMPLANTS</h2>
        <div style="display:flex;gap:40px;width:90%;max-width:1000px;justify-content:center;height:70%">
            <!-- Left: Character Preview & Slots -->
            <div
                style="flex:1;background:rgba(0,0,0,0.5);border:2px solid #555;padding:20px;display:flex;flex-direction:column;align-items:center">
                <div style="font-family:'Press Start 2P';color:#aaa;font-size:10px;margin-bottom:10px">SUBJECT: YELLOW
                    DUDE</div>
                <canvas id="cyber-char-preview" width="100" height="100"
                    style="width:150px;height:150px;margin-bottom:20px;image-rendering:pixelated;border:1px solid #333"></canvas>

                <div style="width:100%;margin-bottom:5px;font-family:'Press Start 2P';color:#ffe135;font-size:10px">CORE
                    SYSTEM [1 MAX]</div>
                <div id="slot-core" class="cyber-slot" onclick="selectCyberSlot('core')"
                    style="width:100%;background:#222;border:2px dashed #555;padding:15px;text-align:center;font-family:'Press Start 2P';font-size:10px;color:#666;cursor:pointer;margin-bottom:20px">
                    EMPTY SLOT</div>

                <div style="width:100%;margin-bottom:5px;font-family:'Press Start 2P';color:#ffe135;font-size:10px">
                    SOFTWARE [1 MAX]</div>
                <div id="slot-software" class="cyber-slot" onclick="selectCyberSlot('software')"
                    style="width:100%;background:#222;border:2px dashed #555;padding:15px;text-align:center;font-family:'Press Start 2P';font-size:10px;color:#666;cursor:pointer;margin-bottom:20px">
                    EMPTY SLOT</div>

                <div style="width:100%;margin-bottom:5px;font-family:'Press Start 2P';color:#ff4444;font-size:10px">ARMS
                    [1 MAX]</div>
                <div id="slot-arm" class="cyber-slot" onclick="selectCyberSlot('arm')"
                    style="width:100%;background:#222;border:2px dashed #555;padding:15px;text-align:center;font-family:'Press Start 2P';font-size:10px;color:#666;cursor:pointer;margin-bottom:20px">
                    EMPTY SLOT</div>

                <div style="width:100%;margin-bottom:5px;font-family:'Press Start 2P';color:#00ccff;font-size:10px">LEGS
                    [1 MAX]</div>
                <div id="slot-legs" class="cyber-slot" onclick="selectCyberSlot('legs')"
                    style="width:100%;background:#222;border:2px dashed #555;padding:15px;text-align:center;font-family:'Press Start 2P';font-size:10px;color:#666;cursor:pointer">
                    EMPTY SLOT</div>
            </div>
            <!-- Right: Inventory / Shop -->
            <div
                style="flex:1.5;background:rgba(0,0,0,0.5);border:2px solid #555;padding:20px;display:flex;flex-direction:column">
                <div
                    style="font-family:'Press Start 2P';color:#ffe135;margin-bottom:20px;font-size:12px;display:flex;justify-content:space-between">
                    <span>INVENTORY</span>
                    <span id="cyber-coins">💰 0</span>
                </div>
                <div id="cyber-inventory"
                    style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:10px;overflow-y:auto;flex:1;align-content:start">
                </div>
                <div id="cyber-item-desc"
                    style="margin-top:10px;padding:10px;background:#111;border:1px solid #333;font-family:'Press Start 2P';font-size:9px;color:#aaa;min-height:50px">
                    HOVER OR SELECT ITEM FOR DETAILS</div>
            </div>
        </div>
        <div style="margin-top:20px;display:flex;gap:20px;flex-wrap:wrap;justify-content:center;align-items:center">
            <button class="menu-btn" onclick="closeCyberware()">BACK</button>
            <button id="cyber-equip-btn" class="menu-btn" style="border-color:#ffe135;color:#ffe135"
                onclick="equipCyberware()">EQUIP / INSTALL</button>
            <button class="menu-btn" style="border-color:#0ff;color:#0ff;font-size:10px" onclick="showLoadoutPresets()">LOADOUTS</button>
        </div>
        <div id="loadout-panel" style="display:none;margin-top:10px;padding:15px;background:rgba(0,0,0,0.7);border:2px solid #0ff;max-width:500px;width:90%">
            <div style="font-family:'Press Start 2P';color:#0ff;font-size:10px;margin-bottom:10px;text-align:center">LOADOUT PRESETS</div>
            <div id="loadout-list" style="display:flex;flex-direction:column;gap:8px;margin-bottom:10px"></div>
            <div style="display:flex;gap:10px;justify-content:center">
                <button class="menu-btn" style="font-size:9px;padding:6px 12px;border-color:#0f0;color:#0f0" onclick="promptSaveLoadout()">SAVE CURRENT</button>
                <button class="menu-btn" style="font-size:9px;padding:6px 12px" onclick="document.getElementById('loadout-panel').style.display='none'">CLOSE</button>
            </div>
        </div>
    </div>
    <!-- Edgerunner Story Mode -->
    <div id="story-screen" class="screen hidden">
        <h2>EDGERUNNERS</h2>
        <div class="story-subtitle">NIGHT CITY STORYLINE</div>
        <div id="street-cred-display" style="font-family:'Press Start 2P';font-size:9px;color:#ff003c;margin-bottom:10px"></div>
        <div id="quest-list" style="overflow-y:auto;max-height:55vh;display:flex;flex-direction:column;align-items:center;width:100%"></div>
        <div style="margin-top:15px;display:flex;gap:15px">
            <button class="menu-btn" onclick="closeStory()">BACK</button>
        </div>
    </div>
    <!-- Dialogue Overlay -->
    <div id="dialogue-overlay">
        <div class="dialogue-box">
            <div class="dialogue-portrait" id="dialogue-portrait"></div>
            <div class="dialogue-speaker" id="dialogue-speaker">???</div>
            <div class="dialogue-text" id="dialogue-text"></div>
            <div class="dialogue-continue">[CLICK / ENTER] ▶</div>
        </div>
    </div>
    <div id="settings-screen" class="screen hidden">
        <h2>SETTINGS</h2>
        <div class="setting-row"><span>SHOW HITBOXES</span><button id="btn-hitbox" class="toggle-btn toggle-off"
                onclick="toggleHitboxSetting()">OFF</button></div>
        <div class="setting-row"><span>MUSIC</span><button id="btn-music" class="toggle-btn toggle-on"
                onclick="toggleMusicSetting()">ON</button></div>
        <div class="setting-row"><span>MOBILE CONTROLS</span><button id="btn-mobile" class="toggle-btn toggle-on"
                onclick="toggleMobileSetting()">ON</button></div>
        <button class="menu-btn" style="margin-top:20px" onclick="showControlsConfig()">CONFIGURE CONTROLS</button>
        <button class="menu-btn danger-btn" style="margin-top:30px" onclick="deleteSaveFile()">DELETE SAVE FILE</button>
        <button class="menu-btn" onclick="closeSettings()">BACK</button>
    </div>
    <div id="controls-config-screen" class="screen hidden" style="overflow-y:auto">
        <h2>CONTROL CONFIGURATION</h2>
        <div style="max-width:800px;margin:0 auto;padding:20px">
            <div style="display:flex;gap:40px;justify-content:center;flex-wrap:wrap">
                <div style="background:rgba(0,255,255,0.05);border:2px solid var(--p1);padding:20px;min-width:300px">
                    <h3 style="color:var(--p1);font-family:'Press Start 2P';margin-bottom:20px">PLAYER 1</h3>
                    <div class="control-row">LEFT: <button class="control-key"
                            onclick="remapKey('p1','left')">A</button></div>
                    <div class="control-row">RIGHT: <button class="control-key"
                            onclick="remapKey('p1','right')">D</button></div>
                    <div class="control-row">UP: <button class="control-key" onclick="remapKey('p1','up')">W</button>
                    </div>
                    <div class="control-row">DOWN: <button class="control-key"
                            onclick="remapKey('p1','down')">S</button></div>
                    <div class="control-row">ATTACK: <button class="control-key"
                            onclick="remapKey('p1','attack')">F</button></div>
                    <div class="control-row">ULT: <button class="control-key" onclick="remapKey('p1','ult')">R</button>
                    </div>
                    <div class="control-row">SHIELD: <button class="control-key"
                            onclick="remapKey('p1','shield')">G</button></div>
                </div>
                <div style="background:rgba(255,0,255,0.05);border:2px solid var(--p2);padding:20px;min-width:300px">
                    <h3 style="color:var(--p2);font-family:'Press Start 2P';margin-bottom:20px">PLAYER 2</h3>
                    <div class="control-row">LEFT: <button class="control-key"
                            onclick="remapKey('p2','left')">←</button></div>
                    <div class="control-row">RIGHT: <button class="control-key"
                            onclick="remapKey('p2','right')">→</button></div>
                    <div class="control-row">UP: <button class="control-key" onclick="remapKey('p2','up')">↑</button>
                    </div>
                    <div class="control-row">DOWN: <button class="control-key"
                            onclick="remapKey('p2','down')">↓</button></div>
                    <div class="control-row">ATTACK: <button class="control-key"
                            onclick="remapKey('p2','attack')">L</button></div>
                    <div class="control-row">ULT: <button class="control-key"
                            onclick="remapKey('p2','ult')">Shift</button></div>
                    <div class="control-row">SHIELD: <button class="control-key"
                            onclick="remapKey('p2','shield')">K</button></div>
                </div>
            </div>
            <button class="menu-btn" onclick="resetControls()" style="margin-top:20px">RESET TO DEFAULT</button>
        </div>
        <button class="menu-btn" onclick="hideControlsConfig()">BACK</button>
    </div>
    <button class="menu-btn" onclick="closeSettings()">BACK</button>
    </div>
    <div id="moves-screen" class="screen hidden"
        style="background:rgba(0,0,0,0.9);overflow:auto;align-items:flex-start;z-index:200">
        <div style="max-width:1000px;margin:40px auto;padding:30px;color:#fff;width:100%">
            <h2>Moves & Specials Guide</h2>
            <div id="moves-content"></div>
            <button class="menu-btn" onclick="hideMoves()">BACK</button>
        </div>
    </div>
    <!-- Detailed Move Modal -->
    <div id="move-detail">
        <div class="box">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <h3 id="move-detail-title">Character</h3>
                <button class="menu-btn" onclick="closeMoveDetail()">CLOSE</button>
            </div>
            <div class="grid">
                <div>
                    <canvas width="64" height="64" id="move-detail-thumb" style="width:128px;height:128px"></canvas>
                    <div id="move-detail-stats" class="stat"></div>
                </div>
                <div>
                    <div class="section" id="move-detail-universal"></div>
                    <div class="section" id="move-detail-specials"></div>
                    <div class="section" id="move-detail-ult"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="trophy-screen" class="screen hidden">
        <h2>TROPHIES</h2>
        <div id="trophy-grid"></div>
        <button class="menu-btn" onclick="hideTrophies()">BACK</button>
    </div>
    <div id="mastery-screen" class="screen hidden" style="overflow-y:auto">
        <h2>CHARACTER MASTERY</h2>
        <div id="mastery-grid"
            style="display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:20px;padding:20px;max-width:1200px;margin:0 auto">
        </div>
        <button class="menu-btn" onclick="hideMastery()">BACK</button>
    </div>
    <div id="friends-screen" class="screen hidden" style="overflow-y:auto">
        <h2>FRIENDS</h2>
        <div style="max-width:800px;margin:0 auto;padding:20px">
            <div
                style="background:rgba(255,215,0,0.1);border:2px solid #ffd700;padding:20px;margin-bottom:20px;text-align:center">
                <div style="font-family:'Press Start 2P';font-size:12px;color:#ffd700;margin-bottom:10px">YOUR FRIEND
                    CODE</div>
                <div id="your-friend-code"
                    style="font-family:'Press Start 2P';font-size:18px;color:#fff;margin-bottom:10px"></div>
                <button class="menu-btn" onclick="copyFriendCode()" style="font-size:10px;padding:8px 16px">COPY
                    CODE</button>
            </div>
            <div style="margin-bottom:20px">
                <input type="text" id="friend-code-input" placeholder="Enter friend code..."
                    style="width:60%;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
                <button class="menu-btn" onclick="addFriend()"
                    style="font-size:10px;padding:10px 20px;margin-left:10px">ADD FRIEND</button>
            </div>
            <div id="friends-list"></div>
        </div>
        <button class="menu-btn" onclick="hideFriends()">BACK</button>
    </div>
    <div id="sound-test-screen" class="screen hidden">
        <h2>SOUND TEST</h2>
        <div style="max-width:600px;margin:0 auto;padding:20px">
            <h3 style="color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin:20px 0">MUSIC</h3>
            <div id="music-list" style="display:flex;flex-direction:column;gap:10px;margin-bottom:30px"></div>
            <h3 style="color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin:20px 0">SOUND EFFECTS</h3>
            <div id="sfx-list" style="display:flex;flex-direction:column;gap:10px"></div>
        </div>
        <button class="menu-btn" onclick="hideSoundTest()">BACK</button>
    </div>
    <div id="online-screen" class="screen hidden">
        <h2>ONLINE (BETA)</h2>
        <div style="display:flex;gap:20px;flex-direction:column;align-items:center">
            <div style="margin-bottom:10px;display:flex;gap:10px;align-items:center">
                <span style="font-family:'Press Start 2P';font-size:12px;color:#ffd700">Server URL</span>
                <input type="text" id="online-ws-url" placeholder="wss://your-relay.example.com"
                    style="width:320px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff"
                    value="https://supermemesmashmutliplayer-production.up.railway.app/">
            </div>
            <div style="margin-bottom:10px;display:flex;gap:10px;align-items:center">
                <span style="font-family:'Press Start 2P';font-size:12px;color:#ffd700">Your Name</span>
                <input type="text" id="online-nickname" placeholder="Player" maxlength="12"
                    style="width:180px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
            </div>
            <div>
                <button class="menu-btn" onclick="quickMatch()" style="background:#0f0;color:#000;font-weight:bold">⚡
                    QUICK MATCH</button>
                <div style="font-family:'Press Start 2P';font-size:9px;color:#666;margin-top:5px">Join any available
                    room</div>
            </div>
            <div style="margin-top:10px;border-top:1px solid #555;padding-top:15px">
                <button class="menu-btn" onclick="hostRoom()">HOST ROOM</button>
                <div style="font-family:'Press Start 2P';font-size:12px;color:#aaa;margin-top:8px">Room Code: <span
                        id="online-room-code">—</span></div>
            </div>
            <div>
                <input type="text" id="online-join-code" placeholder="Enter Room Code"
                    style="width:220px;padding:10px;font-family:'Press Start 2P';font-size:12px;background:#222;border:2px solid #fff;color:#fff">
                <button class="menu-btn" onclick="joinRoom()">JOIN</button>
            </div>
            <div id="online-status" style="font-family:'Press Start 2P';font-size:12px;color:#0f0;min-height:18px">
            </div>
            <div id="online-controls-help"
                style="display:none;flex-direction:column;gap:6px;margin:10px 0;padding:10px;background:rgba(0,0,0,0.4);border:1px solid #555;min-width:320px;font-family:'Press Start 2P';font-size:9px;color:#ddd">
                <div style="color:#ffd700">DEFAULT CONTROLS</div>
                <div id="controls-p1">P1 (Host): Move WASD • Attack F • Ult Q • Shield G</div>
                <div id="controls-p2">P2: Move WASD • Attack F • Ult R • Shield G</div>
                <div id="controls-p3">P3: Move WASD • Attack F • Ult R • Shield G</div>
                <div id="controls-p4">P4: Move WASD • Attack F • Ult R • Shield G</div>
                <div style="margin-top:6px;display:flex;gap:6px;flex-wrap:wrap">
                    <button class="menu-btn" style="font-size:10px" onclick="remapKey('p1','ult')">Remap P1 Ult</button>
                    <button class="menu-btn" style="font-size:10px" onclick="remapKey('p2','ult')">Remap P2 Ult</button>
                    <button class="menu-btn" style="font-size:10px" onclick="remapKey('p3','ult')">Remap P3 Ult</button>
                    <button class="menu-btn" style="font-size:10px" onclick="remapKey('p4','ult')">Remap P4 Ult</button>
                </div>
            </div>
            <div id="online-lobby-list"
                style="display:none;flex-direction:column;gap:8px;margin:15px 0;padding:15px;background:rgba(0,0,0,0.5);border:2px solid #555;min-width:320px">
                <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin-bottom:5px">CONNECTED
                    PLAYERS</div>
                <div id="online-player-list" style="font-family:'Press Start 2P';font-size:9px;color:#fff"></div>
            </div>
            <div id="online-start-box" style="display:none;flex-direction:column;gap:10px;align-items:center">
                <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700">SELECT GAME MODE</div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center">
                    <button class="menu-btn" id="mode-1v1-btn" onclick="selectOnlineMode('1v1')"
                        style="background:#0f0;color:#000">1v1</button>
                    <button class="menu-btn" id="mode-2v2-btn" onclick="selectOnlineMode('2v2')">2v2</button>
                </div>
                <div id="online-char-select"
                    style="margin-top:10px;display:flex;gap:10px;flex-direction:column;align-items:center">
                    <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700">CHARACTER SELECT (Host)</div>
                    <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center">
                        <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">P1:
                            <select id="online-p1-char"
                                style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px"></select>
                        </label>
                        <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">P2:
                            <select id="online-p2-char"
                                style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px"></select>
                        </label>
                    </div>
                    <div id="online-picked-preview" style="font-family:'Press Start 2P';font-size:9px;color:#aaa"></div>
                </div>
                <div style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin-top:10px">MATCH SETTINGS
                </div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;align-items:center">
                    <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">Stage:
                        <select id="online-stage-sel"
                            style="padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px">
                            <option value="flat">Flat</option>
                            <option value="plat">Platforms</option>
                            <option value="edge">Edge</option>
                            <option value="machine">Machine</option>
                        </select>
                    </label>
                    <label style="font-family:'Press Start 2P';font-size:9px;color:#ddd">Stocks:
                        <input type="number" id="online-stocks" min="1" max="5" value="3"
                            style="width:50px;padding:6px;background:#222;border:2px solid #fff;color:#fff;font-family:'Press Start 2P';font-size:9px">
                    </label>
                </div>
                <div style="display:flex;gap:15px;flex-wrap:wrap;justify-content:center;margin-top:8px">
                    <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                        <input type="checkbox" id="online-items" checked style="margin-right:5px"> Items
                    </label>
                    <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                        <input type="checkbox" id="online-hazards" checked style="margin-right:5px"> Hazards
                    </label>
                    <label style="font-family:'Press Start 2P';font-size:8px;color:#ddd;cursor:pointer">
                        <input type="checkbox" id="online-teamattack" style="margin-right:5px"> Team Attack
                    </label>
                </div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:10px">
                    <button class="menu-btn" onclick="onlineStart('meme')">START MEME BALL</button>
                    <button class="menu-btn" onclick="onlineStart('vs')">START VS MATCH</button>
                </div>
                <div style="font-family:'Press Start 2P';font-size:9px;color:#888;max-width:340px;text-align:center">
                    1v1: 2 players | 2v2: 4 players (teams)</div>
            </div>
            <button class="menu-btn" onclick="hideOnline()">BACK</button>
        </div>
        <div style="position:absolute;bottom:20px;font-family:'Press Start 2P';font-size:10px;color:#888">Requires local
            signaling server ws://localhost:8080</div>
    </div>
    <div id="gacha-screen" class="screen hidden">
        <div style="position:absolute;top:20px;left:30px;font-size:24px;font-family:'Black Ops One';color:#ff00ff">GACHA
            🎰</div>
        <div
            style="position:absolute;top:20px;right:30px;font-family:'Press Start 2P';font-size:12px;color:#ffd700;text-align:right">
            💰 <span id="gacha-coin-count">0</span><br>
            🎫 <span id="gacha-coin-special-count">0</span> Gacha Coins
        </div>
        <button class="menu-btn"
            style="position:absolute;top:20px;left:50%;transform:translateX(-50%);font-size:12px;padding:8px 16px"
            onclick="toggleGachaInfo()">VIEW REWARDS</button>
        <div id="banner-timer"
            style="position:absolute;top:70px;left:50%;transform:translateX(-50%);font-family:'Press Start 2P';font-size:10px;color:#ff0;text-align:center;display:none">
            <div style="color:#f0f;margin-bottom:5px">⭐ LIMITED BANNER ⭐</div>
            <div id="banner-char-name" style="font-size:14px;margin-bottom:5px"></div>
            <div>Time Left: <span id="banner-time-left"></span></div>
        </div>
        <div id="gacha-container">
            <div id="gacha-display">
                <div class="gacha-result-icon">🎁</div>
                <div class="gacha-result-name">ROLL FOR REWARDS!</div>
                <div class="gacha-result-desc">Click the button below to roll</div>
                <div class="gacha-rarity">Normal: 100 Coins | Premium: 1 Gacha Coin</div>
            </div>
            <button id="gacha-roll-btn" onclick="rollGacha()">NORMAL GACHA (100💰)</button>
            <button id="gacha-banner-btn" class="menu-btn"
                style="border-color:#ff0;color:#ff0;margin-top:10px;display:none;animation:pulse 1s infinite"
                onclick="rollBannerGacha()" onmouseover="this.style.background='#ff0';this.style.color='black';"
                onmouseout="this.style.background='transparent';this.style.color='#ff0';">BANNER GACHA (1🎫)</button>
            <button id="gacha-roll-premium-btn" class="menu-btn"
                style="border-color:#ff00ff;color:#ff00ff;margin-top:10px" onclick="rollPremiumGacha()"
                onmouseover="this.style.background='#ff00ff';this.style.color='white';"
                onmouseout="this.style.background='transparent';this.style.color='#ff00ff';">PREMIUM GACHA
                (1🎫)</button>
            <button class="menu-btn" style="margin-top:20px;border-color:#ffd700;color:#ffd700"
                onclick="convertCoinsToGacha()" onmouseover="this.style.background='#ffd700';this.style.color='black';"
                onmouseout="this.style.background='transparent';this.style.color='#ffd700';">CONVERT 1000💰 →
                1🎫</button>
        </div>
        <button class="menu-btn" style="position:absolute;bottom:20px;left:30px;z-index:20"
            onclick="closeGacha()">BACK</button>

        <!-- Gacha Info Panel -->
        <div id="gacha-info-panel" class="hidden"
            style="position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:100;overflow-y:auto;padding:40px;box-sizing:border-box">
            <button class="menu-btn" style="position:absolute;top:20px;right:20px;padding:10px 20px"
                onclick="toggleGachaInfo()">CLOSE</button>
            <h2 style="font-family:'Black Ops One';color:#ff00ff;text-align:center;margin-bottom:30px">GACHA REWARDS
                INFO</h2>

            <div id="gacha-pity-display"
                style="text-align:center;color:#ffd700;font-family:'Press Start 2P';font-size:14px;margin-bottom:30px;padding:15px;background:rgba(255,215,0,0.1);border:2px solid #ffd700">
            </div>

            <div style="display:flex;gap:30px;justify-content:center;flex-wrap:wrap">
                <!-- Normal Gacha -->
                <div
                    style="flex:1;min-width:300px;max-width:500px;background:rgba(0,255,255,0.05);border:2px solid #00ffff;padding:20px">
                    <h3 style="font-family:'Press Start 2P';color:#00ffff;text-align:center;margin-bottom:20px">NORMAL
                        GACHA (100💰)</h3>

                    <div style="margin-bottom:20px">
                        <h4 style="color:#ffd700;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">🎁
                            ULTRA RARE (0.5%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">🎲 Lucky Block
                            (GUARANTEED at 200 rolls)</p>
                    </div>

                    <div style="margin-bottom:20px">
                        <h4 style="color:#ff00ff;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">⭐ RARE
                            (4.5%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                            🐶 Doge<br>
                            🐸 Frog<br>
                            🐱 Cat<br>
                            🦫 Capy<br>
                            🧽 Spongy<br>
                            💪 The Meme<br>
                            🗺️ GPS<br>
                            📞 John Pork<br>
                            🤖 Mechabara<br>
                            🗡️ Blue Dude
                        </p>
                    </div>

                    <div>
                        <h4 style="color:#00ff00;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">✨
                            COMMON (95%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                            🎨 Skins<br>
                            💥 Effects<br>
                            🏆 Titles<br>
                            💰 Coin Bundles
                        </p>
                    </div>
                </div>

                <!-- Premium Gacha -->
                <div
                    style="flex:1;min-width:300px;max-width:500px;background:rgba(255,0,255,0.05);border:2px solid #ff00ff;padding:20px">
                    <h3 style="font-family:'Press Start 2P';color:#ff00ff;text-align:center;margin-bottom:20px">PREMIUM
                        GACHA (1🎫)</h3>

                    <div style="margin-bottom:20px">
                        <h4 style="color:#ffd700;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">🎁
                            ULTRA RARE (20%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                            💪 The Meme<br>
                            🗺️ GPS<br>
                            📞 John Pork<br>
                            🤖 Mechabara<br>
                            🗡️ Blue Dude<br>
                            ⚡ Glitch (EXCLUSIVE!)
                        </p>
                    </div>

                    <div style="margin-bottom:20px">
                        <h4 style="color:#ff00ff;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">⭐ RARE
                            (30%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                            🎲 Lucky Block<br>
                            💸 Brokeboy
                        </p>
                    </div>

                    <div>
                        <h4 style="color:#00ff00;font-family:'Press Start 2P';font-size:12px;margin-bottom:10px">✨
                            COSMETIC (50%)</h4>
                        <p style="color:#fff;font-family:'Press Start 2P';font-size:10px;line-height:1.8">
                            🎨 Exclusive Skins<br>
                            💥 Premium Effects<br>
                            🏆 Rare Titles
                        </p>
                    </div>

                    <div style="margin-top:20px;padding:10px;background:rgba(255,215,0,0.1);border:1px solid #ffd700">
                        <p style="color:#ffd700;font-family:'Press Start 2P';font-size:9px;text-align:center">
                            💡 GUARANTEED RARE OR BETTER!<br>
                            Get Gacha Coins from special trophies or convert 1000💰 → 1🎫
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="char-select" class="screen hidden">
        <h2>SELECT FIGHTER</h2>
        <h3 id="select-instruction">P1 CHOOSE</h3>
        <div class="char-grid" id="char-grid"></div>
        <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px">
            <button class="menu-btn" id="p1-mastery-toggle" style="display:none" onclick="toggleMastery(1)">P1 MASTERY:
                OFF</button>
            <button class="menu-btn" id="p2-mastery-toggle" style="display:none" onclick="toggleMastery(2)">P2 MASTERY:
                OFF</button>
        </div>
        <div id="cpu-controls"><button class="menu-btn" id="cpu-toggle" onclick="toggleCpu()">P2: HUMAN</button>
            <div id="cpu-level-container" style="display:none;color:#ccc;font-family:'Press Start 2P'">LVL <span
                    id="cpu-level-val">5</span> <input type="range" min="1" max="9" value="5"
                    oninput="updateCpuLevel(this.value)"></div>
        </div>
    </div>
    <div id="map-select" class="screen hidden">
        <h2>SELECT STAGE</h2>
        <div class="map-grid" id="map-grid" style="display:flex;gap:20px"></div>
    </div>
    <div id="controls-hint" class="screen hidden" style="background:rgba(0,0,0,0.8);pointer-events:auto"
        onclick="startGameLoop()">
        <h2>READY?</h2>
        <div style="display:flex;gap:50px;text-align:left">
            <div><strong style="color:var(--p1)">P1</strong><br>WASD + F<br>ULT: R<br>SHIELD: G</div>
            <div id="p2-controls-text"><strong style="color:var(--p2)">P2</strong><br>Arrows + L<br>ULT:
                Shift<br>SHIELD: K</div>
        </div>
        <h3 class="pulse" style="margin-top:50px">CLICK TO FIGHT</h3>
    </div>
    <div id="game-over" class="screen hidden">
        <h1 id="winner-display">GAME!</h1>
        <div id="mastery-progress" style="font-family:'Press Start 2P';font-size:10px;color:#ffd700;margin:20px 0">
        </div><button class="menu-btn" onclick="rematch()" style="margin-bottom:10px" id="rematch-btn">REMATCH</button><button
            class="menu-btn" onclick="exitToMenu()" id="exit-btn">MAIN MENU</button>
    </div>
    <div id="mobile-controls">
        <div id="btn-left" class="touch-btn dpad">←</div>
        <div id="btn-right" class="touch-btn dpad">→</div>
        <div id="btn-up" class="touch-btn dpad">↑</div>
        <div id="btn-down" class="touch-btn dpad">↓</div>
        <div id="btn-atk" class="touch-btn">A</div>
        <div id="btn-jump" class="touch-btn">JUMP</div>
        <div id="btn-ult" class="touch-btn">U</div>
        <div id="btn-shield" class="touch-btn">S</div>
    </div>
    <div id="feedback-screen" class="screen hidden">
        <h2>FEEDBACK</h2>
        <div style="width: 80%; max-width: 600px; display: flex; flex-direction: column; gap: 20px;">
            <textarea id="feedback-text"
                style="width: 100%; height: 150px; background: #333; color: white; border: 2px solid #555; padding: 10px; font-family: 'Roboto', sans-serif; resize: none;"
                placeholder="Enter your feedback here..."></textarea>

            <div
                style="display: flex; align-items: center; gap: 10px; background: #222; padding: 10px; border: 1px solid #444;">
                <input type="checkbox" id="include-screenshot" checked>
                <label for="include-screenshot"
                    style="font-family: 'Press Start 2P'; font-size: 10px; cursor: pointer;">INCLUDE SCREENSHOT</label>
                <div id="screenshot-preview"
                    style="width: 50px; height: 30px; background: #000; border: 1px solid #fff; margin-left: auto; background-size: cover; background-position: center;">
                </div>
            </div>

            <button class="menu-btn" onclick="submitFeedback()">SUBMIT</button>
            <div id="feedback-status"
                style="text-align: center; font-family: 'Press Start 2P'; font-size: 12px; min-height: 20px;"></div>
        </div>
        <div id="feedback-list" class="hidden"
            style="width: 80%; max-width: 800px; height: 400px; overflow-y: auto; background: #222; border: 2px solid #555; padding: 20px; margin-top: 20px;">
            <!-- Feedback items will be populated here -->
        </div>
        <button class="menu-btn" style="margin-top: 20px;" onclick="closeFeedback()">BACK</button>
    </div>
    <script>
        console.log("RUNNING FILE VERSION: 15:15 PM");
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameState = 'TITLE',
            p1Char = null,
            p2Char = null,
            p2IsCpu = !1,
            cpuLevel = 5;
        let useMasteryP1 = false,
            useMasteryP2 = false;
        let isSurvival = !1,
            isMemeBall = !1,
            servingPlayer = 1,
            isServing = false,
            serveCharge = 0,
            p1Score = 0,
            p2Score = 0,
            ball = null;
        // Online multiplayer
        let isOnline = false,
            isHost = false,
            netSocket = null,
            netRoom = null,
            netPeerReady = false,
            netOpened = false,
            netReadyCount = 0,
            netConnectedPlayers = [], // [{id, name, ready}]
            netP2Inputs = { l: 0, r: 0, u: 0, d: 0, a: 0, j: 0, U: 0, S: 0 },
            netP3Inputs = { l: 0, r: 0, u: 0, d: 0, a: 0, j: 0, U: 0, S: 0 },
            netP4Inputs = { l: 0, r: 0, u: 0, d: 0, a: 0, j: 0, U: 0, S: 0 },
            netTick = 0,
            netGameMode = '1v1', // '1v1' or '2v2'
            customStocks = 3, // Custom stock count for online matches
            rulesItemsEnabled = true,
            rulesHazardsEnabled = true,
            rulesTeamAttack = false, // Friendly fire in teams
            netDisconnected = false; // Track mid-match disconnect
        let survivalWave = 0,
            spawnTimer = 0,
            isTraining = !1,
            trainingCpuMode = 0;
        let players = [],
            platforms = [],
            items = [],
            ultEffects = [],
            particles = [],
            itemTimer = 0,
            camera = {
                x: 0,
                y: 0,
                zoom: 1
            },
            shake = 0,
            hitStop = 0,
            mapTimer = 0;
        let megaCoinSpawned = !1,
            backgrounds = [],
            confetti = [];
        let worldFlipped = !1,
            flipTimer = 0;
        // Combo counter system
        let comboCount = 0, comboTimer = 0, comboLastHitter = 0, comboBestThisGame = 0;
        // Announcer hype system
        let announceText = '', announceTimer = 0, announceColor = '#fff';
        function showAnnounce(text, color) { announceText = text; announceTimer = 120; announceColor = color || '#fff'; }
        // Weather system
        let weatherType = 'none', weatherTimer = 0, weatherParticles = [];
        const keys = {};
        const touchInput = {
            left: !1,
            right: !1,
            up: !1,
            down: !1,
            atk: !1,
            jump: !1,
            ult: !1,
            shield: !1
        };
        let showHitboxes = !1,
            shopCharIndex = 0,
            shopSelectedItem = null;
        let killCount = 0;
        const cheatCode = ['ArrowUp', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft'];
        let cheatIndex = 0;
        const cheatCode2 = ['ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowLeft'];
        let cheatIndex2 = 0;
        const cheatCode3 = ['ArrowLeft', 'ArrowLeft', 'ArrowRight', 'ArrowRight', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowRight'];
        let cheatIndex3 = 0;
        const cheatCode4 = ['ArrowUp', 'ArrowDown', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        let cheatIndex4 = 0;
        const cheatCodeGacha = ['ArrowUp', 'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowDown', 'ArrowLeft'];
        let cheatIndexGacha = 0;
        // Konami code: Up, Up, Down, Down, Left, Right, Left, Right, B, A
        const cheatCodeKonami = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'B', 'A'];
        let cheatIndexKonami = 0;
        // Pork code: (example) Up, Down, Left, Right, P, O, R, K
        const cheatCodePork = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'p', 'o', 'r', 'k'];
        let cheatIndexPork = 0;
        // Glitch code: G, L, I, T, C, H
        const cheatCodeGlitch = ['g', 'l', 'i', 't', 'c', 'h'];
        let cheatIndexGlitch = 0;
        const SAVE_KEY = 'meme_bros_save_v4';
        let saveData = {
            coins: 0,
            gachaCoins: 0,
            gachaPity: 0,
            unlocks: ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', '67kid', 'amogus', 'sahur', 'primo', 'ocralito'],
            goldMode: !1,
            cosmetics: [],
            trophies: [],
            mobileControls: !0,
            bannerEndTime: 0,
            currentBanner: null,
            mastery: {},
            friendCode: '',
            friends: [],
            customControls: null
        };
        let equippedCosmetic = null;
        function generateSprite(pixelData, colors) {
            const pixelSize = 1;
            const canvas = document.createElement('canvas');
            if (!pixelData || pixelData.length === 0) return canvas;
            const width = pixelData[0].length;
            const height = pixelData.length;
            canvas.width = width * pixelSize;
            canvas.height = height * pixelSize;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = !1;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!pixelData[y] || x >= pixelData[y].length) continue;
                    const colorKey = pixelData[y][x];
                    if (colors[colorKey]) {
                        ctx.fillStyle = colors[colorKey];
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            return canvas;
        }
        function generateAnimationSheet(sheetData, colors) {
            const animations = {};
            for (const animName in sheetData) {
                animations[animName] = [];
                const animFrames = sheetData[animName].frames;
                animFrames.forEach(frameData => {
                    animations[animName].push(generateSprite(frameData, colors));
                });
            }
            return animations;
        }
        const sfx = {
            ctx: null,
            vol: 0.5,
            init: function () {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            setVol: function (v) {
                this.vol = v;
            },
            play: function (type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime,
                    osc = this.ctx.createOscillator(),
                    gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                let g = 0.1 * this.vol;
                if (type === 'jump') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.linearRampToValueAtTime(300, t + 0.1);
                    gain.gain.setValueAtTime(g, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.exponentialRampToValueAtTime(10, t + 0.1);
                    gain.gain.setValueAtTime(g * 2, t);
                } else if (type === 'break') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, t);
                    gain.gain.setValueAtTime(g * 5, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.5);
                } else if (type === 'ult') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, t);
                    osc.frequency.linearRampToValueAtTime(800, t + 0.5);
                    gain.gain.setValueAtTime(g * 3, t);
                    osc.start(t);
                    osc.stop(t + 1.0);
                    return;
                } else if (type === 'coin') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1000, t);
                    gain.gain.setValueAtTime(g, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                } else if (type === 'shield') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(300, t);
                    gain.gain.setValueAtTime(g, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                } else if (type === 'mega') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.linearRampToValueAtTime(600, t + 1.0);
                    gain.gain.setValueAtTime(g * 3, t);
                    gain.gain.linearRampToValueAtTime(0, t + 1.0);
                }
                osc.start(t);
                osc.stop(t + 0.1);
            }
        };
        const music = {
            ctx: null,
            enabled: !0,
            currentTheme: null,
            nextNoteTime: 0,
            noteIndex: 0,
            tempo: 120,
            timerID: null,
            vol: 0.5,
            init: function () {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            setVol: function (v) {
                this.vol = v;
            },
            toggle: function () {
                this.enabled = !this.enabled;
                if (!this.enabled) this.stop();
                else if (this.currentTheme) this.play(this.currentTheme);
                return this.enabled;
            },
            play: function (theme) {
                if (this.currentTheme === theme && this.timerID) return;
                this.stop();
                this.currentTheme = theme;
                if (!this.enabled || !this.ctx) return;
                this.noteIndex = 0;
                this.nextNoteTime = this.ctx.currentTime;
                this.scheduler();
            },
            stop: function () {
                clearTimeout(this.timerID);
                this.timerID = null;
            },
            scheduler: function () {
                if (!this.enabled) return;
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.playPattern();
                    this.nextNoteTime += (60 / this.tempo) * 0.25;
                    this.noteIndex++;
                }
                this.timerID = setTimeout(() => this.scheduler(), 25);
            },
            playPattern: function () {
                if (!this.enabled) return;
                const t = this.nextNoteTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                let freq = 0;
                let step = this.noteIndex % 16;
                if (this.currentTheme === 'MENU') {
                    this.tempo = 100;
                    osc.type = 'triangle';
                    const seq = [261, 0, 311, 0, 392, 0, 311, 0, 466, 0, 392, 0, 311, 0, 261, 0];
                    freq = seq[step];
                    gain.gain.value = 0.05 * this.vol;
                } else if (this.currentTheme === 'BATTLE') {
                    this.tempo = 140;
                    osc.type = 'square';
                    const seq = [261, 261, 329, 392, 440, 440, 392, 329, 349, 349, 329, 293, 261, 293, 329, 0];
                    freq = seq[step];
                    gain.gain.value = 0.03 * this.vol;
                    if (step % 4 === 0) this.playBass(130, t);
                } else if (this.currentTheme === 'BOSS') {
                    this.tempo = 110;
                    osc.type = 'sawtooth';
                    const seq = [65, 0, 65, 0, 69, 0, 65, 0, 73, 0, 69, 0, 65, 0, 61, 0];
                    freq = seq[step];
                    gain.gain.value = 0.08 * this.vol;
                } else if (this.currentTheme === 'WIN') {
                    this.tempo = 120;
                    osc.type = 'triangle';
                    const seq = [523, 0, 523, 0, 523, 0, 659, 0, 783, 783, 783, 783, 0, 0, 0, 0];
                    freq = seq[step];
                    gain.gain.value = 0.05 * this.vol;
                }
                if (freq > 0) {
                    osc.frequency.setValueAtTime(freq, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.start(t);
                    osc.stop(t + 0.1);
                }
            },
            playBass: function (freq, t) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0.05 * this.vol, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            }
        };
        const audioFiles = {
            vivaldi: null,
            init: function () {
                if (this.vivaldi) return; // Already initialized
                try {
                    // Create audio element for Vivaldi
                    this.vivaldi = new Audio();
                    this.vivaldi.src = 'vivaldi-winter.mp3'; // Place MP3 file in same directory
                    this.vivaldi.volume = 0.5;
                    this.vivaldi.loop = false;
                    console.log('[AudioFiles] Vivaldi initialized. File: vivaldi-winter.mp3');
                } catch (e) {
                    console.error('[AudioFiles] Failed to initialize:', e);
                }
            },
            play: function (track) {
                if (track === 'VIVALDI') {
                    if (!this.vivaldi) {
                        console.warn('[AudioFiles] Vivaldi not initialized, initializing now...');
                        this.init();
                    }
                    if (this.vivaldi) {
                        this.vivaldi.currentTime = 0;
                        this.vivaldi.play()
                            .then(() => console.log('[AudioFiles] Vivaldi playing!'))
                            .catch(e => console.error('[AudioFiles] Vivaldi playback failed:', e.message));
                    }
                }
            },
            stop: function (track) {
                if (track === 'VIVALDI' && this.vivaldi) {
                    this.vivaldi.pause();
                    this.vivaldi.currentTime = 0;
                }
            }
        };
        class Ball {
            constructor() {
                this.x = 0;
                this.y = -200;
                this.vx = 0;
                this.vy = 0;
                this.r = 40;
                this.icon = '🥔';
                this.lastHit = 0;
                this.inPlay = false;
                this.hasCrossedNet = false;
            }
            reset(servingSide) {
                this.inPlay = false;
                this.lastHit = 0;
                this.hasCrossedNet = false;
                servingPlayer = servingSide || servingPlayer;
                isServing = true;
                serveCharge = 0;

                // Position ball with serving player
                const server = players.find(p => p.id === servingPlayer);
                if (server) {
                    // Move server back to safe serving position
                    const targetX = servingPlayer === 1 ? -250 : 250;
                    server.x = targetX;
                    server.y = 0;

                    this.x = server.x;
                    this.y = server.y - 80;
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.x = servingPlayer === 1 ? -200 : 200;
                    this.y = -150;
                    this.vx = 0;
                    this.vy = 0;
                }
            }
            serve(power, side) {
                isServing = false;
                this.inPlay = true;
                this.lastHit = servingPlayer;
                this.hasCrossedNet = false;
                const direction = side === 1 ? 1 : -1;
                this.vx = direction * (8 + power * 0.15);
                this.vy = -5 - power * 0.1;
                this.serveTime = 60; // Grace period after serve (1 second)
                sfx.play('hit');
            }
            update() {
                // If serving, ball follows player
                if (isServing) {
                    const server = players.find(p => p.id === servingPlayer);
                    if (server) {
                        this.x = server.x;
                        this.y = server.y - 80;
                    }
                    return;
                }

                // Countdown serve grace period
                if (this.serveTime > 0) this.serveTime--;

                // Track if ball crosses net
                if (!this.hasCrossedNet && this.inPlay) {
                    if ((servingPlayer === 1 && this.x > 0) || (servingPlayer === 2 && this.x < 0)) {
                        this.hasCrossedNet = true;
                    }
                }

                this.vy += 0.4;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.99;
                players.forEach(p => {
                    let dx = this.x - (p.x + p.w / 2);
                    let dy = this.y - (p.y + p.h / 2);
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.r + p.w / 2 && this.lastHit !== p.id) {
                        this.vx = (dx / dist) * 10;
                        this.vy = (dy / dist) * 10 - 10;
                        this.lastHit = p.id;
                        sfx.play('hit');
                    }
                });
                platforms.forEach(p => {
                    if (p.w < 100) {
                        if (this.x + this.r > p.x && this.x - this.r < p.x + p.w && this.y + this.r > p.y && this.y - this.r < p.y + p.h) {
                            if (this.y < p.y) {
                                this.y = p.y - this.r;
                                this.vy *= -0.8;
                            } else {
                                this.vx *= -0.8;
                            }
                        }
                    }
                });

                // Check for out of bounds (sides) - reset to center without scoring
                if (this.x < -600 || this.x > 600 || this.y > 800) {
                    this.reset(servingPlayer);
                    return;
                }

                // Score only when ball hits ground on a side (after crossing net)
                if (this.y + this.r > 200 && this.inPlay && this.hasCrossedNet) {
                    let scorer = 0;
                    if (this.x < 0) {
                        p2Score++;
                        scorer = 2;
                    } else {
                        p1Score++;
                        scorer = 1;
                    }
                    document.getElementById('game-score-val').innerText = `${p1Score} - ${p2Score}`;
                    if (p1Score >= 5) endGame(1);
                    else if (p2Score >= 5) endGame(2);
                    else this.reset(scorer);
                }
            }
            draw() {
                ctx.font = "80px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.icon, this.x, this.y);
            }
        }
        class Item {
            constructor(forceType) {
                if (forceType) {
                    this.type = forceType;
                } else {
                    this.type = Math.random() > 0.8 ? 'nyan' : (Math.random() > 0.6 ? 'hammer' : (Math.random() > 0.4 ? 'coin' : (Math.random() > 0.3 ? 'star' : 'freeze')));
                }
                this.active = !0;
                this.w = 30;
                this.h = 30;
                if (this.type === 'mega') {
                    this.w = 60;
                    this.h = 60;
                    this.x = (Math.random() * 200) - 100;
                    this.y = -400;
                    this.vx = 0;
                    this.vy = 0;
                    this.icon = '💰';
                } else if (this.type === 'nyan') {
                    this.y = Math.random() * 400 - 200;
                    this.vx = (Math.random() < 0.5 ? 1 : -1) * 12;
                    this.x = this.vx > 0 ? -600 : 600;
                    this.vy = 0;
                    this.icon = '🌈';
                } else {
                    this.x = (Math.random() * 600) - 300;
                    this.y = -400;
                    this.vx = 0;
                    this.vy = 0;
                    if (this.type === 'hammer') this.icon = '🔨';
                    else if (this.type === 'landmine') this.icon = '💣';
                    else if (this.type === 'potion') this.icon = '🧪';
                    else if (this.type === 'tomato') this.icon = '🍅';
                    else if (this.type === 'star') this.icon = '⭐';
                    else if (this.type === 'freeze') this.icon = '🧊';
                    else this.icon = '💰';
                }
                this.placed = !1;
            }
            update() {
                if (!this.active) return;
                if (this.type === 'nyan') {
                    this.x += this.vx;
                    if (this.x < -1500 || this.x > 1500) this.active = !1;
                } else {
                    this.vy += 0.5;
                    if (worldFlipped) this.vy -= 1.0;
                    this.y += this.vy;
                    for (let p of platforms)
                        if (p.t !== 'lava' && !p.t.startsWith('machine') && this.vy > 0 && this.y + this.h > p.y && this.y + this.h < p.y + 30 && this.x + this.w > p.x && this.x < p.x + p.w) {
                            this.y = p.y - this.h;
                            this.vy = 0;
                        }
                    if (this.y > 800) this.active = !1;
                }
                if (this.type === 'landmine' && this.placed) {
                    players.forEach(p => {
                        if (Math.abs(p.x - this.x) < 30 && Math.abs(p.y - this.y) < 30) {
                            p.hit(0, -20, 30);
                            ultEffects.push({
                                t: 'tear',
                                x: this.x,
                                y: this.y,
                                l: 10
                            });
                            this.active = !1;
                            sfx.play('break');
                        }
                    });
                }
            }
            draw() {
                if (!this.active) return;
                ctx.font = this.type === 'mega' ? "80px Arial" : "30px Arial";
                if (this.type === 'landmine' && this.placed) ctx.font = "20px Arial";
                ctx.fillText(this.icon, this.x, this.y + 30);
            }
        }
        class Fighter {
            constructor(id, s, x, y, loc, cpu) {
                this.id = id;
                this.stats = s;
                this.x = x;
                this.y = y;
                this.w = 50;
                this.h = 50;
                this.vx = 0;
                this.vy = 0;
                this.pct = 0;
                this.stocks = 3;
                this.ult = 0;
                this.dir = id === 1;
                this.loc = loc;
                this.cpu = cpu;
                this.jumps = 2;
                this.stun = 0;
                this.inv = 0;
                this.cd = 0;
                this.box = null;
                this.hasHammer = !1;
                this.hasLandmine = !1;
                this.shieldHP = 100;
                this.shielding = !1;
                this.rolling = !1;
                this.rollDir = 0;
                this.rollTime = 0;
                this.isBoss = !1;
                this.bossHP = 0;
                this.alpha = 1;
                this.friction = 0.85;
                this.confused = 0;
                this.animation = "idle";
                this.frame = 0;
                this.frameTimer = 0;
                this.animSpeed = 0.1;
                this.animOverrideTimer = 0;
                this.animOverride = null;
                this.isParrying = !1;
                this.parryTimer = 0;
                // Mastery variant active flag (per character)
                try {
                    if (this.stats && this.stats.id) {
                        initMastery(this.stats.id);
                        const lvl = (saveData.mastery && saveData.mastery[this.stats.id]) ? saveData.mastery[this.stats.id].level : 0;
                        const unlocked = lvl >= 5;
                        const want = (this.id === 1 ? useMasteryP1 : useMasteryP2);
                        this.masteryActive = !!(unlocked && want);
                    } else {
                        this.masteryActive = false;
                    }
                } catch (e) {
                    this.masteryActive = false;
                }
            }
            updateAnimationState() {
                // Respect temporary animation overrides (e.g., attacks/ults)
                if (this.animOverrideTimer > 0) {
                    this.animOverrideTimer--;
                    return;
                }
                if (this.isParrying && this.parryTimer > 0) {
                    this.setAnimation("shield");
                    return;
                }
                if (this.stun > 0) {
                    this.setAnimation("stun");
                } else if (!this.grounded) {
                    this.setAnimation(this.vy < 0 ? "fall" : "jump");
                } else if (this.rolling) {
                    this.setAnimation("roll");
                } else if (this.shielding) {
                    this.setAnimation("shield");
                } else if (Math.abs(this.vx) > 0.5) {
                    this.setAnimation("walk");
                } else {
                    this.setAnimation("idle");
                }
            }
            setAnimation(newAnim) {
                if (this.animation !== newAnim) {
                    this.animation = newAnim;
                    this.frame = 0;
                    this.frameTimer = 0;
                    const animData = this.stats.animSheet ? this.stats.animSheet[newAnim] : null;
                    if (animData && animData.speed) {
                        this.animSpeed = animData.speed;
                    } else if (this.stats.id === 'doge' && newAnim === 'idle') {
                        this.animSpeed = 0.05;
                    } else {
                        this.animSpeed = 0.1;
                    }
                    if (this.stats.id === 'brokeboy') {
                        console.log(`[ANIM] brokeboy -> ${newAnim} (speed=${this.animSpeed})`);
                    }
                }
            }
            // Play an animation and prevent auto-state overrides for a short duration (in frames)
            playAnimation(animName, durationFrames) {
                this.setAnimation(animName);
                this.animOverride = animName;
                this.animOverrideTimer = Math.max(1, durationFrames | 0);
            }
            update() {
                if (this.stocks <= 0) return;
                this.ult = Math.min(100, this.ult + 0.05);
                if (this.shieldHP < 100 && !this.shielding) this.shieldHP += 0.5;
                if (this.alpha < 1) this.alpha += 0.001;
                if (this.friction > 0.85) this.friction -= 0.0005;
                if (this.confused > 0) this.confused--;
                if (this.luckyBlockCrush && this.grounded) {
                    let t = players.find(p => p.id !== this.id && Math.abs(p.x - this.x) < 80 && Math.abs(p.y - this.y) < 100);
                    if (t) {
                        t.hit(0, -15, 50);
                        this.luckyBlockCrush = false;
                        if (Math.random() < 0.2) {
                            this.autoParryNext = true;
                        }
                    } else {
                        this.luckyBlockCrush = false;
                    }
                }
                if (this.gamblingFever) {
                    this.gamblingFeverTimer--;
                    if (this.gamblingFeverTimer <= 0) {
                        this.gamblingFever = false;
                    } else {
                        if (this.gamblingFeverLastRoll <= 0) {
                            this.gamblingFeverLastRoll = Math.floor(Math.random() * 5) * 60 + 60;
                            const slot1 = Math.floor(Math.random() * 10);
                            const slot2 = Math.floor(Math.random() * 10);
                            const slot3 = Math.floor(Math.random() * 10);
                            if (slot1 === slot2 && slot2 === slot3 && [0, 1, 2, 3, 4, 5, 7, 8, 9].includes(slot1)) {
                                this.gamblingFeverActive = true;
                                this.gamblingFeverActiveTimer = 1200;
                                this.stats = { ...this.stats, speed: this.stats.speed * 1.5 };
                                this.alpha = 1;
                                this.inv = 1200;
                                setTimeout(() => {
                                    if (this.gamblingFeverActive) {
                                        this.stats = { ...this.stats, speed: this.stats.speed / 1.5 };
                                        this.gamblingFeverActive = false;
                                    }
                                }, 20000);
                                sfx.play('ult');
                            }
                        } else {
                            this.gamblingFeverLastRoll--;
                        }
                    }
                }
                if (this.mrbeastBoost) {
                    this.mrbeastTimer--;
                    if (this.mrbeastTimer <= 0) {
                        this.mrbeastBoost = false;
                    }
                }
                this.updateAnimationState();
                if (this.isParrying) {
                    if (this.parryTimer > 0) {
                        this.parryTimer--;
                        this.vx *= 0.1;
                    } else {
                        this.isParrying = !1;
                    }
                }
                if (this.isBoss) {
                    if (Math.random() < 0.01 && this.cd <= 0) {
                        ultEffects.push({
                            t: 'moon',
                            x: players[0].x,
                            y: -500,
                            l: 50
                        });
                        this.cd = 60;
                    }
                    if (players[0].x > this.x + 100) this.vx += 0.5;
                    else if (players[0].x < this.x - 100) this.vx -= 0.5;
                    this.phys();
                    if (this.cd > 0) this.cd--;
                    return;
                }
                if (this.rolling) {
                    this.rollTime--;
                    this.vx = this.rollDir * 15;
                    this.inv = 2;
                    if (this.rollTime <= 0) {
                        this.rolling = !1;
                        this.vx = 0;
                    }
                    this.phys();
                    return;
                }
                if (this.stun > 0) {
                    this.stun--;
                    this.shielding = !1;
                    this.vx *= 0.8;
                    this.phys();
                    return;
                }
                // Contagion poison DOT
                if (this.poisoned && this.poisonTimer > 0) {
                    this.poisonTimer--;
                    if (this.poisonTimer % 30 === 0) {
                        this.pct += 3; // Tick damage
                        particles.push({ x: this.x + this.w/2, y: this.y, text: "☠️", life: 20, vy: -1, color: '#0f0' });
                    }
                    if (this.poisonTimer <= 0) {
                        this.poisoned = false;
                    }
                }
                // Overheat burn DOT
                if (this.burning && this.burnTimer > 0) {
                    this.burnTimer--;
                    if (this.burnTimer % 20 === 0) {
                        this.pct += 4;
                        particles.push({ x: this.x + this.w/2 + (Math.random()-0.5)*20, y: this.y, text: "🔥", life: 15, vy: -1.5, color: '#f80' });
                    }
                    if (this.burnTimer <= 0) {
                        this.burning = false;
                    }
                }
                // MANTIS MK2 Bleed DOT
                if (this.bleeding && this.bleedTimer > 0) {
                    this.bleedTimer--;
                    if (this.bleedTimer % 30 === 0) {
                        this.pct += 3;
                        particles.push({ x: this.x + this.w/2 + (Math.random()-0.5)*15, y: this.y + this.h/2, text: "🩸", life: 12, vy: -1, color: '#ff0044' });
                    }
                    if (this.bleedTimer <= 0) {
                        this.bleeding = false;
                    }
                }
                // EL DORADO - Adaptive ICE cooldown tick + ready glow
                if (this.iceShieldCd > 0) {
                    this.iceShieldCd--;
                    if (this.iceShieldCd <= 0) {
                        // Shield recharged notification
                        particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "🛡️ ICE READY", life: 40, vy: -1, color: '#ffd700' });
                    }
                }
                // ICE shield active glow (subtle golden ring every 90 frames)
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.software === 'el_dorado' && (!this.iceShieldCd || this.iceShieldCd <= 0)) {
                    if (Math.random() < 0.015) {
                        particles.push({ x: this.x + this.w/2 + (Math.random()-0.5)*30, y: this.y + this.h/2 + (Math.random()-0.5)*30, vx: 0, vy: -0.5, life: 20, color: '#ffd700', size: 2 });
                    }
                }
                // MONOWIRE: Charge damage while not attacking
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.arm === 'monowire') {
                    if (!this.monowireCharge) this.monowireCharge = 0;
                    if (this.cd <= 0 && !this.box) {
                        this.monowireCharge = Math.min(12, this.monowireCharge + 0.02);
                        // Glow when fully charged
                        if (this.monowireCharge >= 12 && Math.random() < 0.03) {
                            particles.push({ x: this.x + (this.dir ? this.w+5 : -5), y: this.y + this.h/2, vx: 0, vy: -0.5, life: 10, color: '#f0f', size: 2 });
                        }
                    }
                }
                // WEAPON GLITCH: Countdown + prevent attacking
                if (this.weaponGlitched && this.weaponGlitchTimer > 0) {
                    this.weaponGlitchTimer--;
                    if (this.weaponGlitchTimer % 30 === 0) {
                        particles.push({ x: this.x + this.w/2, y: this.y - 5, text: "🚫", life: 10, vy: -1, color: '#ff0' });
                    }
                    if (this.weaponGlitchTimer <= 0) {
                        this.weaponGlitched = false;
                    }
                }
                // CYBERPSYCHOSIS: Forced to attack nearest ally
                if (this.cyberpsychosis && this.cyberpsychosisTimer > 0) {
                    this.cyberpsychosisTimer--;
                    // Tint red periodically
                    if (this.cyberpsychosisTimer % 20 === 0) {
                        particles.push({ x: this.x + this.w/2, y: this.y, text: "🤯", life: 12, vy: -1, color: '#f0f' });
                    }
                    if (this.cyberpsychosisTimer <= 0) {
                        this.cyberpsychosis = false;
                    }
                }
                // OPTICAL CAMO: Stealth timer
                if (this.opticalCamoTimer && this.opticalCamoTimer > 0) {
                    this.opticalCamoTimer--;
                    if (this.opticalCamoTimer <= 0) {
                        this.opticalCamoActive = false;
                    }
                }
                // OPTICAL CAMO: Cooldown tick
                if (this.opticalCamoCd > 0) this.opticalCamoCd--;
                // REINFORCED TENDONS: Reset double jump flag when grounded
                if (this.grounded && this.doubleJumped) {
                    this.doubleJumped = false;
                }
                // LYNX PAWS: Speed boost (applied during movement)
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.legs === 'lynx_paws') {
                    if (!this.lynxSpeedApplied) {
                        this.lynxSpeedApplied = true;
                    }
                }
                // BERSERK: Red aura while active
                if (this.berserkActive && Math.random() < 0.05) {
                    particles.push({ x: this.x + (Math.random()-0.5)*this.w*1.5, y: this.y + Math.random()*this.h, vx: 0, vy: -1, life: 10, color: '#f00', size: 3 });
                }
                // RICKROLL DOT: Take damage while rickrolled
                if (this.rickrolled && this.rickrollTimer > 0) {
                    this.rickrollTimer--;
                    if (this.rickrollTimer % 30 === 0) {
                        this.pct += 3;
                        particles.push({ x: this.x + this.w/2, y: this.y - 10, text: '🎵', life: 15, vy: -2, color: '#FF6347' });
                    }
                    if (this.rickrollTimer % 20 === 0) {
                        particles.push({ x: this.x + (Math.random()-0.5)*30, y: this.y + Math.random()*this.h, vx: (Math.random()-0.5)*3, vy: -1, life: 12, text: ['🎤','🎵','🎶'][Math.floor(Math.random()*3)], color: '#FF6347' });
                    }
                    if (this.rickrollTimer <= 0) { this.rickrolled = false; }
                }
                // NYAN CAT: Leave rainbow trail while moving fast
                if (this.stats.id === 'nyancat' && Math.abs(this.vx) > 3 && Math.random() < 0.3) {
                    const colors = ['#FF0000','#FF7F00','#FFFF00','#00FF00','#0000FF','#8B00FF'];
                    for (let rc = 0; rc < 6; rc++) {
                        particles.push({
                            x: this.x + (this.dir ? -5 : this.w+5), y: this.y + 5 + rc * 7,
                            vx: (this.dir ? -1 : 1) * 1, vy: 0,
                            life: 15, color: colors[rc], size: 3
                        });
                    }
                }
                // SHREK RAGE: Damage boost while ult active
                if (this.shrekRage && Math.random() < 0.08) {
                    particles.push({ x: this.x + Math.random()*this.w, y: this.y + Math.random()*this.h, vx: 0, vy: -1, life: 10, color: '#4a8c2a', size: 4 });
                }
                let l = 0,
                    r = 0,
                    u = 0,
                    d = 0,
                    a = 0,
                    j = 0,
                    U = 0,
                    S = 0;
                if (this.cpu) {
                    let t = players.find(p => p.id !== this.id);
                    if (isMemeBall && ball) {
                        // Predict ball landing position
                        let predictX = ball.x;
                        let predictY = ball.y;
                        let testVx = ball.vx;
                        let testVy = ball.vy;

                        // Simulate up to 60 frames ahead
                        for (let i = 0; i < 60 && predictY < 200; i++) {
                            testVy += 0.4; // gravity
                            predictX += testVx;
                            predictY += testVy;
                            testVx *= 0.99;
                            testVy *= 0.99;

                            // Check for net collision
                            if (predictX > -50 && predictX < 40 && predictY > 0 && predictY < 200) {
                                testVx *= -0.8;
                                predictX = testVx > 0 ? 40 : -50;
                            }
                        }

                        // Determine which side CPU should stay on
                        let mySide = this.id === 1 ? -1 : 1; // P1 on left, P2 on right
                        let targetX = predictX;

                        // If ball is on opponent's side and moving away, stay near net
                        if ((mySide === -1 && ball.x > 0 && ball.vx > 0) ||
                            (mySide === 1 && ball.x < 0 && ball.vx < 0)) {
                            targetX = mySide * 100; // Stay near net but not too close
                        }

                        // If ball is coming toward my side, position at predicted landing
                        else if ((mySide === -1 && ball.x <= 0) || (mySide === 1 && ball.x >= 0)) {
                            // Clamp to my side with margin
                            targetX = Math.max(mySide * 250, Math.min(mySide * 50, predictX));
                        }

                        // Move toward target position
                        let moveThreshold = 30 + (10 - cpuLevel) * 5; // Higher level = more precise
                        if (Math.abs(targetX - this.x) > moveThreshold) {
                            if (targetX > this.x) r = 1;
                            else l = 1;
                        }

                        // Jump to hit ball when it's near
                        let distToBall = Math.sqrt((ball.x - this.x) ** 2 + (ball.y - this.y) ** 2);
                        let ballApproaching = (mySide === -1 && ball.vx < 0) || (mySide === 1 && ball.vx > 0);

                        // Jump heuristics: easier levels still jump for obvious descending balls
                        if (distToBall < 170 && ball.y < 170 && this.grounded) {
                            let obviousHigh = ball.y < this.y - 40; // Ball noticeably above character
                            let descending = ball.vy > -2; // Not rising too fast
                            if (ballApproaching || cpuLevel <= 3 || (obviousHigh && descending)) {
                                j = 1;
                            }
                        }

                        // Attack when ball is in range
                        let attackRange = 90 + cpuLevel * 6; // Slightly larger to ensure easy hits
                        let canAttack = distToBall < attackRange && ball.y < this.y + 50 && ball.y > this.y - 100;
                        if (canAttack) {
                            // Decide attack direction based on ball position
                            if (ball.y < this.y - 30) u = 1; // Up attack for high balls
                            else if (ball.y > this.y + 30) d = 1; // Down attack for low balls

                            // Directional attack based on where we want to hit
                            if (Math.abs(ball.x - this.x) < 100) {
                                // Close range - hit toward opponent's side
                                if (mySide === -1) r = 1; // Hit right
                                else l = 1; // Hit left
                            }

                            a = 1; // Trigger attack

                            // Miss chance scaled gently; very low levels still mostly succeed
                            if (cpuLevel <= 2 && Math.random() > 0.92) a = 0; // ~8% miss
                            else if (cpuLevel <= 4 && Math.random() > 0.95) a = 0; // ~5% miss
                        }

                        // Simple fallback swing for very easy levels when ball is close but canAttack false
                        if (!canAttack && cpuLevel <= 3) {
                            if (distToBall < 140 && Math.abs(ball.x - this.x) < 120 && ball.y < this.y + 30) {
                                // Light adjust to center under ball
                                if (ball.x > this.x + 20) r = 1; else if (ball.x < this.x - 20) l = 1;
                                a = 1;
                                if (ball.y < this.y - 20) u = 1;
                            }
                        }

                        // Avoid drifting off net line unless not in attack situation
                        if (!canAttack) {
                            let boundaryBuffer = 5;
                            if (mySide === -1 && this.x > -boundaryBuffer) l = 1;
                            if (mySide === 1 && this.x < boundaryBuffer) r = 1;
                        }
                    } else if (t) {
                        let dx = t.x - this.x,
                            dy = t.y - this.y,
                            dist = Math.sqrt(dx * dx + dy * dy);
                        if (this.y > 250 || Math.abs(this.x) > 700) {
                            if (this.x < 0) r = 1;
                            else l = 1;
                            if (this.jumps > 0 && this.vy > 0) j = 1;
                            if (this.jumps == 0) {
                                u = 1;
                                a = 1;
                            }
                        } else {
                            if (Math.abs(dx) > 60) {
                                if (dx > 0) r = 1;
                                else l = 1;
                            }
                            if (dy < -100 && this.jumps > 0 && Math.random() < (cpuLevel * 0.02)) j = 1;
                            if (dist < 150 && Math.random() < (cpuLevel * 0.01)) {
                                a = 1;
                                if (dy > 50) d = 1;
                                else if (dy < -50) u = 1;
                                else if (Math.abs(dx) > 20) {
                                    if (dx > 0) r = 1;
                                    else l = 1;
                                }
                            }
                            if (cpuLevel > 6 && dist < 100 && t.box && t.box.act && Math.random() < 0.3) S = 1;
                            if (this.ult >= 100 && dist < 200 && cpuLevel > 5) U = 1;
                        }
                    }
                } else {
                    if (this.id === 1) {
                        const p1 = getControl('p1', 'left') || 'a';
                        const p1r = getControl('p1', 'right') || 'd';
                        const p1u = getControl('p1', 'up') || 'w';
                        const p1d = getControl('p1', 'down') || 's';
                        const p1a = getControl('p1', 'attack') || 'f';
                        const p1ult = getControl('p1', 'ult') || 'q';
                        const p1shield = getControl('p1', 'shield') || 'g';

                        l = keys[p1] || touchInput.left;
                        r = keys[p1r] || touchInput.right;
                        u = keys[p1u] || touchInput.up;
                        d = keys[p1d] || touchInput.down;
                        a = keys[p1a] || touchInput.atk;
                        j = keys[p1u] || touchInput.jump;
                        U = keys[p1ult] || touchInput.ult;
                        S = keys[p1shield] || touchInput.shield;
                    } else {
                        if (isOnline && isHost) {
                            // Use networked inputs for P2/P3/P4 on host
                            if (this.id === 2) {
                                l = netP2Inputs.l; r = netP2Inputs.r; u = netP2Inputs.u; d = netP2Inputs.d; a = netP2Inputs.a; j = netP2Inputs.j; U = netP2Inputs.U; S = netP2Inputs.S;
                            } else if (this.id === 3) {
                                l = netP3Inputs.l; r = netP3Inputs.r; u = netP3Inputs.u; d = netP3Inputs.d; a = netP3Inputs.a; j = netP3Inputs.j; U = netP3Inputs.U; S = netP3Inputs.S;
                            } else if (this.id === 4) {
                                l = netP4Inputs.l; r = netP4Inputs.r; u = netP4Inputs.u; d = netP4Inputs.d; a = netP4Inputs.a; j = netP4Inputs.j; U = netP4Inputs.U; S = netP4Inputs.S;
                            }
                        } else {
                            const p2l = getControl('p2', 'left') || 'ArrowLeft';
                            const p2r = getControl('p2', 'right') || 'ArrowRight';
                            const p2u = getControl('p2', 'up') || 'ArrowUp';
                            const p2d = getControl('p2', 'down') || 'ArrowDown';
                            const p2a = getControl('p2', 'attack') || 'l';
                            const p2ult = getControl('p2', 'ult') || 'Shift';
                            const p2shield = getControl('p2', 'shield') || 'k';
                            l = keys[p2l]; r = keys[p2r]; u = keys[p2u]; d = keys[p2d]; a = keys[p2a]; j = keys[p2u]; U = keys[p2ult]; S = keys[p2shield];
                        }
                    }
                }
                if (this.confused > 0) {
                    let temp = l;
                    l = r;
                    r = temp;
                }
                if (a && l) this.dir = !1;
                if (a && r) this.dir = !0;
                this.shielding = !1;
                if (S && !a && this.grounded && this.shieldHP > 0 && this.stun <= 0 && !isMemeBall) {
                    this.shielding = !0;
                    this.vx *= 0.5;
                    this.shieldHP -= 0.5;
                    if (l || r) {
                        this.rolling = !0;
                        this.rollDir = l ? -1 : 1;
                        this.rollTime = 15;
                        this.shielding = !1;
                        this.inv = 15;
                        sfx.play('roll');
                        // OPTICAL CAMO: Activate stealth on dodge
                        if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.software === 'optical_camo' && !this.opticalCamoCd) {
                            this.opticalCamoActive = true;
                            this.opticalCamoTimer = 180; // 3 seconds
                            this.opticalCamoCd = 600; // 10 second cooldown
                            particles.push({ x: this.x + this.w/2, y: this.y, text: "👁️ CAMO ON", life: 30, vy: -1.5, color: '#0ff' });
                        }
                        if (this.opticalCamoCd > 0) this.opticalCamoCd--;
                        // KERENZIKOV: Trigger bullet-time on dodge near attacks
                        if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.software === 'kerenzikov') {
                            let nearAttack = false;
                            players.forEach(p => {
                                if (p.id !== this.id && p.box && p.box.act) {
                                    const dist = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
                                    if (dist < 100) nearAttack = true;
                                }
                            });
                            if (nearAttack) {
                                const selfRef = this;
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.3;
                                });
                                setTimeout(() => {
                                    players.forEach(p => {
                                        if (p !== selfRef && !selfRef.dynlarActive && !selfRef.apogeeActive && !selfRef.zetaActive) {
                                            p.sandySlowMult = 1;
                                        }
                                    });
                                }, 1500);
                                particles.push({ x: this.x + this.w/2, y: this.y, text: "⚡ KERENZIKOV", life: 30, vy: -2, color: '#ff0' });
                                sfx.play('ult');
                            }
                        }
                        return;
                    }
                    if (this.shieldHP <= 0) {
                        sfx.play('break');
                        this.shielding = !1;
                        this.stun = 180;
                        this.vy = -10;
                    }
                }
                if (U && this.ult >= 100 && !isMemeBall) this.fireUlt();
                const sp = 1.5 * this.stats.speed * (this.sandySlowMult || 1);
                if (!this.shielding && !this.isParrying) {
                    if (l) {
                        this.vx -= sp;
                        this.dir = !1;
                    }
                    if (r) {
                        this.vx += sp;
                        this.dir = !0;
                    }
                }
                this.vx *= this.friction;
                // LYNX PAWS: Speed boost
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.legs === 'lynx_paws') {
                    this.vx *= 1.2;
                }
                if (j && !this.pj && this.jumps > 0 && !this.shielding && !this.isParrying) {
                    // FORTIFIED ANKLES: Charge Jump — stronger jump
                    const legs = (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots) ? saveData.cyberSlots.legs : null;
                    const jumpMult = legs === 'fortified_ankles' ? 1.3 : 1;
                    this.vy = -14 * this.stats.jump * (this.sandySlowMult || 1) * jumpMult;
                    this.jumps--;
                    sfx.play('jump');
                    if (legs === 'fortified_ankles' && jumpMult > 1) {
                        particles.push({ x: this.x + this.w/2, y: this.y + this.h, vx: 0, vy: 2, life: 10, color: '#0f0', size: 3 });
                    }
                }
                // REINFORCED TENDONS: Double Jump — extra jump mid-air
                if (j && !this.pj && this.jumps <= 0 && !this.grounded && !this.shielding && !this.isParrying) {
                    const legs = (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots) ? saveData.cyberSlots.legs : null;
                    if (legs === 'reinforced_tendons' && !this.doubleJumped) {
                        this.vy = -12 * this.stats.jump * (this.sandySlowMult || 1);
                        this.doubleJumped = true;
                        sfx.play('jump');
                        particles.push({ x: this.x + this.w/2, y: this.y + this.h, text: "⬆️", life: 12, vy: 1, color: '#0cf' });
                    }
                }
                this.pj = j;
                if (this.cd > 0) this.cd--;
                else if (a && !this.shielding && !this.isParrying) this.atk(u, d, l, r);
                this.phys();
                if (this.inv > 0) this.inv--;
                this.chkItm();
                if (this.box && this.box.act) {
                    this.box.f--;
                    if (this.box.f <= 0) this.box.act = !1;
                }
            }
            fireUlt() {
                if (this.ult < 100) return; // Safety check
                this.ult = 0;
                this.cd = 30; // Add cooldown to prevent rapid re-fire
                sfx.play('ult');
                shake = 30;
                updateHUD();
                let t = players.find(p => p.id !== this.id);
                if (!t) return;

                // Debug: log which character is firing ult
                console.log(`Player ${this.id} (${this.stats.id}) firing ult`);

                if (this.stats.id === 'doge') ultEffects.push({
                    t: 'moon',
                    x: t.x,
                    y: -500,
                    l: 50
                });
                else if (this.stats.id === 'frog') {
                    for (let i = 0; i < 20; i++) ultEffects.push({
                        t: 'tear',
                        x: Math.random() * 2000 - 1000,
                        y: -200 - Math.random() * 500,
                        l: 100
                    });
                } else if (this.stats.id === 'sanic') {
                    this.x = t.x;
                    this.y = t.y;
                    t.hit(0, -15, 30);
                    this.inv = 60;
                } else if (this.stats.id === 'chad') {
                    t.stun = 180;
                    t.vx = 0;
                    t.vy = 0;
                } else if (this.stats.id === '67kid') {
                    t.vx = -t.vx;
                    t.vy = -t.vy;
                    t.stun = 60;
                } else if (this.stats.id === 'amogus') {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    t.hit(0, 0, 50);
                } else if (this.stats.id === 'thememe') {
                    t.hit(0, -50, 999);
                } else if (this.stats.id === 'gps') {
                    worldFlipped = !0;
                    flipTimer = 600;
                } else if (this.stats.id === 'sahur') {
                    t.stun = 180;
                } else if (this.stats.id === 'primo') {
                    ultEffects.push({
                        t: 'primo',
                        owner: this.id,
                        x: this.x,
                        y: this.y - 50,
                        vx: (this.dir ? 1 : -1) * 15,
                        l: 100
                    });
                } else if (this.stats.id === 'ocralito') {
                    t.stun = 120;
                } else if (this.stats.id === 'mechabara') {
                    ultEffects.push({
                        t: 'moon',
                        x: t.x,
                        y: -500,
                        l: 50
                    });
                } else if (this.stats.id === 'bluedude') {
                    this.box = {
                        relX: this.dir ? 50 : -150,
                        relY: -25,
                        w: 100,
                        h: 100,
                        act: !0,
                        own: this.id,
                        kbx: 25,
                        kby: -20,
                        dmg: 35,
                        f: 10
                    };
                } else if (this.stats.id === 'johnpork') {
                    ultEffects.push({
                        t: 'pork',
                        x: t.x,
                        y: -600,
                        l: 120
                    });
                } else if (this.stats.id === 'luckyblock') {
                    this.gamblingFever = true;
                    this.gamblingFeverTimer = 1200;
                    this.gamblingFeverLastRoll = 0;
                    sfx.play('ult');
                } else if (this.stats.id === 'brokeboy') {
                    this.mrbeastBoost = true;
                    this.mrbeastTimer = 600;
                    this.stats = { ...this.stats, speed: this.stats.speed * 1.3, power: this.stats.power * 1.2 };
                    this.weight *= 1.5;
                    this.alpha = 1;
                    this.inv = 600;
                    // Play ult animation for a short duration
                    this.playAnimation('ult', 40);
                    setTimeout(() => {
                        if (this.mrbeastBoost) {
                            this.stats = { ...this.stats, speed: this.stats.speed / 1.3, power: this.stats.power / 1.2 };
                            this.weight /= 1.5;
                            this.mrbeastBoost = false;
                        }
                    }, 10000);
                    sfx.play('ult');
                } else if (this.stats.id === 'jack') {
                    // Everything Everywhere All At Once: Fire ALL ults!
                    console.log('Jack ult: EVERYTHING EVERYWHERE ALL AT ONCE!');
                    shake = 60;
                    // Make Jack invincible during ult to prevent self-damage
                    this.inv = 240; // 4 seconds of invincibility
                    // Play Vivaldi Four Seasons Winter
                    audioFiles.play('VIVALDI');

                    // Fire every ult effect with extended delays for longer sequence
                    setTimeout(() => ultEffects.push({ t: 'moon', x: t.x, y: -500, l: 50 }), 200); // Doge
                    setTimeout(() => {
                        for (let i = 0; i < 20; i++) ultEffects.push({
                            t: 'tear',
                            x: Math.random() * 1400 - 700,
                            y: -200 - Math.random() * 400,
                            l: 90
                        });
                    }, 400); // Frog
                    setTimeout(() => { if (t && t.stocks > 0) { this.x = t.x; this.y = t.y; t.hit(0, -15, 30); } }, 600); // Sanic
                    setTimeout(() => ultEffects.push({ t: 'fire', owner: this.id, x: this.x, y: this.y, vx: 0, vy: 0, l: 70 }), 800); // Chad
                    setTimeout(() => { if (t) t.confused = 300; }, 1000); // Gps
                    setTimeout(() => ultEffects.push({ t: 'sword', owner: this.id, x: this.x, y: this.y - 20, l: 100 }), 1200); // Sahur
                    setTimeout(() => ultEffects.push({ t: 'primo', owner: this.id, x: this.x, y: this.y - 50, vx: (this.dir ? 1 : -1) * 15, l: 110 }), 1400); // Primo
                    setTimeout(() => { if (t) t.stun = 180; }, 1600); // Ocralito/others
                    setTimeout(() => ultEffects.push({ t: 'pork', x: t.x, y: -600, l: 130 }), 1800); // Johnpork
                    setTimeout(() => {
                        // Bluedude punch
                        this.box = {
                            relX: this.dir ? 50 : -150,
                            relY: -25,
                            w: 120,
                            h: 120,
                            act: !0,
                            own: this.id,
                            kbx: 35,
                            kby: -28,
                            dmg: 50,
                            f: 10
                        };
                    }, 2000);
                    // Giant combined FINALE - ONE SHOT KILL
                    setTimeout(() => {
                        shake = 100;
                        for (let i = 0; i < 50; i++) {
                            particles.push({
                                x: this.x + this.w / 2,
                                y: this.y + this.h / 2,
                                vx: (Math.random() - 0.5) * 25,
                                vy: (Math.random() - 0.5) * 25,
                                size: 15,
                                life: 100,
                                color: ['#FFD700', '#FF4500', '#8B00FF', '#00CED1', '#FF1493', '#FFFFFF'][Math.floor(Math.random() * 6)]
                            });
                        }
                        // ONE SHOT: Deal 999 damage to guarantee kill
                        if (t && t.stocks > 0) {
                            t.pct = 999;
                            t.hit(35 * (this.x < t.x ? 1 : -1), -40, 999);
                        }
                        // Stop Vivaldi after ult completes
                        audioFiles.stop('VIVALDI');
                    }, 2400);
                    sfx.play('ult');
                // ====== NYAN CAT ULT: NYAN STORM ======
                } else if (this.stats.id === 'nyancat') {
                    // Rain rainbow projectiles across the entire stage
                    shake = 40;
                    for (let i = 0; i < 15; i++) {
                        setTimeout(() => {
                            ultEffects.push({
                                t: 'nyan_rainbow',
                                x: -800 + Math.random() * 1600,
                                y: -400 - Math.random() * 200,
                                vx: (Math.random() - 0.5) * 4,
                                vy: 6 + Math.random() * 3,
                                l: 120,
                                owner: this.id
                            });
                        }, i * 100);
                    }
                    // Screen flash rainbow
                    for (let i = 0; i < 30; i++) {
                        const angle = (i / 30) * Math.PI * 2;
                        particles.push({
                            x: this.x + this.w/2, y: this.y + this.h/2,
                            vx: Math.cos(angle) * 12, vy: Math.sin(angle) * 12,
                            life: 40, color: ['#FF0000','#FF7F00','#FFFF00','#00FF00','#0000FF','#8B00FF'][i % 6], size: 6
                        });
                    }
                // ====== SHREK ULT: GET OUT OF MY SWAMP ======
                } else if (this.stats.id === 'shrek') {
                    // Massive shockwave pushes everyone away + swamp zone
                    shake = 50;
                    players.forEach(p => {
                        if (p.id !== this.id && p.stocks > 0) {
                            const dir = p.x > this.x ? 1 : -1;
                            p.hit(30 * dir, -20, 40);
                            p.stun = 90;
                        }
                    });
                    // Swamp eruption
                    for (let i = 0; i < 25; i++) {
                        particles.push({
                            x: this.x + this.w/2 + (Math.random()-0.5)*200,
                            y: this.y + this.h,
                            vx: (Math.random()-0.5)*15, vy: -Math.random()*15 - 5,
                            life: 50, color: ['#2d5a1e','#4a8c2a','#3b7a24','#1a3d12'][Math.floor(Math.random()*4)], size: 8
                        });
                    }
                    // Temporary super armor for 5 seconds
                    this.inv = 300;
                    this.shrekRage = true;
                    setTimeout(() => { this.shrekRage = false; }, 5000);
                    particles.push({ x: this.x + this.w/2, y: this.y - 30, text: "GET OUT OF MY SWAMP!", life: 60, vy: -1, color: '#4a8c2a' });
                // ====== RICK ASTLEY ULT: RICKROLL ======
                } else if (this.stats.id === 'rickastley') {
                    // All enemies are stunned and forced to dance, take damage over time
                    shake = 30;
                    players.forEach(p => {
                        if (p.id !== this.id && p.stocks > 0) {
                            p.stun = 180; // 3 second stun
                            p.rickrolled = true;
                            p.rickrollTimer = 180;
                        }
                    });
                    // Musical explosion
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: this.x + this.w/2 + (Math.random()-0.5)*100,
                            y: this.y + this.h/2 + (Math.random()-0.5)*100,
                            vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
                            life: 50, text: ['🎵','🎶','🎤','🎵','🎶'][i%5], color: '#FF6347'
                        });
                    }
                    particles.push({ x: this.x + this.w/2, y: this.y - 30, text: "🎤 NEVER GONNA GIVE YOU UP!", life: 80, vy: -0.5, color: '#FF6347' });
                } else t.hit(20 * (this.x < t.x ? 1 : -1), -20, 40);
            }
            atk(u, d, l, r) {
                // WEAPON GLITCH: Can't attack while glitched
                if (this.weaponGlitched && this.weaponGlitchTimer > 0) {
                    particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "🚫 JAMMED", life: 15, vy: -1, color: '#ff0' });
                    this.cd = 10;
                    return;
                }
                this.cd = 30;
                sfx.play('hit');
                let ox = this.dir ? 50 : -60,
                    dmg = 10,
                    kbx = 10,
                    kby = -10;
                const s = this.stats;
                if (this.hasLandmine) {
                    this.hasLandmine = !1;
                    let trap = new Item('landmine');
                    trap.x = this.x;
                    trap.y = this.y;
                    trap.active = !0;
                    trap.placed = !0;
                    items.push(trap);
                    return;
                }
                if (this.hasHammer) {
                    this.hasHammer = !1;
                    this.cd = 45;
                    this.box = {
                        relX: this.dir ? 0 : -40,
                        relY: -20,
                        w: 90,
                        h: 70,
                        act: !0,
                        own: this.id,
                        kbx: 25,
                        kby: -15,
                        dmg: 25,
                        f: 5
                    };
                    return;
                }
                if (s.id === 'yellowdude') {
                    const core = saveData.cyberSlots ? saveData.cyberSlots.core : null;
                    const arm = saveData.cyberSlots ? saveData.cyberSlots.arm : null;
                    const software = saveData.cyberSlots ? saveData.cyberSlots.software : null;
                    const legs = saveData.cyberSlots ? saveData.cyberSlots.legs : null;

                    // DOWN SPECIAL: Sandevistans or Kiroshi Counter
                    if (d) {
                        // DAVID'S SANDEVISTAN (Down Special) - 95% Slow + Self Speed Boost
                        if (core === 'david_sandevistan') {
                            if (!this.davidSandyActive) {
                                this.davidSandyActive = true;
                                const selfRef = this;
                                showNotification("SANDEVISTAN!", "TIME DILATION ACTIVE");
                                sfx.play('ult');
                                // Slow enemies 95%, boost self speed
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.05;
                                });
                                selfRef.sandySlowMult = 2.0; // Speed boost like anime
                                // Anime-style activation burst
                                for (let i = 0; i < 20; i++) {
                                    const angle = (i / 20) * Math.PI * 2;
                                    particles.push({ 
                                        x: this.x + this.w/2 + Math.cos(angle) * 30, 
                                        y: this.y + this.h/2 + Math.sin(angle) * 30, 
                                        vx: Math.cos(angle) * 8, 
                                        vy: Math.sin(angle) * 8, 
                                        life: 25, 
                                        color: '#ff003c', 
                                        size: 4 
                                    });
                                }
                                // Spine glow effect (vertical line)
                                for (let i = 0; i < 8; i++) {
                                    particles.push({ 
                                        x: this.x + this.w/2, 
                                        y: this.y + i * 5, 
                                        vx: 0, 
                                        vy: -2, 
                                        life: 40, 
                                        color: '#ff0066', 
                                        size: 3 
                                    });
                                }
                                particles.push({ x: this.x + this.w / 2, y: this.y - 10, text: "SANDEVISTAN", life: 45, vy: -1, color: '#ff003c' });
                                setTimeout(() => {
                                    players.forEach(p => {
                                        if (p !== selfRef) p.sandySlowMult = 1;
                                    });
                                    selfRef.sandySlowMult = 1;
                                    selfRef.davidSandyActive = false;
                                    davidSandyAfterimages = [];
                                }, 7000);
                                this.cd = 20;
                            }
                            return;
                        }
                        // APOGEE SANDEVISTAN (Down Special) - 90% Time Slow + Kill Reset
                        if (core === 'sandevistan_apogee') {
                            if (!this.apogeeActive) {
                                this.apogeeActive = true;
                                const selfRef = this;
                                showNotification("APOGEE ENGAGED", "TIME DILATION 90%");
                                sfx.play('ult');
                                // Slow OTHERS via multiplier (never mutate stats)
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.1;
                                });
                                particles.push({ x: this.x + this.w / 2, y: this.y, text: "⏱️ APOGEE", life: 60, vy: -2, color: '#f0f' });
                                setTimeout(() => {
                                    players.forEach(p => {
                                        if (p !== selfRef) p.sandySlowMult = 1;
                                    });
                                    selfRef.apogeeActive = false;
                                }, 6000);
                                this.cd = 20;
                            }
                            return;
                        }
                        // DYNLAR SANDEVISTAN MK2 (Down Special) - Enhanced Time Slow
                        if (core === 'sandevistan_dynlar_mk2') {
                            if (!this.dynlarActive) {
                                this.dynlarActive = true;
                                this.dynlarKillCount = 0;
                                const selfRef = this;
                                showNotification("DYNLAR MK2 ENGAGED", "EXTREME TIME DILATION");
                                sfx.play('ult');
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.15;
                                });
                                // MK2: 6 second duration instead of 4
                                setTimeout(() => {
                                    players.forEach(p => {
                                        if (p !== selfRef) p.sandySlowMult = 1;
                                    });
                                    selfRef.dynlarActive = false;
                                }, 6000);
                                this.cd = 18;
                            }
                            return;
                        }
                        // DYNLAR SANDEVISTAN (Down Special) - Time Slow
                        if (core === 'sandevistan_dynlar') {
                            if (!this.dynlarActive) {
                                this.dynlarActive = true;
                                this.dynlarKillCount = 0;
                                const selfRef = this;
                                showNotification("DYNLAR ENGAGED", "TIME DILATION ACTIVE");
                                sfx.play('ult');
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.2;
                                });
                                setTimeout(() => {
                                    players.forEach(p => {
                                        if (p !== selfRef) p.sandySlowMult = 1;
                                    });
                                    selfRef.dynlarActive = false;
                                }, 4000);
                                this.cd = 20;
                            }
                            return;
                        }
                        // ZETATECH SANDEVISTAN MK2 (Down Special) - Speed Boost + Enemy Slow
                        if (core === 'sandevistan_zeta_mk2') {
                            if (!this.zetaActive) {
                                this.zetaActive = true;
                                this.sandySlowMult = 2.5; // MK2: 150% speed boost
                                const selfRef = this;
                                showNotification("ZETATECH MK2 ENGAGED", "SPEED +150% + TIME SLOW");
                                sfx.play('ult');
                                // MK2: Also slow enemies by 30%
                                players.forEach(p => {
                                    if (p !== selfRef) p.sandySlowMult = 0.7;
                                });
                                setTimeout(() => {
                                    selfRef.sandySlowMult = 1;
                                    selfRef.zetaActive = false;
                                    players.forEach(p => {
                                        if (p !== selfRef) p.sandySlowMult = 1;
                                    });
                                }, 5000);
                                this.cd = 18;
                            }
                            return;
                        }
                        // ZETATECH SANDEVISTAN (Down Special) - Speed Boost
                        if (core === 'sandevistan_zeta') {
                            if (!this.zetaActive) {
                                this.zetaActive = true;
                                this.sandySlowMult = 2.2;
                                showNotification("ZETATECH ENGAGED", "SPEED +120%");
                                sfx.play('ult');
                                setTimeout(() => {
                                    this.sandySlowMult = 1;
                                    this.zetaActive = false;
                                }, 5000);
                                this.cd = 20;
                            }
                            return;
                        }
                        // MILITECH BERSERK (Down Special) - Rage Mode
                        if (core === 'berserk_militech') {
                            if (!this.berserkActive) {
                                this.berserkActive = true;
                                const selfRef = this;
                                showNotification("BERSERK ENGAGED", "+50% DAMAGE | ARMOR UP");
                                sfx.play('ult');
                                // Red rage aura
                                for (let i = 0; i < 10; i++) {
                                    particles.push({ x: this.x + (Math.random()-0.5)*40, y: this.y + (Math.random()-0.5)*40, vx: (Math.random()-0.5)*6, vy: -Math.random()*4, life: 25, color: '#f00', size: 5 });
                                }
                                setTimeout(() => {
                                    selfRef.berserkActive = false;
                                    particles.push({ x: selfRef.x + selfRef.w/2, y: selfRef.y, text: "BERSERK OFF", life: 30, vy: -1, color: '#888' });
                                }, 5000);
                                this.cd = 25;
                            }
                            return;
                        }
                        // NETWATCH NETDRIVER (Down Special) - Opens Quickhack Menu (premium deck)
                        if (core === 'netwatch_netdriver') {
                            openQuickhackMenu(this);
                            return;
                        }
                        // Default Down Special: Kiroshi Counter
                        this.isParrying = true;
                        this.parryTimer = 30;
                        this.cd = 60;
                        sfx.play('shield');
                        particles.push({ x: this.x + this.w / 2, y: this.y + this.h / 2, text: "COUNTER READY", life: 30, vy: -1 });
                        return;
                    }

                    // SIDE SPECIAL
                    if (l || r) {
                        // PRIDE - Quick Draw Pistol (Software slot)
                        if (software === 'pride') {
                            if (!this.prideAmmo && this.prideAmmo !== 0) this.prideAmmo = 8;
                            if (!this.prideReloading) {
                                if (this.prideAmmo > 0) {
                                    this.prideAmmo--;
                                    this.cd = 8; // Fast fire rate
                                    sfx.play('hit');
                                    // Fire bullet projectile
                                    const bulletDir = this.dir ? 1 : -1;
                                    ultEffects.push({
                                        t: 'pride_bullet',
                                        owner: this.id,
                                        x: this.x + (this.dir ? this.w + 5 : -10),
                                        y: this.y + this.h / 2 - 3,
                                        vx: bulletDir * 18,
                                        vy: 0,
                                        l: 40,
                                        dmg: 5
                                    });
                                    // Muzzle flash
                                    particles.push({ x: this.x + (this.dir ? this.w + 8 : -8), y: this.y + this.h/2, vx: bulletDir * 3, vy: 0, life: 6, color: '#ff6600', size: 4 });
                                    particles.push({ x: this.x + (this.dir ? this.w + 5 : -5), y: this.y + this.h/2, vx: bulletDir * 2, vy: (Math.random()-0.5)*2, life: 8, color: '#ffaa00', size: 2 });
                                    // Ammo counter particle
                                    if (this.prideAmmo === 0) {
                                        particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "RELOADING...", life: 60, vy: -1, color: '#ff4444' });
                                        this.prideReloading = true;
                                        setTimeout(() => {
                                            this.prideAmmo = 8;
                                            this.prideReloading = false;
                                            particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "🔫 RELOADED", life: 35, vy: -1, color: '#ffd700' });
                                            sfx.play('coin');
                                        }, 2000);
                                    }
                                    return;
                                } else {
                                    // Still reloading, show message
                                    particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "RELOADING...", life: 20, vy: -1, color: '#f44' });
                                    this.cd = 15;
                                    return;
                                }
                            } else {
                                particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "RELOADING...", life: 20, vy: -1, color: '#f44' });
                                this.cd = 15;
                                return;
                            }
                        }
                        // LUCY'S CYBERDECK: Enhanced Quickhack Menu
                        if (core === 'lucy_cyberdeck') {
                            openQuickhackMenu(this);
                            return;
                        }
                        // CYBERDECK: Open Quickhack Menu
                        if (core === 'cyberdeck_militech') {
                            openQuickhackMenu(this);
                            return;
                        }
                        // CYBERDECK MK2: Enhanced Quickhack Menu (faster upload)
                        if (core === 'cyberdeck_militech_mk2') {
                            this.quickhackSpeedBonus = true; // Flag for faster upload time
                            openQuickhackMenu(this);
                            return;
                        }
                        // MAXTAC MANTIS BLADES (Arm slot): Thermal 5-hit combo
                        if (arm === 'maxtac_mantis') {
                            this.vx = (this.dir ? 1 : -1) * 18;
                            this.cd = 45;
                            sfx.play('hit');
                            // 5-hit thermal slash
                            for (let slash = 0; slash < 5; slash++) {
                                setTimeout(() => {
                                    if (this.stocks <= 0) return;
                                    this.box = { relX: this.dir ? 10 : -45, relY: -15, w: 55, h: 45, act: true, own: this.id, kbx: (this.dir ? 10 : -10), kby: -4, dmg: 7, f: 4 };
                                    sfx.play('hit');
                                    particles.push({ x: this.x + (this.dir ? 45 : -15), y: this.y + this.h / 2, text: "🔥", life: 12, vy: -1, color: '#ff4400' });
                                }, slash * 65);
                            }
                            // Apply burn on hit
                            setTimeout(() => {
                                players.forEach(p => {
                                    if (p.id !== this.id && p.stocks > 0) {
                                        const dist = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
                                        if (dist < 120) {
                                            p.burning = true;
                                            p.burnTimer = 150;
                                            p.burnOwner = this.id;
                                        }
                                    }
                                });
                            }, 300);
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "MAXTAC MANTIS", life: 30, vy: -2, color: '#ff4400' });
                            return;
                        }
                        // MAINE'S ARM (Arm slot): Gorilla Arm smash
                        if (arm === 'maine_arm') {
                            this.vx = (this.dir ? 1 : -1) * 12;
                            this.cd = 50;
                            sfx.play('hit');
                            // Single massive gorilla arm punch
                            this.box = { relX: this.dir ? 15 : -50, relY: -5, w: 60, h: 50, act: true, own: this.id, kbx: (this.dir ? 15 : -15), kby: -8, dmg: 18, f: 8 };
                            particles.push({ x: this.x + (this.dir ? 50 : -20), y: this.y + this.h / 2, text: "💪", life: 20, vy: -1, color: '#f80' });
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "GORILLA ARM", life: 30, vy: -2, color: '#ff8800' });
                            // Ground pound shockwave if on ground
                            if (this.grounded) {
                                setTimeout(() => {
                                    this.box = { relX: -60, relY: 0, w: 140, h: 30, act: true, own: this.id, kbx: 0, kby: -12, dmg: 10, f: 6 };
                                    sfx.play('break');
                                    for (let i = 0; i < 8; i++) {
                                        particles.push({ x: this.x + (Math.random()-0.5)*120, y: this.y + this.h, vx: (Math.random()-0.5)*8, vy: -Math.random()*5, life: 20, color: '#f80', size: 4 });
                                    }
                                }, 150);
                            }
                            return;
                        }
                        // MANTIS BLADES MK2 (Arm slot): 5-Hit Dash + Bleed DOT
                        if (arm === 'mantis_blades_mk2') {
                            this.vx = (this.dir ? 1 : -1) * 18;
                            this.cd = 42;
                            sfx.play('hit');
                            const selfRef = this;
                            // MK2: 5-hit slash combo
                            for (let slash = 0; slash < 5; slash++) {
                                setTimeout(() => {
                                    if (selfRef.stocks <= 0) return;
                                    selfRef.box = { relX: selfRef.dir ? 10 : -45, relY: -12, w: 55, h: 42, act: true, own: selfRef.id, kbx: (selfRef.dir ? 9 : -9), kby: -3, dmg: 7, f: 4 };
                                    sfx.play('hit');
                                    particles.push({ x: selfRef.x + (selfRef.dir ? 45 : -12), y: selfRef.y + selfRef.h / 2, text: "✂️", life: 10, vy: -1, color: '#ff0044' });
                                }, slash * 70);
                            }
                            // MK2: Apply bleed DOT to nearby enemies after combo
                            setTimeout(() => {
                                players.forEach(p => {
                                    if (p.id !== selfRef.id && p.stocks > 0) {
                                        const dist = Math.abs(p.x - selfRef.x) + Math.abs(p.y - selfRef.y);
                                        if (dist < 130) {
                                            p.bleeding = true;
                                            p.bleedTimer = 180; // 3 seconds of bleed
                                            p.bleedOwner = selfRef.id;
                                            particles.push({ x: p.x + p.w/2, y: p.y, text: "🩸 BLEED", life: 40, vy: -1, color: '#ff0044' });
                                        }
                                    }
                                });
                            }, 350);
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "MANTIS MK2", life: 30, vy: -2, color: '#ff0044' });
                            return;
                        }
                        // MANTIS BLADES (Arm slot): Dash slash combo
                        if (arm === 'mantis_blades') {
                            this.vx = (this.dir ? 1 : -1) * 15;
                            this.cd = 40;
                            sfx.play('hit');
                            // Multi-hit slash
                            for (let slash = 0; slash < 3; slash++) {
                                setTimeout(() => {
                                    if (this.stocks <= 0) return;
                                    this.box = { relX: this.dir ? 10 : -40, relY: -10, w: 50, h: 40, act: true, own: this.id, kbx: (this.dir ? 8 : -8), kby: -3, dmg: 6, f: 5 };
                                    sfx.play('hit');
                                    particles.push({ x: this.x + (this.dir ? 40 : -10), y: this.y + this.h / 2, text: "✂️", life: 10, vy: -1, color: '#f00' });
                                }, slash * 80);
                            }
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "MANTIS BLADES", life: 30, vy: -2, color: '#f00' });
                            return;
                        }
                        // MONOWIRE (Arm slot): Long-range whip slash
                        if (arm === 'monowire') {
                            sfx.play('hit');
                            // Charge bonus: more damage if idle for a while
                            const chargeBonus = this.monowireCharge || 0;
                            const baseDmg = 8 + Math.min(chargeBonus, 12); // Up to 20 total damage
                            this.monowireCharge = 0; // Reset charge after use
                            this.vx = (this.dir ? 1 : -1) * 5;
                            this.cd = 30;
                            // Long range hitbox
                            this.box = { relX: this.dir ? 5 : -80, relY: -15, w: 85, h: 50, act: true, own: this.id, kbx: (this.dir ? 12 : -12), kby: -5, dmg: baseDmg, f: 6 };
                            // Whip VFX trail
                            for (let i = 0; i < 6; i++) {
                                const wx = this.x + (this.dir ? 20 + i*12 : -i*12);
                                particles.push({ x: wx, y: this.y + this.h/2 + (Math.random()-0.5)*10, vx: this.dir ? 3 : -3, vy: 0, life: 12, color: '#ff00ff', size: 2 });
                            }
                            particles.push({ x: this.x + this.w/2, y: this.y, text: chargeBonus > 5 ? "CHARGED MONO" : "MONOWIRE", life: 25, vy: -2, color: '#f0f' });
                            return;
                        }
                        // PROJECTILE LAUNCH SYSTEM (Arm slot): Missile
                        if (arm === 'projectile_launch') {
                            sfx.play('ult');
                            this.cd = 55;
                            const missileDir = this.dir ? 1 : -1;
                            ultEffects.push({
                                t: 'missile',
                                owner: this.id,
                                x: this.x + (this.dir ? this.w + 5 : -15),
                                y: this.y + this.h / 2 - 5,
                                vx: missileDir * 10,
                                vy: 0,
                                l: 80,
                                dmg: 15
                            });
                            // Launch smoke
                            for (let i = 0; i < 5; i++) {
                                particles.push({ x: this.x + (this.dir ? this.w : 0), y: this.y + this.h/2, vx: -missileDir * Math.random()*3, vy: (Math.random()-0.5)*3, life: 15, color: '#888', size: 3 });
                            }
                            particles.push({ x: this.x + this.w/2, y: this.y, text: "🚀 LAUNCH", life: 25, vy: -2, color: '#f80' });
                            return;
                        }
                        // GORILLA ARMS (Arm slot): Charged punch
                        if (arm === 'gorilla_arms') {
                            this.vx = (this.dir ? 1 : -1) * 10;
                            this.cd = 35;
                            sfx.play('hit');
                            this.box = { relX: this.dir ? 12 : -42, relY: -5, w: 50, h: 40, act: true, own: this.id, kbx: (this.dir ? 12 : -12), kby: -6, dmg: 14, f: 6 };
                            particles.push({ x: this.x + (this.dir ? 45 : -15), y: this.y + this.h/2, text: "💪", life: 15, vy: -1, color: '#f80' });
                            particles.push({ x: this.x + this.w/2, y: this.y, text: "GORILLA ARMS", life: 25, vy: -2, color: '#f80' });
                            return;
                        }
                        // Fallback side attack
                        this.vx = (this.dir ? 1 : -1) * 2;
                        this.box = { relX: this.dir ? 20 : -30, relY: 0, w: 30, h: 30, act: true, own: this.id, kbx: 2, kby: -2, dmg: 1, f: 2 };
                        return;
                    }

                    // UP SPECIAL
                    if (u) {
                        // Lucy's Cyberdeck Up Special: Breach Protocol (AoE stun + damage)
                        if (core === 'lucy_cyberdeck') {
                            this.vy = -12;
                            sfx.play('ult');
                            // Breach Protocol: stun + damage all nearby enemies
                            players.forEach(p => {
                                if (p.id !== this.id && p.stocks > 0) {
                                    const dist = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
                                    if (dist < 300) {
                                        p.hit(0, -3, 12);
                                        p.stun = 80;
                                        particles.push({ x: p.x + p.w/2, y: p.y, text: "⚡ BREACH", life: 40, vy: -1, color: '#0ff' });
                                        for (let i = 0; i < 6; i++) {
                                            particles.push({ x: p.x + (Math.random()-0.5)*30, y: p.y + (Math.random()-0.5)*30, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 15, color: '#f0f', size: 3 });
                                        }
                                    }
                                }
                            });
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "BREACH PROTOCOL", life: 50, vy: -2, color: '#f0f' });
                            this.cd = 120;
                            return;
                        }
                        // Cyberdeck MK2 Up Special - Enhanced fire blast + lingering damage
                        if (core === 'cyberdeck_militech_mk2') {
                            this.vy = -12;
                            // Double fire blast
                            ultEffects.push({
                                t: 'fire',
                                owner: this.id,
                                x: this.x - 20,
                                y: this.y,
                                vx: 0,
                                vy: 0,
                                l: 80
                            });
                            ultEffects.push({
                                t: 'fire',
                                owner: this.id,
                                x: this.x + 20,
                                y: this.y,
                                vx: 0,
                                vy: 0,
                                l: 80
                            });
                            sfx.play('ult');
                            particles.push({ x: this.x + this.w / 2, y: this.y, text: "MK2 OVERLOAD", life: 40, vy: -2, color: '#ff0' });
                            this.cd = 80;
                            return;
                        }
                        // Cyberdeck Up Special still works
                        if (core === 'cyberdeck_militech') {
                            this.vy = -10;
                            ultEffects.push({
                                t: 'fire',
                                owner: this.id,
                                x: this.x,
                                y: this.y,
                                vx: 0,
                                vy: 0,
                                l: 60
                            });
                            sfx.play('ult');
                            this.cd = 90;
                            return;
                        }
                        // Fallback up attack
                        // LEGS CYBERWARE modifies up special
                        if (legs === 'reinforced_tendons') {
                            // Double Jump — enhanced recovery
                            this.vy = -10;
                            if (!this.doubleJumped) {
                                this.doubleJumped = true;
                                particles.push({ x: this.x + this.w/2, y: this.y + this.h, text: "⬆️", life: 10, vy: 1, color: '#0cf' });
                            }
                            this.box = { relX: -10, relY: -20, w: 40, h: 30, act: true, own: this.id, kbx: 0, kby: -8, dmg: 5, f: 3 };
                            return;
                        }
                        if (legs === 'fortified_ankles') {
                            // Charge Jump — super high launch
                            this.vy = -15;
                            sfx.play('ult');
                            particles.push({ x: this.x + this.w/2, y: this.y + this.h, text: "🦿 CHARGE", life: 20, vy: 2, color: '#0f0' });
                            // Stomp shockwave under you
                            if (this.grounded) {
                                this.box = { relX: -30, relY: 10, w: 80, h: 20, act: true, own: this.id, kbx: 0, kby: -10, dmg: 8, f: 5 };
                                for (let i = 0; i < 5; i++) {
                                    particles.push({ x: this.x + (Math.random()-0.5)*60, y: this.y + this.h, vx: (Math.random()-0.5)*6, vy: -Math.random()*2, life: 12, color: '#0f0', size: 3 });
                                }
                            }
                            return;
                        }
                        if (legs === 'lynx_paws') {
                            // Lynx Paws — quick agile recovery
                            this.vy = -9;
                            this.vx = (this.dir ? 1 : -1) * 5; // Angular recovery
                            this.box = { relX: -10, relY: -20, w: 40, h: 30, act: true, own: this.id, kbx: 0, kby: -6, dmg: 4, f: 3 };
                            return;
                        }
                        this.vy = -8;
                        this.box = { relX: -10, relY: -20, w: 40, h: 30, act: true, own: this.id, kbx: 0, kby: -8, dmg: 5, f: 3 };
                        return;
                    }

                    // NEUTRAL M1 ATTACK (no direction held) - uses 'arm' declared above
                    if (arm === 'mantis_blades_mk2') {
                        // MK2 mantis: faster + stronger neutral slash
                        this.box = { relX: this.dir ? 10 : -38, relY: -8, w: 48, h: 38, act: true, own: this.id, kbx: (this.dir ? 7 : -7), kby: -3, dmg: 10, f: 4 };
                        particles.push({ x: this.x + (this.dir ? 42 : -12), y: this.y + this.h / 2, text: "✂️", life: 8, vy: -1, color: '#ff0044' });
                        this.cd = 10;
                    } else if (arm === 'mantis_blades' || arm === 'maxtac_mantis') {
                        // Quick mantis slash
                        this.box = { relX: this.dir ? 10 : -35, relY: -5, w: 45, h: 35, act: true, own: this.id, kbx: (this.dir ? 6 : -6), kby: -3, dmg: 8, f: 4 };
                        particles.push({ x: this.x + (this.dir ? 40 : -10), y: this.y + this.h / 2, text: "✂️", life: 8, vy: -1, color: arm === 'maxtac_mantis' ? '#ff4400' : '#f00' });
                        this.cd = 12;
                    } else if (arm === 'maine_arm') {
                        // Quick gorilla jab
                        this.box = { relX: this.dir ? 10 : -35, relY: -5, w: 45, h: 35, act: true, own: this.id, kbx: (this.dir ? 5 : -5), kby: -2, dmg: 10, f: 5 };
                        particles.push({ x: this.x + (this.dir ? 40 : -10), y: this.y + this.h / 2, text: "💪", life: 8, vy: -1, color: '#f80' });
                        this.cd = 15;
                    } else if (arm === 'gorilla_arms') {
                        this.box = { relX: this.dir ? 10 : -35, relY: -5, w: 45, h: 35, act: true, own: this.id, kbx: (this.dir ? 5 : -5), kby: -2, dmg: 9, f: 5 };
                        this.cd = 15;
                    } else if (arm === 'monowire') {
                        // Quick whip flick
                        this.box = { relX: this.dir ? 5 : -55, relY: -5, w: 60, h: 30, act: true, own: this.id, kbx: (this.dir ? 5 : -5), kby: -2, dmg: 6, f: 4 };
                        particles.push({ x: this.x + (this.dir ? 50 : -20), y: this.y + this.h/2, vx: this.dir ? 2 : -2, vy: 0, life: 8, color: '#f0f', size: 2 });
                        this.cd = 14;
                    } else if (arm === 'projectile_launch') {
                        // Arm punch (save rockets for side special)
                        this.box = { relX: this.dir ? 10 : -30, relY: -5, w: 40, h: 30, act: true, own: this.id, kbx: (this.dir ? 5 : -5), kby: -2, dmg: 8, f: 4 };
                        this.cd = 14;
                    } else {
                        // Default punch
                        this.box = { relX: this.dir ? 10 : -30, relY: -5, w: 40, h: 30, act: true, own: this.id, kbx: (this.dir ? 4 : -4), kby: -2, dmg: 6, f: 4 };
                        this.cd = 15;
                    }
                    return;
                }
                if (s.id === '67kid') {
                    if (u) {
                        this.pct += 67;
                        this.stun = 60;
                        return;
                    }
                    if (d) {
                        this.vy = -20;
                        setTimeout(() => this.vy = 25, 200);
                        this.box = {
                            relX: -40,
                            relY: 20,
                            w: 130,
                            h: 40,
                            act: !0,
                            own: this.id,
                            kbx: 12 * s.power,
                            kby: 15 * s.power,
                            dmg: 10 * s.power,
                            f: 8
                        };
                        return;
                    }
                } else if (s.id === 'amogus') {
                    if (l || r) {
                        this.x += (this.dir ? 100 : -100);
                        return;
                    }
                    if (u) {
                        this.vy = -20;
                        ultEffects.push({
                            t: 'tear',
                            x: this.x,
                            y: this.y + 20,
                            l: 10
                        });
                        return;
                    }
                } else if (s.id === 'gps') {
                    if (d) {
                        let t = players.find(p => p.id !== this.id);
                        if (t) t.confused = 300;
                        sfx.play('break');
                        return;
                    }
                    if (u) {
                        this.y -= 200;
                        this.vy = 0;
                        return;
                    }
                    if (l || r) {
                        this.x += (this.dir ? 150 : -150);
                        this.box = {
                            relX: -20,
                            relY: 0,
                            w: 40,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 10,
                            kby: -10,
                            dmg: 5,
                            f: 10
                        };
                        return;
                    }
                } else if (s.id === 'sahur') {
                    if (d) {
                        this.vy = 10;
                        this.box = {
                            relX: -75,
                            relY: 20,
                            w: 200,
                            h: 40,
                            act: !0,
                            own: this.id,
                            kbx: 15 * s.power,
                            kby: -15 * s.power,
                            dmg: 20 * s.power,
                            f: 10
                        };
                        sfx.play('break');
                        this.cd = 60;
                        return;
                    }
                    if (u) {
                        this.vy = -10 * s.jump;
                        this.box = {
                            relX: -25,
                            relY: 50,
                            w: 100,
                            h: 40,
                            act: !0,
                            own: this.id,
                            kbx: 5 * s.power,
                            kby: 20 * s.power,
                            dmg: 12 * s.power,
                            f: 5
                        };
                        sfx.play('hit');
                        return;
                    }
                    if (l || r) {
                        this.vx = (this.dir ? 1 : -1) * 10;
                        this.box = {
                            relX: this.dir ? 40 : -90,
                            relY: -10,
                            w: 50,
                            h: 70,
                            act: !0,
                            own: this.id,
                            kbx: 20 * s.power,
                            kby: -10 * s.power,
                            dmg: 15 * s.power,
                            f: 8
                        };
                        this.cd = 45;
                        return;
                    }
                } else if (s.id === 'primo') {
                    if (d) {
                        this.box = {
                            relX: this.dir ? 0 : -100,
                            relY: 0,
                            w: 100,
                            h: 60,
                            act: !0,
                            own: this.id,
                            kbx: 12 * s.power,
                            kby: -10 * s.power,
                            dmg: 14 * s.power,
                            f: 10
                        };
                        this.cd = 40;
                        return;
                    }
                    if (u) {
                        this.vy = -12;
                        this.vx = (this.dir ? 1 : -1) * 8;
                        this.box = {
                            relX: -25,
                            relY: 0,
                            w: 100,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 10 * s.power,
                            kby: -15 * s.power,
                            dmg: 12 * s.power,
                            f: 15
                        };
                        this.cd = 50;
                        return;
                    }
                    if (l || r) {
                        this.vx = (this.dir ? 1 : -1) * 15;
                        this.box = {
                            relX: this.dir ? 40 : -80,
                            relY: 0,
                            w: 40,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 18 * s.power,
                            kby: -8 * s.power,
                            dmg: 12 * s.power,
                            f: 8
                        };
                        this.cd = 40;
                        return;
                    }
                } else if (s.id === 'ocralito') {
                    if (d) {
                        this.box = {
                            relX: -50,
                            relY: 40,
                            w: 150,
                            h: 20,
                            act: !0,
                            own: this.id,
                            kbx: 10 * s.power,
                            kby: -10 * s.power,
                            dmg: 14 * s.power,
                            f: 5
                        };
                        this.vy = 10;
                        this.cd = 40;
                        return;
                    }
                    if (u) {
                        this.vy = -15 * s.jump;
                        this.box = {
                            relX: -25,
                            relY: -20,
                            w: 100,
                            h: 40,
                            act: !0,
                            own: this.id,
                            kbx: 5 * s.power,
                            kby: -15 * s.power,
                            dmg: 10 * s.power,
                            f: 8
                        };
                        this.cd = 45;
                        return;
                    }
                    if (l || r) {
                        this.vx = (this.dir ? 1 : -1) * 12;
                        this.box = {
                            relX: this.dir ? 40 : -70,
                            relY: 20,
                            w: 30,
                            h: 30,
                            act: !0,
                            own: this.id,
                            kbx: 15 * s.power,
                            kby: -5 * s.power,
                            dmg: 8 * s.power,
                            f: 12
                        };
                        this.friction = 0.98;
                        this.cd = 50;
                        return;
                    }
                } else if (s.id === 'mechabara') {
                    if (d) {
                        this.box = {
                            relX: -25,
                            relY: 50,
                            w: 100,
                            h: 20,
                            act: !0,
                            own: this.id,
                            kbx: 10 * s.power,
                            kby: 15 * s.power,
                            dmg: 16 * s.power,
                            f: 5
                        };
                        this.vy = 5;
                        this.cd = 45;
                        return;
                    }
                    if (u) {
                        this.vy = -18 * s.jump;
                        this.box = {
                            relX: -25,
                            relY: 0,
                            w: 100,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 5 * s.power,
                            kby: -15 * s.power,
                            dmg: 10 * s.power,
                            f: 12
                        };
                        this.cd = 50;
                        return;
                    }
                    if (l || r) {
                        this.vx = (this.dir ? 1 : -1) * 10;
                        this.box = {
                            relX: this.dir ? 40 : -80,
                            relY: 0,
                            w: 40,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 16 * s.power,
                            kby: -5 * s.power,
                            dmg: 7 * s.power,
                            f: 15
                        };
                        this.cd = 50;
                        return;
                    }
                } else if (s.id === 'bluedude') {
                    if (d) {
                        this.isParrying = !0;
                        this.parryTimer = 15;
                        this.cd = 30;
                        return;
                    }
                    if (u) {
                        this.setAnimation("attack_up");
                        this.vy = -16 * s.jump;
                        this.box = {
                            relX: -25,
                            relY: -50,
                            w: 100,
                            h: 100,
                            act: !0,
                            own: this.id,
                            kbx: 8 * s.power,
                            kby: -18 * s.power,
                            dmg: 12 * s.power,
                            f: 8
                        };
                        this.cd = 50;
                        return;
                    }
                    if (l || r) {
                        this.setAnimation("attack_side");
                        this.vx = (this.dir ? 1 : -1) * 12;
                        this.box = {
                            relX: this.dir ? 50 : -90,
                            relY: 10,
                            w: 40,
                            h: 30,
                            act: !0,
                            own: this.id,
                            kbx: 14 * s.power,
                            kby: -5 * s.power,
                            dmg: 9 * s.power,
                            f: 6
                        };
                        this.cd = 40;
                        return;
                    }
                } else if (s.id === 'johnpork') {
                    let t = players.find(p => p.id !== this.id);
                    if (d) {
                        if (t) t.hit(0, 0, 10);
                        showNotification("CALL DECLINED", "Dealt 10 damage");
                        this.cd = 60;
                        return;
                    }
                    if (u) {
                        const boosts = ['speed', 'power', 'jump'];
                        const boost = boosts[Math.floor(Math.random() * boosts.length)];
                        if (boost === 'speed') this.stats.speed *= 1.5;
                        if (boost === 'power') this.stats.power *= 1.5;
                        if (boost === 'jump') this.stats.jump *= 1.5;
                        showNotification("CALL ACCEPTED", `+${boost.toUpperCase()} for 5s`);
                        setTimeout(() => {
                            if (boost === 'speed') this.stats.speed /= 1.5;
                            if (boost === 'power') this.stats.power /= 1.5;
                            if (boost === 'jump') this.stats.jump /= 1.5;
                        }, 5000);
                        this.cd = 120;
                        return;
                    }
                    if (l || r) {
                        if (t) t.stun = 120;
                        showNotification("RING RING", "Enemy Stunned!");
                        this.cd = 180;
                        return;
                    }
                } else if (s.id === 'luckyblock') {
                    // Mastery Lucky Block: buffed moves + replaced down move (Jackpot)
                    if (l || r) {
                        if (Math.random() < 0.5) {
                            let t = players.find(p => p.id !== this.id);
                            if (t) {
                                for (let i = 0; i < 5; i++) {
                                    setTimeout(() => {
                                        if (t && t.stocks > 0) {
                                            let kbm = (this.masteryActive ? 1.2 : 1);
                                            let dmgm = (this.masteryActive ? 1.2 : 1);
                                            t.hit((this.dir ? 1 : -1) * 8 * kbm, -5 * kbm, 100 * dmgm);
                                        }
                                    }, i * 100);
                                }
                                sfx.play('ult');
                            }
                        } else {
                            sfx.play('break');
                        }
                        this.cd = this.masteryActive ? 50 : 60;
                        return;
                    }
                    if (u) {
                        let t = players.find(p => p.id !== this.id);
                        if (t) {
                            let coin = new Item('coin');
                            coin.x = this.x;
                            coin.y = this.y - 30;
                            items.push(coin);
                            setTimeout(() => {
                                if (t && t.stocks > 0) {
                                    let kbm = (this.masteryActive ? 1.2 : 1);
                                    let dmgm = (this.masteryActive ? 1.5 : 1);
                                    t.hit((this.x < t.x ? 1 : -1) * 5 * kbm, -8 * kbm, 10 * dmgm);
                                }
                            }, 300);
                        }
                        this.cd = this.masteryActive ? 40 : 50;
                        return;
                    }
                    if (d) {
                        if (this.masteryActive) {
                            // Replaced move: Jackpot Block
                            // Large sweeping hitbox with big knockback and a chance for a bonus effect
                            this.playAnimation("attack_down", 16);
                            this.box = {
                                relX: -60,
                                relY: -30,
                                w: 170,
                                h: 80,
                                act: !0,
                                own: this.id,
                                kbx: 22 * s.power,
                                kby: -25 * s.power,
                                dmg: 30 * s.power,
                                f: 10
                            };
                            // 30% chance to rain an extra coin hit shortly after
                            if (Math.random() < 0.3) {
                                setTimeout(() => {
                                    let t = players.find(p => p.id !== this.id);
                                    if (t && t.stocks > 0) {
                                        t.hit((this.x < t.x ? 1 : -1) * 6, -10, 12);
                                    }
                                    let coin = new Item('coin');
                                    coin.x = this.x + (this.dir ? 40 : -40);
                                    coin.y = this.y - 40;
                                    items.push(coin);
                                }, 200);
                            }
                            this.cd = 70;
                        } else {
                            this.vy = -15;
                            this.cd = 80;
                            this.luckyBlockCrush = true;
                        }
                        return;
                    }
                } else if (s.id === 'brokeboy') {
                    if (l || r) {
                        // Side attack: beg/boost chance; play side animation briefly
                        this.playAnimation("attack_side", 18);
                        if (Math.random() < 0.1) {
                            const boosts = ['speed', 'power', 'regen', 'knockback'];
                            const boost = boosts[Math.floor(Math.random() * boosts.length)];
                            if (boost === 'speed') {
                                this.stats = { ...this.stats, speed: this.stats.speed * 1.3 };
                                setTimeout(() => {
                                    this.stats = { ...this.stats, speed: this.stats.speed / 1.3 };
                                }, 10000);
                            } else if (boost === 'power') {
                                this.stats = { ...this.stats, power: this.stats.power * 1.3 };
                                setTimeout(() => {
                                    this.stats = { ...this.stats, power: this.stats.power / 1.3 };
                                }, 10000);
                            } else if (boost === 'regen') {
                                this.alpha = 1;
                                this.inv = 600;
                            } else if (boost === 'knockback') {
                                this.weight *= 1.5;
                                setTimeout(() => {
                                    this.weight /= 1.5;
                                }, 10000);
                            }
                            sfx.play('ult');
                        } else {
                            sfx.play('break');
                        }
                        this.cd = 60;
                        return;
                    }
                    if (u) {
                        // Up attack: use custom up-attack animation and lock for a bit
                        this.playAnimation("attack_up", 20);
                        if (Math.random() < 0.1) {
                            let t = players.find(p => p.id !== this.id);
                            if (t) {
                                t.stats = { ...t.stats, speed: t.stats.speed * 1.2, power: t.stats.power * 1.2 };
                                t.stun = 120;
                                t.hit(0, -5, 10);
                                setTimeout(() => {
                                    if (t) {
                                        t.stats = { ...t.stats, speed: t.stats.speed / 1.2, power: t.stats.power / 1.2 };
                                    }
                                }, 2000);
                                sfx.play('ult');
                            }
                        } else {
                            sfx.play('break');
                        }
                        this.cd = 50;
                        return;
                    }
                    if (d) {
                        if (Math.random() < 0.5) {
                            // Down special: Broken Sword parry uses shield animation
                            this.setAnimation("shield");
                            this.isParrying = !0;
                            this.parryTimer = 20;
                            this.cd = 30;
                            sfx.play('shield');
                        } else {
                            sfx.play('break');
                            this.cd = 40;
                        }
                        return;
                    }
                } else if (s.id === 'glitch') {
                    if (l || r) {
                        // Pixel Shift: 70% normal dash, 30% opposite direction
                        if (Math.random() < 0.7) {
                            this.vx = (this.dir ? 1 : -1) * 12;
                            this.box = {
                                relX: this.dir ? 40 : -80,
                                relY: 0,
                                w: 40,
                                h: 50,
                                act: !0,
                                own: this.id,
                                kbx: 10 * s.power,
                                kby: -8 * s.power,
                                dmg: 10 * s.power,
                                f: 8
                            };
                        } else {
                            // Glitch: dash opposite direction
                            this.vx = (this.dir ? -1 : 1) * 12;
                            this.box = {
                                relX: this.dir ? -80 : 40,
                                relY: 0,
                                w: 40,
                                h: 50,
                                act: !0,
                                own: this.id,
                                kbx: 15 * s.power,
                                kby: -10 * s.power,
                                dmg: 20 * s.power,
                                f: 8
                            };
                            sfx.play('ult');
                        }
                        this.cd = 40;
                        return;
                    }
                    if (u) {
                        // Data Corruption: Random teleport + 10% position swap
                        let oldX = this.x;
                        let oldY = this.y;
                        this.y -= 150 + Math.random() * 100;
                        this.vy = 0;
                        this.box = {
                            relX: -40,
                            relY: oldY - this.y,
                            w: 80,
                            h: 60,
                            act: !0,
                            own: this.id,
                            kbx: 8 * s.power,
                            kby: -12 * s.power,
                            dmg: 12 * s.power,
                            f: 10
                        };
                        if (Math.random() < 0.1) {
                            let t = players.find(p => p.id !== this.id);
                            if (t) {
                                let tx = t.x;
                                let ty = t.y;
                                t.x = oldX;
                                t.y = oldY;
                                this.x = tx;
                                this.y = ty;
                                sfx.play('ult');
                            }
                        }
                        this.cd = 50;
                        return;
                    }
                    if (d) {
                        // Reality Break: 50% stun opponent 60f OR stun self 30f
                        if (Math.random() < 0.5) {
                            let t = players.find(p => p.id !== this.id);
                            if (t) {
                                t.stun = 60;
                                t.hit(0, -8, 15);
                                sfx.play('hit');
                            }
                        } else {
                            this.stun = 30;
                            sfx.play('break');
                        }
                        this.cd = 60;
                        return;
                    }
                } else if (s.id === 'jack') {
                    if (l || r) {
                        // Master Of None: Rush attack + stat comparison buff + projectile
                        let t = players.find(p => p.id !== this.id);
                        this.vx = (this.dir ? 1 : -1) * 15;
                        this.box = {
                            relX: this.dir ? 40 : -80,
                            relY: 0,
                            w: 60,
                            h: 50,
                            act: !0,
                            own: this.id,
                            kbx: 12 * s.power,
                            kby: -8 * s.power,
                            dmg: 15 * s.power,
                            f: 10
                        };
                        // Get 0.5 better stats than opponent temporarily
                        if (t && !this.jackStatBoost) {
                            this.jackStatBoost = true;
                            const oldSpeed = this.stats.speed;
                            const oldPower = this.stats.power;
                            const oldJump = this.stats.jump;
                            this.stats.speed = Math.max(this.stats.speed, t.stats.speed + 0.5);
                            this.stats.power = Math.max(this.stats.power, t.stats.power + 0.5);
                            this.stats.jump = Math.max(this.stats.jump, t.stats.jump + 0.5);
                            setTimeout(() => {
                                if (this.stats) {
                                    this.stats.speed = oldSpeed;
                                    this.stats.power = oldPower;
                                    this.stats.jump = oldJump;
                                    this.jackStatBoost = false;
                                }
                            }, 180);
                        }
                        // Throw projectile
                        setTimeout(() => {
                            ultEffects.push({
                                t: 'tear',
                                x: this.x + (this.dir ? 30 : -30),
                                y: this.y,
                                l: 30
                            });
                        }, 100);
                        this.cd = 60;
                        return;
                    }
                    if (d) {
                        // Parry Combo: Hybrid of BlueDude and BrokeBoy parry with 50% buff chance
                        this.isParrying = !0;
                        this.parryTimer = 15;
                        this.jackParryBonus = Math.random() < 0.5; // 50% chance for buff
                        if (this.jackParryBonus) {
                            // Visual feedback for bonus
                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: this.x + this.w / 2,
                                    y: this.y + this.h / 2,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    size: 6,
                                    life: 30,
                                    color: '#FFD700'
                                });
                            }
                        }
                        this.cd = 35;
                        return;
                    }
                    if (u) {
                        // Rising Mastery: Stat buff + low damage attack
                        this.vy = -18 * s.jump;
                        this.box = {
                            relX: -30,
                            relY: -20,
                            w: 60,
                            h: 70,
                            act: !0,
                            own: this.id,
                            kbx: 3 * s.power,
                            kby: -5 * s.power,
                            dmg: 5 * s.power,
                            f: 12
                        };
                        // Temporary stat boost
                        if (!this.jackRisingBoost) {
                            this.jackRisingBoost = true;
                            const oldStats = { speed: this.stats.speed, power: this.stats.power, jump: this.stats.jump };
                            this.stats.speed += 0.3;
                            this.stats.power += 0.3;
                            this.stats.jump += 0.3;
                            setTimeout(() => {
                                if (this.stats) {
                                    this.stats.speed = oldStats.speed;
                                    this.stats.power = oldStats.power;
                                    this.stats.jump = oldStats.jump;
                                    this.jackRisingBoost = false;
                                }
                            }, 240);
                        }
                        this.cd = 50;
                        return;
                    }
                }
                // ====== NYAN CAT ======
                if (s.id === 'nyancat') {
                    if (l || r) {
                        // Rainbow Dash: Fast horizontal charge leaving rainbow trail
                        this.vx = (this.dir ? 1 : -1) * 20;
                        this.box = {
                            relX: this.dir ? 30 : -80, relY: -10, w: 60, h: 40,
                            act: !0, own: this.id,
                            kbx: 18 * s.power, kby: -6 * s.power, dmg: 11 * s.power, f: 8
                        };
                        // Leave rainbow trail
                        const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#8B00FF'];
                        for (let i = 0; i < 6; i++) {
                            particles.push({
                                x: this.x + this.w/2, y: this.y + 5 + i * 7,
                                vx: (this.dir ? -1 : 1) * (3 + Math.random() * 2), vy: 0,
                                life: 30, color: colors[i], size: 5
                            });
                        }
                        this.cd = 25;
                        return;
                    }
                    if (u) {
                        // Pop-Tart Launch: Fly up with sparkles
                        this.vy = -16;
                        this.vx = (this.dir ? 1 : -1) * 4;
                        this.box = {
                            relX: -20, relY: -40, w: 70, h: 50,
                            act: !0, own: this.id,
                            kbx: 4 * s.power, kby: -18 * s.power, dmg: 9 * s.power, f: 6
                        };
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: this.x + this.w/2 + (Math.random()-0.5)*20, y: this.y + this.h,
                                vx: (Math.random()-0.5)*4, vy: Math.random()*4+2,
                                life: 20, color: ['#ff0','#f0f','#0ff','#f90'][i%4], size: 3
                            });
                        }
                        this.cd = 35;
                        return;
                    }
                    if (d) {
                        // Bass Drop: Ground slam with shockwave
                        this.vy = 15;
                        this.box = {
                            relX: -50, relY: 20, w: 150, h: 30,
                            act: !0, own: this.id,
                            kbx: 8 * s.power, kby: -14 * s.power, dmg: 14 * s.power, f: 10
                        };
                        // Musical note particles
                        for (let i = 0; i < 6; i++) {
                            particles.push({
                                x: this.x + this.w/2 + (Math.random()-0.5)*60, y: this.y + this.h,
                                vx: (Math.random()-0.5)*6, vy: -Math.random()*5-2,
                                life: 25, text: ['🎵','🎶','🎵'][i%3], color: '#ff69b4'
                            });
                        }
                        this.cd = 40;
                        return;
                    }
                    // Neutral: Quick paw swipe with rainbow spark
                    this.box = {
                        relX: this.dir ? 30 : -60, relY: -5, w: 45, h: 40,
                        act: !0, own: this.id,
                        kbx: 8 * s.power, kby: -6 * s.power, dmg: 7 * s.power, f: 4
                    };
                    particles.push({
                        x: this.x + (this.dir ? 50 : -20), y: this.y + 15,
                        vx: (this.dir ? 1 : -1) * 3, vy: 0,
                        life: 10, color: '#ff69b4', size: 4
                    });
                    this.cd = 12;
                    return;
                }
                // ====== SHREK ======
                if (s.id === 'shrek') {
                    if (l || r) {
                        // Ogre Slam: Heavy forward charge, massive knockback
                        this.vx = (this.dir ? 1 : -1) * 10;
                        this.box = {
                            relX: this.dir ? 20 : -80, relY: -10, w: 70, h: 60,
                            act: !0, own: this.id,
                            kbx: 25 * s.power, kby: -8 * s.power, dmg: 16 * s.power, f: 12
                        };
                        // Ground crack effect
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: this.x + (this.dir ? 40 : -20) + (Math.random()-0.5)*30, y: this.y + this.h,
                                vx: (Math.random()-0.5)*4, vy: -Math.random()*3,
                                life: 15, color: '#5a3a1a', size: 4
                            });
                        }
                        this.cd = 40;
                        return;
                    }
                    if (u) {
                        // Swamp Geyser: Launch upward on swamp blast
                        this.vy = -14;
                        this.box = {
                            relX: -30, relY: -40, w: 80, h: 70,
                            act: !0, own: this.id,
                            kbx: 5 * s.power, kby: -20 * s.power, dmg: 12 * s.power, f: 8
                        };
                        // Swamp splash
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: this.x + this.w/2, y: this.y + this.h,
                                vx: (Math.random()-0.5)*8, vy: Math.random()*5+3,
                                life: 20, color: ['#2d5a1e','#4a8c2a','#3b7a24'][i%3], size: 5
                            });
                        }
                        this.cd = 45;
                        return;
                    }
                    if (d) {
                        // Onion Layers: Counter shield — if hit during this, reflect with big damage
                        this.isParrying = !0;
                        this.parryTimer = 20;
                        // Swamp aura
                        for (let i = 0; i < 10; i++) {
                            const angle = (i / 10) * Math.PI * 2;
                            particles.push({
                                x: this.x + this.w/2 + Math.cos(angle)*25, y: this.y + this.h/2 + Math.sin(angle)*25,
                                vx: Math.cos(angle)*2, vy: Math.sin(angle)*2,
                                life: 20, color: '#4a8c2a', size: 6
                            });
                        }
                        this.cd = 50;
                        return;
                    }
                    // Neutral: Heavy swamp fist
                    this.box = {
                        relX: this.dir ? 20 : -60, relY: -5, w: 55, h: 50,
                        act: !0, own: this.id,
                        kbx: 14 * s.power, kby: -8 * s.power, dmg: 12 * s.power, f: 6
                    };
                    this.cd = 20;
                    return;
                }
                // ====== RICK ASTLEY ======
                if (s.id === 'rickastley') {
                    if (l || r) {
                        // Never Gonna Run Around: Dance dash forward with mic swing
                        this.vx = (this.dir ? 1 : -1) * 14;
                        this.box = {
                            relX: this.dir ? 30 : -70, relY: -5, w: 50, h: 50,
                            act: !0, own: this.id,
                            kbx: 15 * s.power, kby: -8 * s.power, dmg: 12 * s.power, f: 8
                        };
                        // Musical notes
                        for (let i = 0; i < 4; i++) {
                            particles.push({
                                x: this.x + this.w/2, y: this.y + (Math.random()-0.5)*20,
                                vx: (this.dir ? -1 : 1) * (2+Math.random()*2), vy: -Math.random()*3,
                                life: 25, text: ['🎵','🎶','🎤','🎵'][i], color: '#FF6347'
                            });
                        }
                        this.cd = 28;
                        return;
                    }
                    if (u) {
                        // Never Gonna Give You Up: Launch upward, enemy can't escape (pulls enemy)
                        this.vy = -15;
                        let t = players.find(p => p.id !== this.id && p.stocks > 0);
                        if (t) {
                            const dist = Math.abs(t.x - this.x) + Math.abs(t.y - this.y);
                            if (dist < 200) {
                                // Pull enemy toward Rick
                                t.vx += (this.x - t.x) * 0.1;
                                t.vy += (this.y - t.y) * 0.1;
                                particles.push({ x: t.x + 25, y: t.y - 10, text: "🎤 GOTCHA", life: 20, vy: -1, color: '#FF6347' });
                            }
                        }
                        this.box = {
                            relX: -25, relY: -40, w: 70, h: 60,
                            act: !0, own: this.id,
                            kbx: 4 * s.power, kby: -14 * s.power, dmg: 10 * s.power, f: 6
                        };
                        this.cd = 35;
                        return;
                    }
                    if (d) {
                        // Desert You: Teleport behind enemy, backstab
                        let t = players.find(p => p.id !== this.id && p.stocks > 0);
                        if (t) {
                            const oldX = this.x;
                            this.x = t.x + (t.dir ? -60 : 60);
                            this.y = t.y;
                            this.dir = t.x > this.x;
                            // Poof particles at old position
                            for (let i = 0; i < 6; i++) {
                                particles.push({
                                    x: oldX + this.w/2, y: this.y + this.h/2,
                                    vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6,
                                    life: 15, color: '#888', size: 4
                                });
                            }
                            this.box = {
                                relX: this.dir ? 20 : -60, relY: -10, w: 50, h: 50,
                                act: !0, own: this.id,
                                kbx: 12 * s.power, kby: -10 * s.power, dmg: 15 * s.power, f: 8
                            };
                            particles.push({ x: this.x + 25, y: this.y - 15, text: "🎵 Deserted!", life: 25, vy: -1, color: '#f55' });
                        }
                        this.cd = 50;
                        return;
                    }
                    // Neutral: Mic check — quick jab
                    this.box = {
                        relX: this.dir ? 25 : -55, relY: -5, w: 45, h: 40,
                        act: !0, own: this.id,
                        kbx: 9 * s.power, kby: -7 * s.power, dmg: 8 * s.power, f: 4
                    };
                    this.cd = 14;
                    return;
                }
                if (!u && !d && !l && !r) {
                    this.box = {
                        relX: -30,
                        relY: 0,
                        w: 110,
                        h: 50,
                        act: !0,
                        own: this.id,
                        kbx: 10 * s.power,
                        kby: -8 * s.power,
                        dmg: 8 * s.power,
                        f: 5
                    };
                    return;
                }
                if (d) {
                    this.box = {
                        relX: -40,
                        relY: 20,
                        w: 130,
                        h: 40,
                        act: !0,
                        own: this.id,
                        kbx: 12 * s.power,
                        kby: 5 * s.power,
                        dmg: 10 * s.power,
                        f: 8
                    };
                    return;
                }
                if (u) {
                    this.vy = -12 * s.jump;
                    this.box = {
                        relX: -20,
                        relY: -50,
                        w: 90,
                        h: 60,
                        act: !0,
                        own: this.id,
                        kbx: 5 * s.power,
                        kby: -15 * s.power,
                        dmg: 10 * s.power,
                        f: 5
                    };
                    return;
                }
                if (l || r) {
                    this.vx = (this.dir ? 1 : -1) * 5;
                    dmg = 12;
                    kbx = 15;
                    this.box = {
                        relX: ox,
                        relY: 0,
                        w: 60,
                        h: 50,
                        act: !0,
                        own: this.id,
                        kbx: kbx * s.power,
                        kby: kby * s.power,
                        dmg: dmg * s.power,
                        f: 5
                    };
                    return;
                }
            }
            hit(kbx, kby, d) {
                // EL DORADO - Adaptive ICE Shield: absorb one hit, create shockwave
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.software === 'el_dorado') {
                    if (!this.iceShieldCd || this.iceShieldCd <= 0) {
                        // Block the hit!
                        this.iceShieldCd = 1200; // 20 seconds at 60fps
                        sfx.play('shield');
                        // Golden shockwave pushes enemies back
                        players.forEach(p => {
                            if (p.id !== this.id && p.stocks > 0) {
                                const dist = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
                                if (dist < 200) {
                                    const pushDir = p.x > this.x ? 1 : -1;
                                    p.vx += pushDir * 12;
                                    p.vy -= 5;
                                    p.stun = 30;
                                }
                            }
                        });
                        // Golden shield break particles
                        for (let i = 0; i < 15; i++) {
                            const angle = (i / 15) * Math.PI * 2;
                            particles.push({
                                x: this.x + this.w/2 + Math.cos(angle) * 20,
                                y: this.y + this.h/2 + Math.sin(angle) * 20,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                life: 30,
                                color: '#ffd700',
                                size: 5
                            });
                        }
                        particles.push({ x: this.x + this.w/2, y: this.y - 10, text: "🛡️ ICE BLOCKED", life: 45, vy: -1.5, color: '#ffd700' });
                        return;
                    }
                }
                if (this.autoParryNext && Math.random() < 0.2) {
                    let attacker = players.find(p => p.box && p.box.act && p.id !== this.id);
                    if (attacker) {
                        attacker.stun = 120;
                    }
                    this.autoParryNext = false;
                    sfx.play('shield');
                    this.box = {
                        relX: -25,
                        relY: -25,
                        w: 100,
                        h: 100,
                        act: !0,
                        own: this.id,
                        kbx: 20,
                        kby: -20,
                        dmg: 25,
                        f: 5
                    };
                    return;
                }
                if (this.isParrying && this.parryTimer > 0) {
                    let attacker = players.find(p => p.box && p.box.act && p.id !== this.id);
                    if (attacker) {
                        attacker.stun = 120;
                        // Jack's Parry Combo bonus: 50% chance for permanent stat buff
                        if (this.stats.id === 'jack' && this.jackParryBonus) {
                            const statChoices = ['speed', 'power', 'jump'];
                            const buffStat = statChoices[Math.floor(Math.random() * 3)];
                            this.stats[buffStat] += 0.5;
                            console.log(`Jack parry buff! +0.5 ${buffStat}`);
                            // Visual effect
                            for (let i = 0; i < 10; i++) {
                                particles.push({
                                    x: this.x + this.w / 2,
                                    y: this.y + this.h / 2,
                                    vx: (Math.random() - 0.5) * 12,
                                    vy: (Math.random() - 0.5) * 12,
                                    size: 8,
                                    life: 40,
                                    color: '#FFD700'
                                });
                            }
                        }
                    }
                    this.parryTimer = 0;
                    this.isParrying = !1;
                    sfx.play('shield');
                    this.box = {
                        relX: -25,
                        relY: -25,
                        w: 100,
                        h: 100,
                        act: !0,
                        own: this.id,
                        kbx: 20,
                        kby: -20,
                        dmg: 25,
                        f: 5
                    };
                    return;
                }
                if (this.inv > 0 || (this.rolling && this.inv > 0)) return;
                if (this.gamblingFeverActive && Math.random() < 0.1) {
                    d *= 1.5;
                }
                // SUBDERMAL ARMOR: 20% damage reduction
                if (this.stats && this.stats.id === 'yellowdude' && saveData.cyberSlots && saveData.cyberSlots.software === 'subdermal_armor') {
                    d = Math.round(d * 0.8);
                    if (Math.random() < 0.3) particles.push({ x: this.x + this.w/2, y: this.y, text: "🛡️", life: 12, vy: -1, color: '#888' });
                }
                // BERSERK: reduced knockback when active
                if (this.berserkActive) {
                    kbx *= 0.5;
                    kby *= 0.6;
                }
                if (this.shielding) {
                    this.shieldHP -= d * 2;
                    sfx.play('shield');
                    this.vx = kbx * 0.5;
                    if (this.shieldHP <= 0) {
                        sfx.play('break');
                        this.shielding = !1;
                        this.stun = 180;
                        this.vy = -15;
                    }
                    return;
                }
                shake = Math.min(10, d * 0.5);
                particles.push({
                    x: this.x + this.w / 2,
                    y: this.y,
                    text: `+${Math.floor(d)}%`,
                    life: 60,
                    vy: -2
                });
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: this.x + this.w / 2,
                        y: this.y + this.h / 2,
                        vx: (Math.random() - 0.5) * 5 + kbx * 0.1,
                        vy: (Math.random() - 0.5) * 5 + kby * 0.1,
                        size: Math.random() * 5 + 2,
                        life: 30,
                        color: 'white'
                    });
                }
                this.pct += d;
                this.ult = Math.min(100, this.ult + d);
                let sc = 0.5 + (this.pct * 0.025),
                    wm = 1.0 / this.stats.weight;
                // Reduce knockback when Sandevistan is active (you're in the zone)
                const sandyKBReduce = (this.sandySlowMult && this.sandySlowMult > 1) ? 0.4 : 1;
                if (kbx !== 0) {
                    let o = players.find(p => p.id !== this.id);
                    this.vx = (this.x < (o ? o.x : 0) ? -1 : 1) * Math.abs(kbx * sc * wm) * sandyKBReduce;
                } else this.vx = (Math.random() - 0.5) * Math.abs(kbx * sc * wm) * sandyKBReduce;
                this.vy = kby * sc * wm * sandyKBReduce;
                this.inv = 10;
                sfx.play(d > 15 ? 'hit' : 'hit');
                hitStop = 5;
                updateHUD();
            }
            phys() {
                let gv = 0.6;
                if (worldFlipped) gv = -0.6;
                // Space map: low gravity
                if (selectedMap && selectedMap.lowGravity) gv *= 0.5;
                if (!this.isParrying) {
                    this.vy += gv;
                    if (!worldFlipped && this.vy > 25) this.vy = 25;
                    if (worldFlipped && this.vy < -25) this.vy = -25;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.grounded = !1;
                }
                if (isMemeBall) {
                    if (this.id === 1) {
                        this.x = Math.min(this.x, -10 - this.w);
                    }
                    if (this.id === 2) {
                        this.x = Math.max(this.x, 10);
                    }
                }
                for (let p of platforms) {
                    if (p.t === 'lava') {
                        if (this.y > p.y && this.y < p.y + p.h && this.x > p.x && this.x < p.x + p.w) {
                            this.hit(0, -20, 15);
                            this.y = p.y - 50;
                        }
                        continue;
                    }
                    if (p.t.startsWith('machine')) {
                        let dx = (this.x + this.w / 2) - p.pivotX;
                        let pStart = p.x;
                        let pEnd = p.x + p.w;
                        let pCenterX = this.x + this.w / 2;
                        if (pCenterX >= pStart && pCenterX <= pEnd) {
                            let floorY = p.pivotY + (pCenterX - p.pivotX) * Math.tan(p.angle);
                            if (this.vy >= 0 && this.y + this.h >= floorY - 15 && this.y + this.h <= floorY + 15) {
                                this.y = floorY - this.h;
                                this.vy = 0;
                                this.grounded = !0;
                                this.jumps = 2;
                            }
                        }
                        continue;
                    }
                    let pt = p.y,
                        ft = this.y + this.h;
                    if (this.vy >= 0 && ft >= pt && ft <= pt + Math.max(25, this.vy + 10) && this.x + this.w > p.x && this.x < p.x + p.w) {
                        this.y = p.y - this.h;
                        this.vy = 0;
                        this.grounded = !0;
                        this.jumps = 2;
                        if (p.vx) this.x += p.vx;
                        if (p.vy) this.y += p.vy;
                    }
                    if (p.t === 'solid' && this.vy < 0 && this.x + this.w > p.x && this.x < p.x + p.w && this.y < p.y + p.h && ft > p.y + p.h) {
                        this.y = p.y + p.h;
                        this.vy = 0;
                    }
                }
                if (this.y > 800 || this.y < -800) this.die();
            }
            die() {
                sfx.play('ko');
                this.stocks--;
                this.pct = 0;
                this.ult = 0;
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: this.x + this.w / 2,
                        y: this.y + this.h / 2,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15 - 5,
                        size: Math.random() * 8 + 3,
                        life: 60,
                        color: 'var(--ult)'
                    });
                }
                if (this.stocks > 0) {
                    this.x = 0;
                    this.y = -200;
                    this.vx = 0;
                    this.vy = 0;
                    shake = 20;
                }
                if (isSurvival) {
                    let humanPlayers = players.filter(p => !p.cpu);
                    let livingHumans = humanPlayers.filter(p => p.stocks > 0);
                    if (livingHumans.length === 0 && gameState === 'GAME') {
                        endGame(1);
                    }
                } else if (this.stocks <= 0) {
                    // Track Dynlar/Apogee kills for Yellow Dude in VS mode
                    const killer = players.find(p => p.id !== this.id && p.stocks > 0);
                    if (killer) {
                        trackDynlarKill(killer);
                    }
                    // Jack Of All Trades passive: Killer gains stats when Jack dies
                    if (killer && killer.stats.id === 'jack') {
                        if (!killer.jackKills) killer.jackKills = 0;
                        if (!killer.jackBuffs) killer.jackBuffs = { speed: 0, power: 0, jump: 0 };
                        killer.jackKills++;
                        // Random stat gets +3
                        const statChoices = ['speed', 'power', 'jump'];
                        const buffStat = statChoices[Math.floor(Math.random() * 3)];
                        killer.jackBuffs[buffStat] += 3;
                        killer.stats[buffStat] += 3;
                        killer.stats.weight += 0.1; // Weight increases each kill
                        console.log(`Jack gained +3 ${buffStat}, weight now ${killer.stats.weight.toFixed(1)}`);
                    }
                    if (gameState === 'GAME') endGame(this.id === 1 ? 2 : 1);
                }
                updateHUD();
            }
            chkItm() {
                items.forEach(i => {
                    if (i.active && this.x < i.x + i.w && this.x + this.w > i.x && this.y < i.y + i.h && this.y + this.h > i.y) {
                        if (i.type === 'hammer') {
                            this.hasHammer = !0;
                            i.active = !1;
                            sfx.play('coin');
                        } else if (i.type === 'landmine') {
                            this.hasLandmine = !0;
                            i.active = !1;
                            sfx.play('coin');
                        } else if (i.type === 'potion') {
                            this.alpha = 0.1;
                            this.inv = 600;
                            i.active = !1;
                            sfx.play('coin');
                        } else if (i.type === 'tomato') {
                            this.friction = 0.99;
                            this.pct = Math.max(0, this.pct - 10);
                            i.active = !1;
                            sfx.play('coin');
                        } else if (i.type === 'coin') {
                            if (this.id === 1 || !players.find(p => p.id === 1)) {
                                earnCoins(50);
                                sfx.play('coin');
                            }
                            i.active = !1;
                        } else if (i.type === 'mega') {
                            if (this.id === 1 || !players.find(p => p.id === 1)) {
                                earnCoins(500);
                                sfx.play('ult');
                            }
                            i.active = !1;
                        } else if (i.type === 'nyan') {
                            this.hit(20 * (i.vx > 0 ? 1 : -1), -10, 15);
                            i.active = !1;
                        } else if (i.type === 'star') {
                            // STAR: 5 sec invincibility + speed + golden glow
                            this.inv = 300;
                            this.starPower = true;
                            this.starTimer = 300;
                            const origSpeed = this.stats.speed;
                            this.stats = { ...this.stats, speed: this.stats.speed * 1.5 };
                            sfx.play('ult');
                            showAnnounce('⭐ STAR POWER!', '#FFD700');
                            for (let sp = 0; sp < 10; sp++) {
                                particles.push({ x: this.x + Math.random()*this.w, y: this.y + Math.random()*this.h, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 30, color: '#FFD700', size: 5 });
                            }
                            setTimeout(() => {
                                this.starPower = false;
                                this.stats = { ...this.stats, speed: origSpeed };
                            }, 5000);
                            i.active = !1;
                        } else if (i.type === 'freeze') {
                            // FREEZE: Freezes all enemies for 2 seconds
                            players.forEach(p => {
                                if (p.id !== this.id && p.stocks > 0) {
                                    p.stun = 120;
                                    p.vx = 0;
                                    p.vy = 0;
                                    // Ice VFX on frozen player
                                    for (let ic = 0; ic < 8; ic++) {
                                        particles.push({ x: p.x + Math.random()*p.w, y: p.y + Math.random()*p.h, vx: (Math.random()-0.5)*3, vy: -Math.random()*3, life: 25, color: '#88ccff', size: 4 });
                                    }
                                    particles.push({ x: p.x + p.w/2, y: p.y - 15, text: '🧊 FROZEN!', life: 40, vy: -1, color: '#88ccff' });
                                }
                            });
                            sfx.play('break');
                            showAnnounce('🧊 FREEZE!', '#88ccff');
                            i.active = !1;
                        }
                    }
                });
            }
            draw() {
                if (this.stocks <= 0) return;
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                if (this.isBoss) ctx.scale(2.5, 2.5);
                // Base sprites face right; flip when facing left
                if (!this.dir) ctx.scale(-1, 1);
                if (this.confused > 0) {
                    ctx.font = "20px Arial";
                    ctx.fillText("❓", 0, -40);
                }
                ctx.globalAlpha = this.alpha;
                // OPTICAL CAMO: Semi-transparent when active
                if (this.opticalCamoActive) {
                    ctx.globalAlpha = 0.15;
                }
                ctx.font = "50px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                const sprite = characterSprites[this.stats.id];
                if (saveData.goldMode && this.id === 1) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                } else if (this.starPower) {
                    // Star power golden rainbow glow
                    const hue = (Date.now() / 10) % 360;
                    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                    ctx.shadowBlur = 20;
                } else {
                    ctx.shadowBlur = 0;
                }
                if (this.stun > 0) {
                    this.setAnimation("idle");
                    ctx.fillText("💫", 0, -10);
                } else if (this.rolling) {
                    ctx.globalAlpha = 0.5;
                    ctx.rotate(Date.now() / 50);
                }
                if (this.isParrying && this.parryTimer > 0) {
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.5;
                }
                if (sprite && sprite.idle) {
                    const anim = sprite[this.animation] || sprite["idle"];
                    if (anim) {
                        this.frameTimer += this.animSpeed;
                        if (this.frameTimer >= 1) {
                            this.frameTimer = 0;
                            this.frame = (this.frame + 1) % anim.length;
                            if (this.stats.id === 'brokeboy') {
                                console.log(`[ANIM] brokeboy ${this.animation} frame=${this.frame}/${anim.length}`);
                            }
                        }
                        const currentFrameSprite = anim[this.frame];
                        if (currentFrameSprite) ctx.drawImage(currentFrameSprite, -this.w / 2, -this.h / 2, this.w, this.h);
                    }
                } else if (sprite) {
                    ctx.drawImage(sprite, -this.w / 2, -this.h / 2, this.w, this.h);
                } else {
                    ctx.fillText(this.stats.icon, 0, 5);
                }
                if (saveData.goldMode && this.id === 1) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                    if (sprite && sprite.idle) {
                        const anim = sprite[this.animation] || sprite["idle"];
                        if (anim) ctx.drawImage(anim[this.frame], -this.w / 2, -this.h / 2, this.w, this.h);
                    } else if (sprite) {
                        ctx.drawImage(sprite, -this.w / 2, -this.h / 2, this.w, this.h);
                    }
                }
                ctx.shadowBlur = 0;
                if (this.hasHammer) {
                    ctx.font = "20px Arial";
                    ctx.fillText('🔨', 25, -25);
                }
                if (this.hasLandmine) {
                    ctx.font = "20px Arial";
                    ctx.fillText('💣', 25, -25);
                }
                if (this.id === 1 && equippedCosmetic) {
                    ctx.font = "30px Arial";
                    if (equippedCosmetic === 'tophat') ctx.fillText('🎩', 0, -30);
                    if (equippedCosmetic === 'shades') ctx.fillText('🕶️', 5, 0);
                    if (equippedCosmetic === 'crown') ctx.fillText('👑', 0, -35);
                }
                if (this.shielding) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * (this.shieldHP / 100), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${255 - this.shieldHP * 2.55},${this.shieldHP * 2.55},0,0.5)`;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
                if (this.box && this.box.act && showHitboxes) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillRect(this.x + this.box.relX, this.y + this.box.relY, this.box.w, this.box.h);
                }
                ctx.fillStyle = this.id === 1 ? '#3498db' : (this.isCpu ? '#9b59b6' : '#e74c3c');
                ctx.font = "bold 12px sans-serif";
                ctx.fillText(this.isCpu ? `CPU` : `P${this.id}`, this.x + 15, this.y - 10);
            }
        }
        const CHARACTERS = [{
            id: 'doge',
            name: 'Doge',
            icon: '🐕',
            speed: 1.1,
            weight: 1.0,
            power: 1.0,
            jump: 1.0,
            desc: "Balanced",
            moves: {
                side: "Zoomies",
                up: "Moon Jump",
                down: "Heavy",
                ult: "MOON CRASH"
            },
            colors: {
                '0': null,
                '1': '#c19a6b'
            },
            animSheet: {
                "idle": {
                    speed: 0.05,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"],
                        ["0000000000000000", "0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "walk": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "jump": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "fall": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "stun": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "roll": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                },
                "shield": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000011111000000", "0001111111110000", "0011111111111100", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0111111111111110", "0011111111111100", "0011111111111100", "0001111111111000", "0000011111000000"]
                    ]
                }
            }
        }, {
            id: 'frog',
            name: 'Pepe',
            icon: '🐸',
            speed: 0.8,
            weight: 1.4,
            power: 1.3,
            jump: 0.9,
            desc: "Heavy",
            moves: {
                side: "Ree Punch",
                up: "High Hop",
                down: "Stomp",
                ult: "TEAR FLOOD"
            }
        }, {
            id: 'cat',
            name: 'Pop Cat',
            icon: '🙀',
            speed: 1.4,
            weight: 0.7,
            power: 0.8,
            jump: 1.2,
            desc: "Speed",
            moves: {
                side: "Scratch",
                up: "Pop Jump",
                down: "Fast Fall",
                ult: "POP STORM"
            }
        }, {
            id: 'capy',
            name: 'Capy',
            icon: '🥔',
            speed: 0.6,
            weight: 1.8,
            power: 1.5,
            jump: 0.8,
            desc: "Tank",
            moves: {
                side: "Headbutt",
                up: "Chill Rise",
                down: "Slam",
                ult: "PULL UP"
            }
        }, {
            id: 'spongy',
            name: 'Spongy',
            icon: '🧽',
            speed: 1.0,
            weight: 0.9,
            power: 1.1,
            jump: 1.3,
            desc: "Aerial",
            moves: {
                side: "Karate",
                up: "Rainbow",
                down: "Head Out",
                ult: "IMAGINATION"
            }
        }, {
            id: 'sanic',
            name: 'Sanic',
            icon: '🦔',
            speed: 1.8,
            weight: 0.8,
            power: 0.9,
            jump: 1.1,
            desc: "Fast",
            moves: {
                side: "Go Fast",
                up: "Spring",
                down: "Spindash",
                ult: "LIGHT SPEED"
            }
        }, {
            id: 'chad',
            name: 'Chad',
            icon: '🗿',
            speed: 0.5,
            weight: 2.0,
            power: 1.4,
            jump: 0.7,
            desc: "Boss",
            moves: {
                side: "Strut",
                up: "Chin Up",
                down: "Flex",
                ult: "GIGA STUN"
            }
        }, {
            id: 'troll',
            name: 'Troll',
            icon: '👺',
            speed: 1.2,
            weight: 1.0,
            power: 1.0,
            jump: 1.5,
            desc: "Tricky",
            moves: {
                side: "Problem?",
                up: "Float",
                down: "Glitch",
                ult: "U MAD?"
            }
        }, {
            id: '67kid',
            name: '67 Kid',
            icon: '🧒',
            speed: 1.0,
            weight: 0.9,
            power: 1.0,
            jump: 1.2,
            desc: "Chaotic",
            moves: {
                side: "Cringe",
                up: "Youtube Shorts",
                down: "67!!!",
                ult: "BRAIN ROT"
            }
        }, {
            id: 'amogus',
            name: 'Amogus',
            icon: '🕵️',
            speed: 1.1,
            weight: 1.2,
            power: 1.2,
            jump: 1.0,
            desc: "Sus",
            moves: {
                side: "Vent",
                up: "Eject",
                down: "Sus Strike",
                ult: "EMERGENCY MEETING"
            }
        }, {
            id: 'sahur',
            name: 'Sahur Drum',
            icon: '🥁',
            speed: 0.7,
            weight: 1.7,
            power: 1.4,
            jump: 0.8,
            desc: "Heavy Hitter",
            moves: {
                side: "Loud Lunge",
                up: "Drum Pop",
                down: "TUNG TUNG!",
                ult: "DEAFENING BEAT"
            },
            colors: {
                '0': null,
                '1': '#000000',
                '2': '#1A1A1A',
                '3': '#7A4E28',
                '4': '#B37842',
                '5': '#FFFFFF'
            },
            spriteData: ["0000222222200000", "0002333333320000", "0023444444432000", "0234511441154200", "0234114444114200", "0234144444414200", "0234141111414200", "0234141441414200", "0234141441414200", "0234141441414200", "0234114444114200", "0234411441144200", "0023444444432000", "0002333333320000", "0000222002200000", "0000022002200000"]
        }, {
            id: 'primo',
            name: 'Los Primos',
            icon: '🧱',
            speed: 1.0,
            weight: 1.5,
            power: 1.3,
            jump: 1.0,
            desc: "Tag Team",
            moves: {
                side: "Primo Lunge",
                up: "Flying Elbow",
                down: "Stomp & Kick",
                ult: "TAG TEAM!"
            },
            colors: {
                '0': null,
                '1': '#000000',
                '2': '#1A1A1A',
                '3': '#4EC4FF',
                '4': '#FFFFFF',
                '5': '#E53030'
            },
            spriteData: ["0000000000000000", "0002222222222000", "0002333333332000", "0002341334132000", "0002411441142000", "0002444114442000", "0002222552222000", "0000222222220000", "0002244444422000", "0023344444433200", "0233244444423320", "0232222222222320", "0020232002320200", "0000242002420000", "0000222002220000", "0000000000000000"]
        }, {
            id: 'ocralito',
            name: 'The Ocralito',
            icon: '🐋',
            speed: 0.9,
            weight: 1.6,
            power: 1.2,
            jump: 1.0,
            desc: "Slippery",
            moves: {
                side: "Belly Slide",
                up: "Tail Splash",
                down: "Stomp",
                ult: "DEEP FREEZE"
            },
            colors: {
                '0': null,
                '1': '#000000',
                '2': '#1A1A1A',
                '3': '#0A0F25',
                '4': '#FFFFFF',
                '5': '#4EC4FF'
            },
            spriteData: ["0000222222200000", "0002333333320000", "0002344444432000", "0002411551142000", "0002411441142000", "0002441111442000", "0002221111222000", "0000222222220000", "0002244444422000", "0023344444433200", "0233244444423320", "0232222222222320", "0020332002330200", "0000242002420000", "0000222002220000", "0000000000000000"]
        }, {
            id: 'mechabara',
            name: 'Mecha-Bara',
            icon: '🦾',
            speed: 0.7,
            weight: 2.2,
            power: 1.5,
            jump: 1.1,
            desc: "Programmed to chill.",
            moves: {
                side: "Drill Lunge",
                up: "Booster Jets",
                down: "Ground Laser",
                ult: "ORBITAL STRIKE"
            }
        }, {
            id: 'bluedude',
            name: 'Bluedude',
            icon: '⚔️',
            speed: 1.3,
            weight: 0.8,
            power: 1.0,
            jump: 1.2,
            desc: "A fast swordsman.",
            moves: {
                side: "Blade Dash",
                up: "Rising Blade",
                down: "Parry",
                ult: "Zero Slash"
            },
            colors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#D9965A',
                '3': '#4FC5FF',
                '4': '#7B8694',
                '5': '#FFFFFF'
            },
            animSheet: {
                "idle": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                        ["0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000"],
                        ["0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
                    ]
                },
                "walk": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000011000001000", "0000010000001100", "0000110000000100"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0050000000000000", "0050000000000000", "0050000000000000", "0050011111110000", "0444013333310000", "0020011531510000", "0021111131111100", "0000013333310100", "0000011111110100", "0000010000010000", "0000010000010000", "0000110000110000"]
                    ]
                },
                "jump": {
                    speed: 0.1,
                    frames: [
                        ["0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000"]
                    ]
                },
                "fall": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
                    ]
                },
                "attack_side": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000011000011000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000001111111", "0000000001333331", "0000400001153151", "0555422111113111", "0000400001333331", "0000000001111111", "0000000001000001", "0000000001000001", "0000000011000011"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000011111110", "0000000013333310", "0004000011531510", "0555422111113111", "0004000013333310", "0000000011111110", "0000000010000010", "0000000010000010", "0000000110000110"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000111111100", "0000000133333100", "0040000115315100", "0554221111131110", "0040000133333100", "0000000111111100", "0000000100000100", "0000000100000100", "0000001100001100"]
                    ]
                },
                "attack_up": {
                    speed: 0.15,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0500000000000000", "0500000000000000", "0500000000000000", "0444011111110000", "0021013333310000", "0020111535110000", "0001011131110000", "0000113333310000", "0000011111110000", "0000100000100000", "0000100000100000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0500000000000000", "0500000000000000", "0500000000000000", "0444011111110000", "0021013333310000", "0020111535110000", "0001011131110000", "0000113333310000", "0000011111110000", "0000100000100000", "0000100000100000"],
                        ["0000000100000000", "0000001310000000", "0000013331000000", "0000013131000000", "0000013331000000", "0111113131001110", "0155113331111510", "0155513131155510", "0015555555551100", "0001115555511000", "0000011111100000", "0000013131000000", "0000013331000000", "0000001310000000", "0000000100000000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0050000000000000", "0050000000000000", "0050000000000000", "0444111111100000", "0020133333100000", "0020115351100000", "0011111311111000", "0000133333101000", "0000111111101000", "0000100000100000", "0000100000100000"]
                    ]
                },
                "stun": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
                    ]
                },
                "roll": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0005000000000000", "0005000000000000", "0005000000000000", "0005001111111000", "0044401333331000", "0002001153151000", "0002111113111110", "0000001333331010", "0000001111111010", "0000001000001000", "0000001000001000", "0000001100001100"]
                    ]
                },
                "shield": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000001111111", "0000000001333331", "0000000001153151", "0000011111113111", "0001121001333331", "0014210001111111", "0154410001000001", "1555100001000001", "1551000011000011", "0110000000000000"]
                    ]
                }
            }
        }, {
            id: 'thememe',
            name: 'THE MEME',
            icon: '🤡',
            speed: 2.0,
            weight: 999,
            power: 999,
            jump: 2.0,
            desc: "GOD",
            moves: {
                side: "DEATH",
                up: "DEATH",
                down: "DEATH",
                ult: "DEATH"
            }
        }, {
            id: 'gps',
            name: 'GPS',
            icon: '🧭',
            speed: 1.3,
            weight: 1.0,
            power: 1.0,
            jump: 1.1,
            desc: "Director",
            moves: {
                side: "Recalculating",
                up: "Uplink",
                down: "Turn Around",
                ult: "GLOBAL ROTATION"
            }
        }, {
            id: 'johnpork',
            name: 'John Pork',
            icon: '📞',
            speed: 1.0,
            weight: 1.1,
            power: 1.1,
            jump: 1.0,
            desc: "He's calling...",
            moves: {
                side: "Yo Phone Linging",
                up: "Accept Call",
                down: "Decline Call",
                ult: "PIG SLAM"
            }
        }, {
            id: 'luckyblock',
            name: 'Lucky Block',
            icon: '🎁',
            speed: 1.2,
            weight: 1.0,
            power: 1.3,
            jump: 1.1,
            desc: "Ultra Rare",
            moves: {
                side: "Lucky Block OPEN",
                up: "Loan Debt",
                down: "Crushing Debt",
                ult: "Gambling Fever"
            },
            colors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#ff0000',
                '3': '#3c587c',
                '4': '#417ea4',
                '5': '#ffffff',
                '6': '#FF0000',
                '7': '#FFA500',
                '8': '#FFFF00',
                '9': '#00FF00',
                'A': '#00FFFF',
                'B': '#0000FF',
                'C': '#8000FF',
                'D': '#FF00FF',
                'E': '#964B00',
                'F': '#808080',
                'G': '#404040',
                'H': '#606060',
                'I': '#202020',
                'J': '#008000',
                'K': '#008080',
                'L': '#800000',
                'M': '#808000',
                'N': '#0080FF',
                'O': '#FF0080',
                'P': '#C0C0C0',
                'Q': '#A0A0A0',
                'R': '#303030',
                'S': '#101010',
                'T': '#FFD700',
                'U': '#ADFF2F',
                'V': '#4B0082'
            },
            spriteData: ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"]
        }, {
            id: 'brokeboy',
            name: 'Broke Boy',
            icon: '💸',
            speed: 0.9,
            weight: 0.8,
            power: 0.7,
            jump: 0.9,
            desc: "Common",
            moves: {
                side: "Please speed I need this",
                up: "Sucker Punch",
                down: "Broken Sword",
                ult: "Mrbeast"
            },
            colors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#eea0bf',
                '3': '#ecbbd3',
                '4': '#9c6d6d',
                '5': '#ffffff',
                '6': '#FF0000',
                '7': '#FFA500',
                '8': '#FFFF00',
                '9': '#00FF00',
                'A': '#00ff00',
                'B': '#00cc00',
                'C': '#00ff80',
                'D': '#FF00FF',
                'E': '#964B00',
                'F': '#c96500',
                'G': '#633200',
                'H': '#969600',
                'I': '#202020',
                'J': '#008000',
                'K': '#008080',
                'L': '#800000',
                'M': '#808000',
                'N': '#0080FF',
                'O': '#FF0080',
                'P': '#C0C0C0',
                'Q': '#A0A0A0',
                'R': '#303030',
                'S': '#101010',
                'T': '#FFD700',
                'U': '#ADFF2F',
                'V': '#4B0082'
            },
            spriteData: ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"],
            animSheet: {
                "idle": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"]
                    ]
                },
                "attack_side": {
                    speed: 4,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000099CC00000000", "0000B55CSSSS0000", "000SEEEEEFFS0000", "000SEEEEEFFS0000", "000SGEEEEEES0000", "000SGEEEEEES0000", "000SGGGEEEES0000", "000SSSSSSSSS0000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111000", "001QQQQQQQQQ1000", "001QQQTTTTTQ1000", "001Q1Q51T51Q1000", "001QQ111T11Q1000", "001Q1QTTTTTQ1000", "001QQ1TTTTTQ1000", "001QQQQQQQQQ1000", "001SSSSSSSSS1000", "0000000000000000"]
                    ]
                },
                "attack_up": {
                    speed: 0.2,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "00000000CC990000", "0000SSSSC55B0000", "0000SFFEEEEES000", "0000SFFEEEEES000", "0000SEEEEEEGS000", "0000SEEEEEEGS000", "0000SEEEEGGGS000", "0000SSSSSSSSS000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CC99000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CC99000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "000000000CCBB000", "000000000C55B000", "00000SSSSC55B000", "00000SFFEEEEES00", "00000SFFEEEEES00", "00000SEEEEEEGS00", "00000SEEEEEEGS00", "00000SEEEEGGGS00", "00000SSSSSSSSS00", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0000000000CCBB00", "0000000000C55B00", "0000000000C55B00", "0000000000955A00", "00000000009AAA00", "000000SSSS000000", "000000SFFEEEEES0", "000000SFFEEEEES0", "000000SEEEEEEGS0", "000000SEEEEEEGS0", "000000SEEEEGGGS0", "000000SSSSSSSSS0", "0000000000000000", "0000000000000000", "0000000000000000"],
                        ["0000000000000000", "0000000000CCBB00", "0000000000C55B00", "0000000000C55B00", "0000000000955A00", "00000000009AAA00", "000000SSSS000000", "000000SFFEEEEES0", "000000SFFEEEEES0", "000000SEEEEEEGS0", "000000SEEEEEEGS0", "000000SEEEEGGGS0", "000000SSSSSSSSS0", "0000000000000000", "0000000000000000", "0000000000000000"]
                    ]
                },
                "shield": {
                    speed: 1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0SSSS00000000000", "0SFFEEEEES111100", "0SFFEEEEESCAA100", "0SEEEEEEGSC5A110", "0SEEEEEEGS555B10", "0SEEEEGGGS15BB10", "0SSSSSSSSS111110", "0000000000000000", "0000000000000000"]
                    ]
                },
                "ult": {
                    speed: 0.1,
                    frames: [
                        [
                            "0000IIIIIII00000",
                            "IIIIIOPPPPI00000",
                            "IIIIII110PII0000",
                            "777771211PPII000",
                            "777711221OPPII00",
                            "I77771110OOPIII0",
                            "0II11II00OOPIIII",
                            "0IROOOOOOOOPPPII",
                            "0IROOOOOOI3IIII0",
                            "0IRRROOOI3300000",
                            "0IIRRRROI3000000",
                            "000IIIROI6600000",
                            "00000IRROI660000",
                            "00000IIROOII0000",
                            "000000IIIII00000",
                            "0000000000000000"
                        ]
                    ]
                }
            },
            ultColors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#ffffff',
                '3': '#ecbbd3',
                '4': '#ffcae4',
                '5': '#b993a5',
                '6': '#af4141',
                '7': '#d1057c',
                '8': '#FFFF00',
                '9': '#00FF00',
                'A': '#00ff00',
                'B': '#00cc00',
                'C': '#00ff80',
                'D': '#FF00FF',
                'E': '#964B00',
                'F': '#c96500',
                'G': '#633200',
                'H': '#969600',
                'I': '#141010',
                'J': '#008000',
                'K': '#008080',
                'L': '#800000',
                'M': '#808000',
                'N': '#0080FF',
                'O': '#74b8fb',
                'P': '#9ee0ff',
                'Q': '#5c93c8',
                'R': '#7475fb',
                'S': '#101010',
                'T': '#FFD700',
                'U': '#ADFF2F',
                'V': '#4B0082'
            },
            ultSprite: ["0000IIIIIII00000", "IIIIIOPPPPI00000", "IIIIII110PII0000", "777771211PPII000", "777711221OPPII00", "I77771110OOPIII0", "0II11II00OOPIIII", "0IROOOOOOOOPPPII", "0IROOOOOOI3IIII0", "0IRRROOOI3300000", "0IIRRRROI3000000", "000IIIROI6600000", "00000IRROI660000", "00000IIROOII0000", "000000IIIII00000", "0000000000000000"]
        }, {
            id: 'glitch',
            name: 'Glitch',
            icon: '⚡',
            speed: 1.3,
            weight: 0.7,
            power: 1.2,
            jump: 1.4,
            desc: "Unstable",
            moves: {
                side: "Pixel Shift",
                up: "Data Corruption",
                down: "Reality Break",
                ult: "SYSTEM CRASH"
            },
            colors: {
                '0': null,
                '1': '#ff0000',
                '2': '#00ff00',
                '3': '#0000ff',
                '4': '#ffff00',
                '5': '#ff00ff',
                '6': '#00ffff',
                '7': '#ffffff'
            },
            spriteData: ["0000000000000000", "0011111111110000", "0013456712340000", "0014567123450000", "0015671234560000", "0016712345610000", "0017123456120000", "0071234561230000", "0012345612340000", "0023456123450000", "0034561234560000", "0045612345610000", "0056123456120000", "0061234561230000", "0000000000000000", "0000000000000000"]
        }, {
            id: 'jack',
            name: 'Jack Of All Trades',
            icon: '🃏',
            speed: 1.8,
            weight: 0.5,
            power: 2.0,
            jump: 2.0,
            desc: "Master of None",
            moves: {
                side: "Master Of None",
                up: "Rising Mastery",
                down: "Parry Combo",
                ult: "Everything Everywhere All At Once"
            },
            colors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#FFFFFF',
                '3': '#7B8694',
                '4': '#b27c4b',
                '5': '#d9965a',
                '6': '#FF0000',
                '7': '#ff0000',
                '8': '#cc0000',
                '9': '#ff8000',
                'A': '#00FFFF',
                'B': '#0000FF',
                'C': '#8000FF',
                'D': '#FF00FF',
                'E': '#964B00',
                'F': '#808080',
                'G': '#404040',
                'H': '#606060',
                'I': '#202020',
                'J': '#008000',
                'K': '#008080',
                'L': '#800000',
                'M': '#b30000',
                'N': '#4d0000',
                'O': '#804000',
                'P': '#C0C0C0',
                'Q': '#A0A0A0',
                'R': '#303030',
                'S': '#101010',
                'T': '#FFD700',
                'U': '#ADFF2F',
                'V': '#4B0082'
            },
            spriteData: ["0000000000000000", "0001111111111100", "0001M27272626100", "0001222222222100", "0001M2M272626100", "0001222222222100", "0001M2M2M2M26100", "0001222222222100", "0001L2M2M2M26100", "0001222222222100", "0001N28282826100", "0001222222222100", "0001N28282826100", "0001222222222100", "0001N2N2N2L26100", "0001111111111100"],
            jackKills: 0,
            jackBuffs: { speed: 0, power: 0, jump: 0 }
        }, {
            id: 'yellowdude',
            name: 'Yellow Dude',
            icon: '😐',
            speed: 1.0,
            weight: 1.0,
            power: 1.0,
            jump: 1.0,
            desc: "Custom Build",
            customMoveset: true,
            moves: {
                side: "---",
                up: "---",
                down: "Kiroshi Counter",
                ult: "---"
            },
            colors: {
                '0': "rgba(0,0,0,0)",
                '1': '#000000',
                '2': '#FFFFFF',
                '3': '#7B8694',
                '4': '#b27c4b',
                '5': '#d9965a',
                '6': '#FF0000',
                '7': '#FFA500',
                '8': '#FFFF00',
                '9': '#00FF00',
                'A': '#00FFFF',
                'B': '#0000FF',
                'C': '#8000FF',
                'D': '#FF00FF',
                'E': '#964B00',
                'F': '#808080',
                'G': '#404040',
                'H': '#606060',
                'I': '#202020',
                'J': '#008000',
                'K': '#008080',
                'L': '#800000',
                'M': '#808000',
                'N': '#0080FF',
                'O': '#FF0080',
                'P': '#C0C0C0',
                'Q': '#A0A0A0',
                'R': '#303030',
                'S': '#101010',
                'T': '#FFD700',
                'U': '#f2d25f',
                'V': '#ccac00'
            },
            animSheet: {
                "idle": {
                    speed: 0.1,
                    frames: [
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000011111110000", "000001TTUUU10000", "00000112T1210000", "00000111T1110000", "000011TTTUU11000", "000101VTTTT10100", "001001VVTTT10010", "0000011111110000", "0000010000010000", "0000010000010000", "0000010000010000", "0000010000010000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000011111110000", "000001TTUUU10000", "00000112T1210000", "00000111T1110000", "000011TTTUU11000", "000101VTTTT10100", "001001VVTTT10010", "0000011111110000", "0000010000010000", "0000010000010000", "0000010000010000"],
                        ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0000011111110000", "000001TTUUU10000", "00000112T1210000", "00000111T1110000", "000011TTTUU11000", "000101VTTTT10100", "001001VVTTT10010", "0000011111110000", "0000010000010000", "0000010000010000", "0000010000010000", "0000010000010000"]
                    ]
                }
            }
        }, {
            id: 'nyancat',
            name: 'Nyan Cat',
            icon: '🌈',
            speed: 1.6,
            weight: 0.6,
            power: 0.9,
            jump: 1.3,
            desc: "Rainbow Rush",
            moves: {
                side: "Rainbow Dash",
                up: "Pop-Tart Launch",
                down: "Bass Drop",
                ult: "NYAN STORM"
            },
            colors: {
                '0': null,
                '1': '#808080',
                '2': '#FFB6C1',
                '3': '#FF69B4',
                '4': '#FF0000',
                '5': '#FFA500',
                '6': '#FFFF00',
                '7': '#00FF00',
                '8': '#00BFFF',
                '9': '#8B00FF'
            },
            spriteData: ["0000000000000000", "0000011111100000", "0001122222210000", "0012233333321000", "0123333333332100", "0133333333333100", "0133311331133100", "0133333333333100", "0133331111333100", "0123333333332100", "0012233333321000", "0001122222210000", "0000456789000000", "0000456789000000", "0000456789000000", "0000000000000000"]
        }, {
            id: 'shrek',
            name: 'Shrek',
            icon: '🟢',
            speed: 0.7,
            weight: 2.0,
            power: 1.5,
            jump: 0.7,
            desc: "Ogre Tank",
            moves: {
                side: "Ogre Slam",
                up: "Swamp Geyser",
                down: "Onion Layers",
                ult: "GET OUT OF MY SWAMP"
            },
            colors: {
                '0': null,
                '1': '#2d5a1e',
                '2': '#4a8c2a',
                '3': '#5aad33',
                '4': '#3b7a24',
                '5': '#8b6f47',
                '6': '#FFFFFF',
                '7': '#1a3d12'
            },
            spriteData: ["0000000000000000", "0000011111100000", "0001122222210000", "0012233333321000", "0123344443332100", "0133344443333100", "0133366633333100", "0133333333333100", "0133333333333100", "0133337733333100", "0123344444332100", "0012233333321000", "0001155555510000", "0000155555510000", "0000015555100000", "0000000000000000"]
        }, {
            id: 'rickastley',
            name: 'Rick Astley',
            icon: '🎤',
            speed: 1.0,
            weight: 1.0,
            power: 1.1,
            jump: 1.1,
            desc: "Never Gonna",
            moves: {
                side: "Never Gonna Run Around",
                up: "Never Gonna Give You Up",
                down: "Desert You",
                ult: "RICKROLL"
            },
            colors: {
                '0': null,
                '1': '#8B4513',
                '2': '#D2691E',
                '3': '#FFD39B',
                '4': '#1a1a1a',
                '5': '#333333',
                '6': '#FFFFFF',
                '7': '#FF6347'
            },
            spriteData: ["0000000000000000", "0000111111000000", "0001122211100000", "0001111111100000", "0001133311100000", "0000133310000000", "0000444444000000", "0000477744000000", "0000444444000000", "0000455554000000", "0000455554000000", "0000444444000000", "0000044440000000", "0000055550000000", "0000050050000000", "0000050050000000"]
        }];
        const MAPS = [{
            id: 'flat',
            c: '#546E7A'
        }, {
            id: 'plat',
            c: '#2E7D32'
        }, {
            id: 'edge',
            c: '#4e342e'
        }, {
            id: 'machine',
            c: '#7f8c8d'
        }, {
            id: 'nightcity',
            c: '#0a0015',
            neon: true
        }, {
            id: 'badlands',
            c: '#3d1f00'
        }, {
            id: 'arasaka_district',
            c: '#080020'
        }, {
            id: 'arasaka_tower',
            c: '#0a0008'
        }, {
            id: 'backrooms',
            c: '#c4b078'
        }, {
            id: 'space',
            c: '#000010',
            lowGravity: true
        }, {
            id: 'minecraft',
            c: '#5b8731'
        }];
        let selectedMap = MAPS[0];
        const characterSprites = {};
        CHARACTERS.forEach(char => {
            // Prefer animations when available; fall back to static sprite
            if (char.animSheet) {
                characterSprites[char.id] = generateAnimationSheet(char.animSheet, char.colors);
            } else if (char.spriteData) {
                characterSprites[char.id] = generateSprite(char.spriteData, char.colors);
            }
        });
        const MASTER_TROPHY_LIST = {
            'kills_50': {
                name: "Horde Slayer",
                desc: "Get 50 total kills in Survival",
                icon: "💀"
            },
            'flawless': {
                name: "Flawless",
                desc: "Win a VS match with 0% damage",
                icon: "✨"
            },
            'buy_gold': {
                name: "High Roller",
                desc: "Buy the Gold Skin in the shop",
                icon: "💰"
            },
            'unlock_chad': {
                name: "Giga-Brain",
                desc: "Unlock Chad",
                icon: "🗿"
            },
            'unlock_meme': {
                name: "Secret Hunter",
                desc: "Unlock THE MEME",
                icon: "🤡"
            },
            'unlock_gps': {
                name: "Recalculating...",
                desc: "Unlock GPS",
                icon: "🧭"
            },
            'unlock_mechabara': {
                name: "Chill Protocol",
                desc: "Unlock Mecha-Bara",
                icon: "🦾"
            },
            'unlock_bluedude': {
                name: "Pointy End",
                desc: "Unlock Bluedude",
                icon: "⚔️"
            },
            'unlock_johnpork': {
                name: "He Answered",
                desc: "Unlock John Pork",
                icon: "📞"
            },
            'unlock_glitch': {
                name: "Reality Breaker",
                desc: "Unlock Glitch",
                icon: "⚡"
            },
            'dynlar_10_kills': {
                name: "Chrome Assassin",
                desc: "Get 10 kills while using Dynlar Sandevistan",
                icon: "⏱️",
                reward: 'sandevistan_apogee'
            },
            'edgerunner_complete': {
                name: "I Really Want to Stay at Your House",
                desc: "Complete the entire Edgerunner storyline",
                icon: "🌙"
            },
            'street_cred_10': {
                name: "Rising Rep",
                desc: "Reach Street Cred Level 10",
                icon: "📈"
            },
            'street_cred_25': {
                name: "V-Status",
                desc: "Reach Street Cred Level 25",
                icon: "🔥"
            },
            'street_cred_50': {
                name: "Legend of Night City",
                desc: "Reach Street Cred Level 50",
                icon: "👑"
            }
        };
        function loadGame() {
            const d = localStorage.getItem(SAVE_KEY);
            if (d) saveData = JSON.parse(d);
            if (!saveData.unlocks) saveData.unlocks = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', '67kid', 'amogus', 'sahur', 'primo', 'ocralito'];
            if (!saveData.unlocks.includes('sahur')) saveData.unlocks.push('sahur');
            if (!saveData.unlocks.includes('primo')) saveData.unlocks.push('primo');
            if (!saveData.unlocks.includes('ocralito')) saveData.unlocks.push('ocralito');
            if (!saveData.cosmetics) saveData.cosmetics = [];
            if (!saveData.trophies) saveData.trophies = [];
            if (!saveData.titles) saveData.titles = [];
            if (!saveData.powerBoosters) saveData.powerBoosters = 0;
            if (saveData.mobileControls === undefined) saveData.mobileControls = !0;
            if (saveData.equipped) equippedCosmetic = saveData.equipped;
            // Ensure cyberSlots has arm slot
            if (saveData.cyberSlots && !saveData.cyberSlots.hasOwnProperty('arm')) saveData.cyberSlots.arm = null;
            // Ensure cyberSlots has software slot
            if (saveData.cyberSlots && !saveData.cyberSlots.hasOwnProperty('software')) saveData.cyberSlots.software = null;
            // Ensure cyberSlots has legs slot
            if (saveData.cyberSlots && !saveData.cyberSlots.hasOwnProperty('legs')) saveData.cyberSlots.legs = null;
            // Init quest progress
            if (!saveData.questProgress) saveData.questProgress = {};
            // Init street cred
            if (!saveData.streetCred) saveData.streetCred = { xp: 0, level: 1 };
            // Init ending tracker
            if (!saveData.endingTracker) saveData.endingTracker = { usedSandy: false, ending: null };
            // Init loadout presets
            if (!saveData.loadoutPresets) saveData.loadoutPresets = {};
            updateCoinDisplay();
            updateMobileControlsSetting();
            if (saveData.unlocks.includes('yellowdude')) {
                const btn = document.getElementById('cyberware-btn');
                if (btn) btn.style.display = 'block';
                const storyBtn = document.getElementById('story-btn');
                if (storyBtn) storyBtn.style.display = 'block';
            }
        }
        function saveGame() {
            saveData.equipped = equippedCosmetic;
            localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            updateCoinDisplay();
        }
        function updateCoinDisplay() {
            const el = document.getElementById('coin-count');
            if (el) el.innerText = saveData.coins;
        }
        function earnCoins(amount) {
            saveData.coins += amount;
            saveGame();
            const pop = document.createElement('div');
            pop.className = 'coin-pop';
            pop.innerText = `+${amount} 💰`;
            pop.style.left = '50%';
            pop.style.top = '50%';
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 1000);
        }
        function showNotification(title, subtitle) {
            const el = document.getElementById('secret-unlock');
            el.innerHTML = `${title}<br><span id="secret-name" style="font-size:20px">${subtitle}</span>`;
            el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', 3000);
        }
        function unlockTrophy(id) {
            if (!saveData.trophies.includes(id)) {
                saveData.trophies.push(id);

                // Award Gacha Coins for special trophies
                const gachaCoinTrophies = ['first_blood', 'combo_master', 'survivor', 'perfect_victory', 'unlock_all', 'collector', 'unlock_meme'];
                if (gachaCoinTrophies.includes(id)) {
                    saveData.gachaCoins = (saveData.gachaCoins || 0) + 1;
                    showNotification("🎫 BONUS! 🎫", "+1 Gacha Coin from Trophy!");
                }

                saveGame();
                sfx.play('ult');
                showNotification("🏆 TROPHY UNLOCKED! 🏆", MASTER_TROPHY_LIST[id].name);
            }
        }
        const SHOP_ITEMS = [{
            id: 'yellowdude',
            name: 'UNLOCK YELLOW DUDE',
            cost: 1000,
            type: 'char'
        }, {
            id: 'chad',
            name: 'UNLOCK CHAD',
            cost: 500,
            type: 'char'
        }, {
            id: 'troll',
            name: 'UNLOCK TROLL',
            cost: 500,
            type: 'char'
        }, {
            id: 'ocralito',
            name: 'UNLOCK OCRALITO',
            cost: 500,
            type: 'char'
        }, {
            id: 'mechabara',
            name: 'UNLOCK MECHA-BARA',
            cost: 1500,
            type: 'char'
        }, {
            id: 'tophat',
            name: 'TOP HAT',
            cost: 200,
            type: 'cosmetic',
            icon: '🎩'
        }, {
            id: 'shades',
            name: 'SHADES',
            cost: 300,
            type: 'cosmetic',
            icon: '🕶️'
        }, {
            id: 'crown',
            name: 'CROWN',
            cost: 1000,
            type: 'cosmetic',
            icon: '👑'
        }, {
            id: 'sandevistan_zeta',
            name: 'ZETATECH SANDY',
            cost: 1500,
            type: 'cyber',
            subtype: 'core',
            desc: 'Speed Boost'
        }, {
            id: 'sandevistan_dynlar',
            name: 'DYNAR SANDY',
            cost: 2000,
            type: 'cyber',
            subtype: 'core',
            desc: 'Time Slow'
        }, {
            id: 'cyberdeck_militech',
            name: 'MILITECH DECK',
            cost: 1200,
            type: 'cyber',
            subtype: 'core',
            desc: 'Quickhacks'
        }, {
            id: 'sandevistan_apogee',
            name: 'APOGEE SANDY',
            cost: 0,
            type: 'cyber',
            subtype: 'core',
            desc: '90% Time Slow + Kill Reset',
            quest: true
        }, {
            id: 'mantis_blades',
            name: 'MANTIS BLADES',
            cost: 1800,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Dash Slash Combo (Side B)'
        }, {
            id: 'david_sandevistan',
            name: "DAVID'S SANDY",
            cost: 0,
            type: 'cyber',
            subtype: 'core',
            desc: '95% Slow + Speed Boost Self',
            quest: true
        }, {
            id: 'maine_arm',
            name: "MAINE'S ARM",
            cost: 0,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Gorilla Arm + Ground Pound',
            quest: true
        }, {
            id: 'lucy_cyberdeck',
            name: "LUCY'S DECK",
            cost: 0,
            type: 'cyber',
            subtype: 'core',
            desc: 'Enhanced Quickhacks + Breach',
            quest: true
        }, {
            id: 'maxtac_mantis',
            name: 'MAXTAC MANTIS',
            cost: 0,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Thermal Mantis Blades + Dash',
            quest: true
        }, {
            id: 'el_dorado',
            name: 'EL DORADO',
            cost: 0,
            type: 'cyber',
            subtype: 'software',
            desc: 'ICONIC SOFTWARE — Adaptive ICE shield absorbs 1 hit every 20s. Blocked hits create a shockwave pushing enemies back.',
            quest: true
        }, {
            id: 'pride',
            name: 'PRIDE',
            cost: 0,
            type: 'cyber',
            subtype: 'software',
            desc: 'ICONIC PISTOL — Quick Draw: Rapid-fire pistol. Tap Side Special to shoot while moving. 8 rounds, auto-reloads.',
            quest: true
        }, {
            id: 'gold',
            name: 'GOLD SKIN',
            cost: 2000,
            type: 'skin'
        },
        // ===== CYBERWARE TIER 2 UPGRADES =====
        {
            id: 'sandevistan_zeta_mk2',
            name: 'ZETATECH MK2',
            cost: 3000,
            type: 'cyber',
            subtype: 'core',
            desc: '150% Speed Boost + 30% Time Slow on enemies',
            tier: 2,
            requires: 'sandevistan_zeta',
            requiresStreetCred: 10
        }, {
            id: 'sandevistan_dynlar_mk2',
            name: 'DYNLAR MK2',
            cost: 4000,
            type: 'cyber',
            subtype: 'core',
            desc: '85% Time Slow + 6s Duration',
            tier: 2,
            requires: 'sandevistan_dynlar',
            requiresStreetCred: 15
        }, {
            id: 'cyberdeck_militech_mk2',
            name: 'MILITECH MK2',
            cost: 3500,
            type: 'cyber',
            subtype: 'core',
            desc: 'Enhanced Quickhacks + Faster Upload',
            tier: 2,
            requires: 'cyberdeck_militech',
            requiresStreetCred: 10
        }, {
            id: 'mantis_blades_mk2',
            name: 'MANTIS MK2',
            cost: 3500,
            type: 'cyber',
            subtype: 'arm',
            desc: '5-Hit Dash Combo + Bleed DOT',
            tier: 2,
            requires: 'mantis_blades',
            requiresStreetCred: 15
        },
        // ===== PATCH 1.1 — CHROME OVERLOAD =====
        // NEW CORE CYBERWARE
        {
            id: 'berserk_militech',
            name: 'MILITECH BERSERK',
            cost: 1800,
            type: 'cyber',
            subtype: 'core',
            desc: 'Rage Mode: +50% DMG, reduced knockback taken, 5s duration'
        }, {
            id: 'netwatch_netdriver',
            name: 'NETWATCH NETDRIVER',
            cost: 2500,
            type: 'cyber',
            subtype: 'core',
            desc: 'Premium Cyberdeck — All Quickhacks + Faster Cooldown'
        },
        // NEW ARM CYBERWARE
        {
            id: 'gorilla_arms',
            name: 'GORILLA ARMS',
            cost: 1200,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Heavy Punches + Charged Power Attack'
        }, {
            id: 'monowire',
            name: 'MONOWIRE',
            cost: 2200,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Long-Range Whip — Charges while idle for bonus DMG'
        }, {
            id: 'projectile_launch',
            name: 'PROJECTILE LAUNCHER',
            cost: 2800,
            type: 'cyber',
            subtype: 'arm',
            desc: 'Arm Rocket — Fires explosive missile with AoE blast'
        },
        // NEW SOFTWARE CYBERWARE
        {
            id: 'kerenzikov',
            name: 'KERENZIKOV',
            cost: 1500,
            type: 'cyber',
            subtype: 'software',
            desc: 'Auto Bullet-Time — Brief slow effect when dodging near attacks'
        }, {
            id: 'optical_camo',
            name: 'OPTICAL CAMO',
            cost: 2000,
            type: 'cyber',
            subtype: 'software',
            desc: 'Stealth Mode — Invisible 3s, first attack from stealth does 2x DMG'
        }, {
            id: 'subdermal_armor',
            name: 'SUBDERMAL ARMOR',
            cost: 1000,
            type: 'cyber',
            subtype: 'software',
            desc: 'Passive — Reduces all incoming damage by 20%'
        },
        // NEW LEGS CYBERWARE
        {
            id: 'reinforced_tendons',
            name: 'REINFORCED TENDONS',
            cost: 1200,
            type: 'cyber',
            subtype: 'legs',
            desc: 'Double Jump — Press jump again mid-air'
        }, {
            id: 'fortified_ankles',
            name: 'FORTIFIED ANKLES',
            cost: 1500,
            type: 'cyber',
            subtype: 'legs',
            desc: 'Charge Jump — Hold jump to launch super high'
        }, {
            id: 'lynx_paws',
            name: 'LYNX PAWS',
            cost: 1800,
            type: 'cyber',
            subtype: 'legs',
            desc: 'Silent Runner — +20% move speed, reduced hitbox'
        }];
        function openShop() {
            sfx.init();
            music.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('shop-screen').classList.remove('hidden');
            gameState = 'SHOP';
            renderShop();
            music.play('MENU');
            loop();
        }
        function closeShop() {
            document.getElementById('shop-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            gameState = 'TITLE';
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear any shop artifacts
        }
        function cycleShopChar(dir) {
            shopCharIndex = (shopCharIndex + dir + CHARACTERS.length) % CHARACTERS.length;
            document.getElementById('shop-char-name').innerText = CHARACTERS[shopCharIndex].name;
            sfx.play('coin');
        }
        function renderShop() {
            const grid = document.getElementById('shop-grid');
            grid.innerHTML = '';
            const discount = getShopDiscount();
            // Update discount display
            const discountEl = document.getElementById('shop-discount');
            if (discountEl) discountEl.innerText = discount > 0 ? `STREET CRED DISCOUNT: -${discount}%` : '';
            SHOP_ITEMS.forEach(item => {
                // Hide quest-only items from shop
                if (item.quest) return;
                // Hide tier 2 items if requirements not met
                if (item.tier === 2) {
                    if (!saveData.cyberware || !saveData.cyberware.includes(item.requires)) return;
                    const credLevel = saveData.streetCred ? saveData.streetCred.level : 1;
                    if (credLevel < (item.requiresStreetCred || 1)) return;
                }
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (shopSelectedItem && shopSelectedItem.id === item.id) div.classList.add('selected');
                let owned = !1;
                if (item.type === 'char' && saveData.unlocks.includes(item.id)) owned = !0;
                if (item.type === 'skin' && saveData.goldMode) owned = !0;
                if (item.type === 'cosmetic' && saveData.cosmetics.includes(item.id)) owned = !0;
                let iconHtml = '';
                const charForItem = CHARACTERS.find(c => c.id === item.id);
                if (item.type === 'char' && (characterSprites[item.id] || (charForItem && charForItem.icon))) {
                    if (characterSprites[item.id]) {
                        iconHtml = `<canvas width="16" height="16" id="shop-sprite-${item.id}"></canvas>`;
                    } else {
                        iconHtml = `<div style="font-size:30px">${charForItem.icon}</div>`;
                    }
                } else {
                    iconHtml = `<div style="font-size:30px">${item.icon || (owned ? '✅' : '🔒')}</div>`;
                }
                let content = `${iconHtml}<div style="font-size:10px">${item.tier === 2 ? '<span style="color:#ffd700">★</span> ' : ''}${item.name}</div>`;
                if (!owned) {
                    const actualCost = Math.floor(item.cost * (1 - discount / 100));
                    if (discount > 0 && item.cost > 0) {
                        content += `<div class="shop-cost"><s style="color:#666">${item.cost}</s> ${actualCost}</div>`;
                    } else {
                        content += `<div class="shop-cost">${item.cost}</div>`;
                    }
                } else {
                    content += `<div class="shop-cost" style="color:var(--on)">OWNED</div>`;
                }
                div.innerHTML = content;
                div.onclick = () => selectShopItem(item);
                grid.appendChild(div);
                if (item.type === 'char' && characterSprites[item.id]) {
                    const miniCanvas = document.getElementById(`shop-sprite-${item.id}`);
                    if (miniCanvas) {
                        const miniCtx = miniCanvas.getContext('2d');
                        miniCtx.imageSmoothingEnabled = !1;
                        const sprite = characterSprites[item.id];
                        if (sprite.idle && sprite.idle[0]) {
                            miniCtx.drawImage(sprite.idle[0], 0, 0, miniCanvas.width, miniCanvas.height);
                        } else if (sprite) {
                            miniCtx.drawImage(sprite, 0, 0, miniCanvas.width, miniCanvas.height);
                        }
                    }
                }
            });
            updateBuyButton();
        }
        function selectShopItem(item) {
            shopSelectedItem = item;
            renderShop();
            updateBuyButton();
            sfx.play('coin');
        }
        function updateBuyButton() {
            const btn = document.getElementById('buy-btn');
            const info = document.getElementById('shop-item-info');
            if (!shopSelectedItem) {
                btn.style.display = 'none';
                info.innerText = "SELECT ITEM";
                return;
            }
            btn.style.display = 'block';
            let owned = !1;
            if (shopSelectedItem.type === 'char' && saveData.unlocks.includes(shopSelectedItem.id)) owned = !0;
            if (shopSelectedItem.type === 'skin' && saveData.goldMode) owned = !0;
            if (shopSelectedItem.type === 'cosmetic' && saveData.cosmetics.includes(shopSelectedItem.id)) owned = !0;
            if (shopSelectedItem.type === 'cyber') {
                if (!saveData.cyberware) saveData.cyberware = [];
                if (saveData.cyberware.includes(shopSelectedItem.id)) owned = !0;
            }

            if (!owned) {
                const discount = getShopDiscount();
                const actualCost = Math.floor(item.cost * (1 - discount / 100));
                btn.innerText = "BUY";
                btn.className = "btn-buy";
                btn.onclick = buyOrEquip;
                if (discount > 0 && item.cost > 0) {
                    info.innerText = `COST: ${actualCost} COINS (${discount}% OFF)`;
                } else {
                    info.innerText = `COST: ${item.cost} COINS`;
                }
            } else {
                if (shopSelectedItem.type === 'cosmetic') {
                    if (equippedCosmetic === shopSelectedItem.id) {
                        btn.innerText = "UNEQUIP";
                        btn.className = "btn-unequip";
                    } else {
                        btn.innerText = "EQUIP";
                        btn.className = "btn-equip";
                    }
                    btn.onclick = buyOrEquip;
                    info.innerText = "OWNED";
                } else if (shopSelectedItem.type === 'cyber') {
                    info.innerText = "IN INVENTORY";
                    btn.style.display = 'none';
                } else {
                    info.innerText = "UNLOCKED";
                    btn.style.display = 'none';
                }
            }
        }
        function buyOrEquip() {
            const item = shopSelectedItem;
            let owned = !1;
            if (item.type === 'char' && saveData.unlocks.includes(item.id)) owned = !0;
            if (item.type === 'skin' && saveData.goldMode) owned = !0;
            if (item.type === 'cosmetic' && saveData.cosmetics.includes(item.id)) owned = !0;
            if (item.type === 'cyber') {
                if (!saveData.cyberware) saveData.cyberware = [];
                if (saveData.cyberware.includes(item.id)) owned = !0;
            }

            if (!owned) {
                const discount = getShopDiscount();
                const actualCost = Math.floor(item.cost * (1 - discount / 100));
                if (saveData.coins >= actualCost) {
                    saveData.coins -= actualCost;
                    if (item.type === 'char') {
                        saveData.unlocks.push(item.id);
                        if (item.id === 'chad') unlockTrophy('unlock_chad');
                        if (item.id === 'mechabara') unlockTrophy('unlock_mechabara');
                        if (item.id === 'bluedude') unlockTrophy('unlock_bluedude');
                        if (item.id === 'yellowdude') {
                            document.getElementById('cyberware-btn').style.display = 'block';
                            const storyBtn = document.getElementById('story-btn');
                            if (storyBtn) storyBtn.style.display = 'block';
                            showNotification("NEW SYSTEM DETECTED", "Cyberware & Story Mode Unlocked");
                        }
                    }
                    if (item.type === 'skin') {
                        saveData.goldMode = !0;
                        unlockTrophy('buy_gold');
                    }
                    if (item.type === 'cosmetic') {
                        saveData.cosmetics.push(item.id);
                        equippedCosmetic = item.id;
                    }
                    if (item.type === 'cyber') {
                        saveData.cyberware.push(item.id);
                        showNotification("HARDWARE ACQUIRED", "Added to Cyberware Inventory");
                    }
                    sfx.play('ult');
                    saveGame();
                    renderShop();
                } else {
                    sfx.play('break');
                }
            } else if (item.type === 'cosmetic') {
                if (equippedCosmetic === item.id) equippedCosmetic = null;
                else equippedCosmetic = item.id;
                sfx.play('shield');
                saveGame();
                renderShop();
            }
        }

        // Quickhack Menu System (Canvas-based, drawn ON target)
        let quickhackUser = null;
        let quickhackMenuOpen = false;
        let quickhackTarget = null;
        let quickhackSelectedIndex = 0;
        let quickhackAvailable = [];
        const QUICKHACKS = [
            { id: 'short_circuit', name: 'SHORT CIRCUIT', icon: '\u26a1', color: '#0ff', desc: 'SHOCK DMG' },
            { id: 'overheat', name: 'OVERHEAT', icon: '\ud83d\udd25', color: '#f80', desc: 'BURN AOE' },
            { id: 'synapse_burnout', name: 'SYNAPSE BURNOUT', icon: '\ud83e\udde0', color: '#f0f', desc: 'HIGH DMG' },
            { id: 'contagion', name: 'CONTAGION', icon: '\u2620\ufe0f', color: '#0f0', desc: 'POISON ALL' },
            { id: 'system_reset', name: 'SYSTEM RESET', icon: '\ud83d\udd04', color: '#f55', desc: 'EXECUTE', premium: true },
            { id: 'cyberpsychosis', name: 'CYBERPSYCHOSIS', icon: '\ud83e\udd2f', color: '#f0f', desc: 'TURN ENEMY', premium: true },
            { id: 'weapon_glitch', name: 'WEAPON GLITCH', icon: '\ud83d\udeab', color: '#ff0', desc: 'DISARM 3S', premium: true }
        ];

        function openQuickhackMenu(fighter) {
            quickhackUser = fighter;
            quickhackSelectedIndex = 0;
            // Filter quickhacks based on deck type
            const core = saveData.cyberSlots ? saveData.cyberSlots.core : null;
            const hasPremium = (core === 'netwatch_netdriver' || core === 'lucy_cyberdeck');
            quickhackAvailable = QUICKHACKS.filter(q => !q.premium || hasPremium);
            // Find nearest enemy as target
            let nearest = null;
            let minDist = Infinity;
            players.forEach(p => {
                if (p.id !== fighter.id && p.stocks > 0) {
                    const dist = Math.abs(p.x - fighter.x) + Math.abs(p.y - fighter.y);
                    if (dist < minDist) { minDist = dist; nearest = p; }
                }
            });
            if (!nearest) return; // No targets
            quickhackTarget = nearest;
            quickhackMenuOpen = true;
        }

        function closeQuickhackMenu() {
            quickhackMenuOpen = false;
            quickhackUser = null;
            quickhackTarget = null;
        }

        function drawQuickhackMenu(ctx) {
            if (!quickhackMenuOpen || !quickhackTarget || !quickhackUser) return;
            const t = quickhackTarget;
            // Draw in world coords (camera transform already applied)
            const cx = t.x + t.w / 2;
            const baseY = t.y - 20;

            const boxW = 120;
            const rowH = 18;
            const pad = 4;
            const totalH = quickhackAvailable.length * rowH + pad * 2 + 16; // +16 for header
            const boxX = cx - boxW / 2;
            const boxY = baseY - totalH;

            // Semi-transparent background
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#000';
            ctx.fillRect(boxX - 2, boxY - 2, boxW + 4, totalH + 4);
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(boxX - 2, boxY - 2, boxW + 4, totalH + 4);

            // Header
            ctx.globalAlpha = 1;
            const core = saveData.cyberSlots ? saveData.cyberSlots.core : null;
            ctx.fillStyle = core === 'lucy_cyberdeck' ? '#f0f' : (core === 'netwatch_netdriver' ? '#f55' : '#0ff');
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            const headerText = core === 'lucy_cyberdeck' ? "// LUCY'S DECK" : (core === 'netwatch_netdriver' ? '// NETWATCH' : '// QUICKHACK');
            ctx.fillText(headerText, cx, boxY + 10);

            // Hacks list
            for (let i = 0; i < quickhackAvailable.length; i++) {
                const qh = quickhackAvailable[i];
                const rowY = boxY + 16 + pad + i * rowH;

                // Highlight selected
                if (i === quickhackSelectedIndex) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = qh.color;
                    ctx.fillRect(boxX, rowY, boxW, rowH - 2);
                }

                ctx.globalAlpha = 1;
                ctx.fillStyle = (i === quickhackSelectedIndex) ? '#fff' : qh.color;
                ctx.font = '7px monospace';
                ctx.textAlign = 'left';
                ctx.fillText((i + 1) + ' ' + qh.icon + ' ' + qh.name, boxX + 4, rowY + 11);
            }

            // Cancel hint
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#f55';
            ctx.font = '6px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('ESC:CANCEL  ENTER:SELECT', cx, boxY + totalH + 8);

            // Targeting line from user to target
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = '#0ff';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(quickhackUser.x + quickhackUser.w / 2, quickhackUser.y + quickhackUser.h / 2);
            ctx.lineTo(cx, t.y + t.h / 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Target indicator ring
            ctx.globalAlpha = 0.5 + 0.3 * Math.sin(Date.now() * 0.005);
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, t.y + t.h / 2, Math.max(t.w, t.h) * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function selectQuickhack(hack) {
            if (!quickhackUser || !quickhackTarget) { closeQuickhackMenu(); return; }
            const fighter = quickhackUser;
            const target = quickhackTarget;
            const isLucy = saveData.cyberSlots && saveData.cyberSlots.core === 'lucy_cyberdeck';
            const isMK2 = saveData.cyberSlots && saveData.cyberSlots.core === 'cyberdeck_militech_mk2';
            const dmgMult = isLucy ? 1.5 : (isMK2 ? 1.3 : 1); // Lucy 50%, MK2 30% more damage
            const stunMult = isLucy ? 1.3 : (isMK2 ? 1.2 : 1);
            closeQuickhackMenu();

            sfx.play('ult');
            fighter.cd = isLucy ? 45 : (isMK2 ? 50 : 60); // Lucy fastest, MK2 faster

            if (isLucy) {
                particles.push({ x: fighter.x + fighter.w/2, y: fighter.y - 10, text: "LUCY'S DECK", life: 30, vy: -1, color: '#f0f' });
            }

            switch(hack) {
                case 'short_circuit':
                    // Guaranteed hit: stun + shock damage
                    if (target) {
                        target.hit((target.x > fighter.x ? 5 : -5), -5, Math.round(8 * dmgMult));
                        target.stun = Math.round(60 * stunMult);
                        particles.push({ x: target.x + target.w/2, y: target.y, text: "⚡ SHORT CIRCUIT", life: 60, vy: -1, color: '#0ff' });
                        // Electric VFX on target
                        for (let i = 0; i < 8; i++) {
                            particles.push({ x: target.x + (Math.random()-0.5)*30, y: target.y + (Math.random()-0.5)*30, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 20, color: '#0ff', size: 3 });
                        }
                    }
                    sfx.play('break');
                    break;
                case 'overheat':
                    // Guaranteed hit: burn DOT on target
                    if (target) {
                        target.hit(0, -2, Math.round(5 * dmgMult));
                        target.burning = true;
                        target.burnTimer = Math.round(120 * dmgMult);
                        target.burnOwner = fighter.id;
                        particles.push({ x: target.x + target.w/2, y: target.y, text: "🔥 OVERHEAT", life: 60, vy: -1, color: '#f80' });
                        for (let i = 0; i < 10; i++) {
                            particles.push({ x: target.x + (Math.random()-0.5)*40, y: target.y + (Math.random()-0.5)*40, vx: (Math.random()-0.5)*3, vy: -Math.random()*3, life: 30, color: Math.random() > 0.5 ? '#ff4400' : '#ffff00', size: 4 });
                        }
                    }
                    sfx.play('ult');
                    break;
                case 'synapse_burnout':
                    // Guaranteed hit: massive single target damage
                    if (target) {
                        target.hit((target.x > fighter.x ? 10 : -10), -15, Math.round(35 * dmgMult));
                        target.stun = Math.round(90 * stunMult);
                        particles.push({ x: target.x + target.w/2, y: target.y, text: "🧠 BURNOUT!", life: 60, vy: -1, color: '#f0f' });
                        for (let i = 0; i < 12; i++) {
                            particles.push({ x: target.x + (Math.random()-0.5)*40, y: target.y + (Math.random()-0.5)*40, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 15, color: '#f0f', size: 4 });
                        }
                    }
                    sfx.play('break');
                    fighter.cd = 120;
                    break;
                case 'contagion':
                    // Guaranteed hit: poison all opponents
                    players.forEach(p => {
                        if (p.id !== fighter.id && p.stocks > 0) {
                            p.poisoned = true;
                            p.poisonTimer = Math.round(180 * dmgMult);
                            p.poisonOwner = fighter.id;
                            particles.push({ x: p.x + p.w/2, y: p.y, text: "☠️ INFECTED", life: 60, vy: -1, color: '#0f0' });
                            for (let i = 0; i < 6; i++) {
                                particles.push({ x: p.x + (Math.random()-0.5)*30, y: p.y + (Math.random()-0.5)*30, vx: 0, vy: -1, life: 25, color: '#0f0', size: 3 });
                            }
                        }
                    });
                    sfx.play('break');
                    fighter.cd = 100;
                    break;
                case 'system_reset':
                    // Instant KO if target is above 100%, otherwise big damage
                    if (target) {
                        if (target.pct >= 100) {
                            // Execute!
                            target.hit((target.x > fighter.x ? 20 : -20), -20, 50);
                            particles.push({ x: target.x + target.w/2, y: target.y, text: "🔄 SYSTEM RESET", life: 80, vy: -1, color: '#f55' });
                            particles.push({ x: target.x + target.w/2, y: target.y + 20, text: "💀 FLATLINED", life: 60, vy: -2, color: '#f00' });
                            sfx.play('break');
                            // Glitch VFX
                            for (let i = 0; i < 15; i++) {
                                particles.push({ x: target.x + (Math.random()-0.5)*50, y: target.y + (Math.random()-0.5)*50, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 20, color: '#f00', size: 4 });
                            }
                        } else {
                            // Not enough damage to execute — weaker effect
                            target.hit((target.x > fighter.x ? 3 : -3), -3, Math.round(10 * dmgMult));
                            target.stun = 40;
                            particles.push({ x: target.x + target.w/2, y: target.y, text: "🔄 RESET FAILED", life: 50, vy: -1, color: '#f55' });
                            particles.push({ x: target.x + target.w/2, y: target.y + 15, text: `${target.pct}% < 100%`, life: 40, vy: -1.5, color: '#888' });
                        }
                    }
                    fighter.cd = 150;
                    break;
                case 'cyberpsychosis':
                    // Target attacks nearest ally for 3 seconds
                    if (target) {
                        target.cyberpsychosis = true;
                        target.cyberpsychosisTimer = 180; // 3 seconds
                        target.cyberpsychosisOwner = fighter.id;
                        target.stun = 30; // Brief stun first
                        particles.push({ x: target.x + target.w/2, y: target.y, text: "🤯 CYBERPSYCHOSIS", life: 80, vy: -1, color: '#f0f' });
                        // Glitch static around target
                        for (let i = 0; i < 12; i++) {
                            particles.push({ x: target.x + (Math.random()-0.5)*40, y: target.y + (Math.random()-0.5)*40, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 25, color: Math.random() > 0.5 ? '#f0f' : '#f00', size: 3 });
                        }
                    }
                    sfx.play('break');
                    fighter.cd = 140;
                    break;
                case 'weapon_glitch':
                    // Disable target's attacks for 3 seconds
                    if (target) {
                        target.weaponGlitched = true;
                        target.weaponGlitchTimer = 180; // 3 seconds
                        particles.push({ x: target.x + target.w/2, y: target.y, text: "🚫 WEAPON GLITCH", life: 60, vy: -1, color: '#ff0' });
                        // Sparks VFX
                        for (let i = 0; i < 8; i++) {
                            particles.push({ x: target.x + (Math.random()-0.5)*30, y: target.y + (Math.random()-0.5)*30, vx: (Math.random()-0.5)*3, vy: -Math.random()*2, life: 20, color: '#ff0', size: 2 });
                        }
                    }
                    sfx.play('ult');
                    fighter.cd = 110;
                    break;
            }
        }

        // Dynlar kill tracking for Apogee unlock
        let dynlarTotalKills = 0;

        function trackDynlarKill(killer) {
            if (killer && killer.dynlarActive && killer.stats.id === 'yellowdude') {
                if (!saveData.dynlarKills) saveData.dynlarKills = 0;
                saveData.dynlarKills++;
                dynlarTotalKills = saveData.dynlarKills;
                particles.push({ x: killer.x + killer.w / 2, y: killer.y - 20, text: `DYNLAR KILL ${saveData.dynlarKills}/10`, life: 60, vy: -1, color: '#0ff' });

                if (saveData.dynlarKills >= 10 && !saveData.trophies.includes('dynlar_10_kills')) {
                    unlockTrophy('dynlar_10_kills');
                    // Award Apogee Sandevistan
                    if (!saveData.cyberware) saveData.cyberware = [];
                    if (!saveData.cyberware.includes('sandevistan_apogee')) {
                        saveData.cyberware.push('sandevistan_apogee');
                        showNotification("🏆 CHROME ASSASSIN", "APOGEE SANDEVISTAN UNLOCKED!");
                    }
                    saveGame();
                }
            }
            // Also track for Apogee cooldown reset
            if (killer && killer.apogeeActive && killer.stats.id === 'yellowdude') {
                killer.cd = 0; // Reset cooldown on kill!
                particles.push({ x: killer.x + killer.w / 2, y: killer.y - 30, text: "⏱️ CD RESET!", life: 40, vy: -2, color: '#f0f' });
                sfx.play('coin');
            }
        }

        let cyberSelectedItem = null;

        // ===== EDGERUNNER STORYLINE QUEST SYSTEM =====
        let davidSandyAfterimages = []; // For red afterimage effect
        
        const EDGERUNNER_QUESTS = [
            {
                id: 'ep1_gloria',
                num: 1,
                title: "LET YOU DOWN",
                subtitle: "Episode 1",
                desc: "Gloria Martinez is gone. All she left behind was a military-grade Sandevistan. Time to use it.",
                enemy: 'amogus',
                enemyName: 'ARASAKA AGENT',
                map: 'nightcity',
                stocks: 2,
                reward: 'david_sandevistan',
                rewardName: "DAVID'S SANDEVISTAN",
                coins: 500,
                dialogue_pre: [
                    { speaker: "GLORIA", portrait: "", text: "David... promise me you'll make it. Promise me you'll get to the top..." },
                    { speaker: "DAVID", portrait: "", text: "Mom...? MOM?! No... no no no..." },
                    { speaker: "???", portrait: "", text: "The implant your mother stole... a military-grade Sandevistan. It's in your bag." },
                    { speaker: "DAVID", portrait: "", text: "If the system took everything from me... then I'll take the fight to them." },
                    { speaker: "DAVID", portrait: "", text: "Installing the Sandevistan. Let's see what this thing can do." },
                    { speaker: "SYSTEM", portrait: "", text: "WARNING: Arasaka security agent detected. They want the implant back." }
                ],
                dialogue_post: [
                    { speaker: "DAVID", portrait: "", text: "The Sandevistan... it's incredible. Everything slows down around me." },
                    { speaker: "DAVID", portrait: "", text: "Mom... I won't let your sacrifice be for nothing." },
                    { speaker: "SYSTEM", portrait: "", text: "DAVID'S SANDEVISTAN installed. The chrome is yours now, choom." }
                ]
            },
            {
                id: 'ep2_maine',
                num: 2,
                title: "RUNNING WITH THE CREW",
                subtitle: "Episode 2",
                desc: "Maine's crew needs a new runner. Prove yourself on a gig and earn his trust and his iconic gorilla arms.",
                enemy: 'chad',
                enemyName: 'MILITECH ENFORCER',
                map: 'badlands',
                stocks: 3,
                reward: 'maine_arm',
                rewardName: "MAINE'S ARM",
                coins: 750,
                dialogue_pre: [
                    { speaker: "MAINE", portrait: "", text: "So you're the kid with the Sandy. Gloria's boy, huh? She was good people." },
                    { speaker: "DAVID", portrait: "", text: "I need work. I need to survive in this city." },
                    { speaker: "MAINE", portrait: "", text: "Alright kid, here's the deal. We got a gig. Militech convoy, heavy security." },
                    { speaker: "DORIO", portrait: "", text: "Maine, you sure about this? He's just a kid..." },
                    { speaker: "MAINE", portrait: "", text: "Gloria trusted him with military chrome. That's good enough for me." },
                    { speaker: "MAINE", portrait: "", text: "Take down their enforcer and you're in the crew. Here, take my spare gorilla arms." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Militech Enforcer to join Maine's crew!" }
                ],
                dialogue_post: [
                    { speaker: "MAINE", portrait: "", text: "Not bad, kid! Not bad at all. You're one of us now." },
                    { speaker: "MAINE", portrait: "", text: "These gorilla arms served me well. They're yours now. Take care of em." },
                    { speaker: "LUCY", portrait: "", text: "...Interesting. You're different from the others." },
                    { speaker: "SYSTEM", portrait: "", text: "MAINE'S ARM acquired. Gorilla Arm plus Ground Pound unlocked!" }
                ]
            },
            {
                id: 'ep3_lucy',
                num: 3,
                title: "GIRL ON FIRE",
                subtitle: "Episode 3",
                desc: "Lucy needs backup on a Netrunning gig. An Arasaka netrunner has locked onto her signal. Protect her and earn her trust.",
                enemy: 'mechabara',
                enemyName: 'ARASAKA NETRUNNER',
                map: 'arasaka_district',
                stocks: 3,
                reward: 'lucy_cyberdeck',
                rewardName: "LUCY'S CYBERDECK",
                coins: 1000,
                dialogue_pre: [
                    { speaker: "LUCY", portrait: "", text: "David. I need your help. Arasaka's onto me. They've sent a netrunner." },
                    { speaker: "DAVID", portrait: "", text: "What did you do?" },
                    { speaker: "LUCY", portrait: "", text: "I stole data from them. Data about the moon... about getting out of this city." },
                    { speaker: "LUCY", portrait: "", text: "The moon, David. That's where I want to go someday. Away from all this." },
                    { speaker: "DAVID", portrait: "", text: "Then I'll make sure you get there. Nobody's touching you." },
                    { speaker: "LUCY", portrait: "", text: "Take my backup Cyberdeck. You'll need it against their netrunner." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Arasaka Netrunner to protect Lucy!" }
                ],
                dialogue_post: [
                    { speaker: "LUCY", portrait: "", text: "You really are something else, David Martinez." },
                    { speaker: "DAVID", portrait: "", text: "Lucy... I promise I'll get you to the moon." },
                    { speaker: "LUCY", portrait: "", text: "Keep the Cyberdeck. You handle it better than most netrunners I know." },
                    { speaker: "SYSTEM", portrait: "", text: "LUCY'S CYBERDECK acquired. Enhanced Quickhacks plus Breach Protocol unlocked!" }
                ]
            },
            {
                id: 'ep4_maxtac',
                num: 4,
                title: "MY MOON MY MAN",
                subtitle: "Episode 4 - FINALE",
                desc: "Arasaka has sent MaxTac after you. This is the final showdown. Maine's gone. The crew is counting on you. Fight for Lucy. Fight for the moon.",
                enemy: 'gps',
                enemyName: 'MAXTAC COMMANDER',
                map: 'arasaka_tower',
                stocks: 4,
                reward: 'maxtac_mantis',
                rewardName: "MAXTAC MANTIS BLADES",
                coins: 1500,
                dialogue_pre: [
                    { speaker: "FALCO", portrait: "", text: "David... MaxTac is coming. The big guns. This ain't no regular gig." },
                    { speaker: "DAVID", portrait: "", text: "Maine... Dorio... Pilar... I won't let more people die." },
                    { speaker: "KIWI", portrait: "", text: "The Arasaka cyberskeleton data is uploaded. This is it, David." },
                    { speaker: "LUCY", portrait: "", text: "David, don't do this. Please. You don't have to be a hero." },
                    { speaker: "DAVID", portrait: "", text: "I'm not doing this to be a hero, Lucy. I'm doing this so you can reach the moon." },
                    { speaker: "DAVID", portrait: "", text: "I promised Mom I'd make it to the top. This is what I was meant to do." },
                    { speaker: "SYSTEM", portrait: "", text: "FINAL MISSION: Defeat the MaxTac Commander!" }
                ],
                dialogue_post: [
                    { speaker: "DAVID", portrait: "", text: "It's... it's over. MaxTac is down." },
                    { speaker: "FALCO", portrait: "", text: "Kid... you actually did it. Maine would be proud." },
                    { speaker: "LUCY", portrait: "", text: "David... thank you. For everything." },
                    { speaker: "DAVID", portrait: "", text: "Go see the moon for me, Lucy. That's all I ever wanted." },
                    { speaker: "SYSTEM", portrait: "", text: "MAXTAC MANTIS BLADES acquired. The story of David Martinez lives on." },
                    { speaker: "SYSTEM", portrait: "", text: "EDGERUNNER STORYLINE COMPLETE! All quest cyberware unlocked!" }
                ]
            }
        ];

        // ===== SIDE QUESTS (unlock after each main quest) =====
        const SIDE_QUESTS = [
            // AFTER EPISODE 1
            {
                id: 'side_convoy_heist',
                afterQuest: 'ep1_gloria',
                num: '1A',
                title: "CONVOY HEIST",
                subtitle: "Side Gig",
                desc: "A Militech transport is moving through the Badlands. Jack it and sell the goods to a fixer.",
                enemy: 'amogus',
                enemyName: 'MILITECH GUARD',
                map: 'badlands',
                stocks: 2,
                coins: 300,
                dialogue_pre: [
                    { speaker: "FIXER", portrait: "", text: "Got a gig for you, kid. Militech convoy rolling through the Badlands." },
                    { speaker: "FIXER", portrait: "", text: "Take out the guard, grab the cargo. Easy eddies." },
                    { speaker: "DAVID", portrait: "", text: "Easy money. I need it to survive out here." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Militech guard to complete the heist!" }
                ],
                dialogue_post: [
                    { speaker: "FIXER", portrait: "", text: "Clean work, choom. The eddies are wired to your account." },
                    { speaker: "DAVID", portrait: "", text: "What else you got?" }
                ]
            },
            {
                id: 'side_rescue_tanaka',
                afterQuest: 'ep1_gloria',
                num: '1B',
                title: "RESCUE JOB",
                subtitle: "Side Gig",
                desc: "A corpo techie defected from Arasaka. Help them escape before security catches up.",
                enemy: 'frog',
                enemyName: 'ARASAKA PURSUER',
                map: 'nightcity',
                stocks: 2,
                coins: 350,
                dialogue_pre: [
                    { speaker: "TECHIE", portrait: "", text: "Please... they're after me. I left Arasaka and they sent someone." },
                    { speaker: "DAVID", portrait: "", text: "Stay behind me. I'll handle this." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Arasaka pursuer to save the techie!" }
                ],
                dialogue_post: [
                    { speaker: "TECHIE", portrait: "", text: "Thank you... here, take this data shard. It might be useful." },
                    { speaker: "DAVID", portrait: "", text: "Get somewhere safe. Night City doesn't forgive." }
                ]
            },
            // AFTER EPISODE 2
            {
                id: 'side_bodyguard',
                afterQuest: 'ep2_maine',
                num: '2A',
                title: "BODYGUARD DETAIL",
                subtitle: "Side Gig",
                desc: "A fixer needs muscle for a client meeting in Arasaka territory. Keep them alive.",
                enemy: 'chad',
                enemyName: 'RIVAL MERC',
                map: 'arasaka_district',
                stocks: 2,
                coins: 400,
                dialogue_pre: [
                    { speaker: "MAINE", portrait: "", text: "Got a quick gig, kid. VIP needs a bodyguard for a meeting." },
                    { speaker: "DORIO", portrait: "", text: "Watch out. The rival crew hired their own muscle." },
                    { speaker: "DAVID", portrait: "", text: "Nobody gets through me." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the rival mercenary to protect the VIP!" }
                ],
                dialogue_post: [
                    { speaker: "MAINE", portrait: "", text: "Smooth work. The client's impressed. Bonus eddies for you." },
                    { speaker: "DAVID", portrait: "", text: "All in a day's work with Maine's crew." }
                ]
            },
            {
                id: 'side_netrunner_hunt',
                afterQuest: 'ep2_maine',
                num: '2B',
                title: "NETRUNNER HUNT",
                subtitle: "Side Gig",
                desc: "A rogue netrunner has been stealing data from the crew. Track them down in the district.",
                enemy: 'mechabara',
                enemyName: 'ROGUE NETRUNNER',
                map: 'arasaka_district',
                stocks: 2,
                coins: 450,
                dialogue_pre: [
                    { speaker: "KIWI", portrait: "", text: "Someone's been siphoning our data. Traced them to the corpo district." },
                    { speaker: "LUCY", portrait: "", text: "Be careful. Netrunners fight dirty." },
                    { speaker: "DAVID", portrait: "", text: "I'll bring them down." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the rogue netrunner!" }
                ],
                dialogue_post: [
                    { speaker: "KIWI", portrait: "", text: "Data secured. Nice work, David." },
                    { speaker: "LUCY", portrait: "", text: "You're getting good at this." }
                ]
            },
            // AFTER EPISODE 3
            {
                id: 'side_data_theft',
                afterQuest: 'ep3_lucy',
                num: '3A',
                title: "DATA HEIST",
                subtitle: "Side Gig",
                desc: "Lucy found a vulnerable Arasaka server. Break in, grab the data, get out.",
                enemy: 'amogus',
                enemyName: 'ARASAKA SYSADMIN',
                map: 'arasaka_district',
                stocks: 3,
                coins: 500,
                dialogue_pre: [
                    { speaker: "LUCY", portrait: "", text: "I found a hole in their firewall. Physical access point is nearby." },
                    { speaker: "LUCY", portrait: "", text: "Get past the sysadmin. I'll handle the ICE remotely." },
                    { speaker: "DAVID", portrait: "", text: "On it. Keep the line open." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Arasaka sysadmin to steal the data!" }
                ],
                dialogue_post: [
                    { speaker: "LUCY", portrait: "", text: "Got it. Terabytes of Arasaka research. This'll sell for a fortune." },
                    { speaker: "DAVID", portrait: "", text: "Or we keep it. Knowledge is power." }
                ]
            },
            {
                id: 'side_stealth_op',
                afterQuest: 'ep3_lucy',
                num: '3B',
                title: "GHOST PROTOCOL",
                subtitle: "Side Gig",
                desc: "Infiltrate an Arasaka black site. Someone inside has intel on MaxTac's next move.",
                enemy: 'gps',
                enemyName: 'BLACK OPS AGENT',
                map: 'arasaka_tower',
                stocks: 3,
                coins: 600,
                dialogue_pre: [
                    { speaker: "FALCO", portrait: "", text: "I got a contact inside Arasaka. Says MaxTac is planning something big." },
                    { speaker: "DAVID", portrait: "", text: "If we know their move before they make it..." },
                    { speaker: "FALCO", portrait: "", text: "Exactly. But the black site's crawling with ops. Watch yourself." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the black ops agent to retrieve the intel!" }
                ],
                dialogue_post: [
                    { speaker: "FALCO", portrait: "", text: "Intel's solid. MaxTac's mobilizing everything they've got." },
                    { speaker: "DAVID", portrait: "", text: "Then we'll be ready." },
                    { speaker: "LUCY", portrait: "", text: "David... please be careful." }
                ]
            },
            // AFTER EPISODE 4
            {
                id: 'side_black_ops',
                afterQuest: 'ep4_maxtac',
                num: '4A',
                title: "LOOSE ENDS",
                subtitle: "Side Gig",
                desc: "Remaining Arasaka forces are regrouping. Finish the job before they come back stronger.",
                enemy: 'chad',
                enemyName: 'ARASAKA COMMANDER',
                map: 'arasaka_tower',
                stocks: 3,
                coins: 700,
                dialogue_pre: [
                    { speaker: "FALCO", portrait: "", text: "Arasaka survivors are regrouping at the tower. We gotta clean this up." },
                    { speaker: "DAVID", portrait: "", text: "No loose ends. Never again." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Arasaka commander to finish the job!" }
                ],
                dialogue_post: [
                    { speaker: "FALCO", portrait: "", text: "That's the last of them. Night City's finally free... for now." },
                    { speaker: "DAVID", portrait: "", text: "It's never really over in this city." }
                ]
            },
            {
                id: 'side_assassination',
                afterQuest: 'ep4_maxtac',
                num: '4B',
                title: "FINAL CONTRACT",
                subtitle: "Side Gig",
                desc: "The ultimate fixer contract. An Arasaka board member who ordered the hit on your crew. This is personal.",
                enemy: 'gps',
                enemyName: 'ARASAKA EXECUTIVE',
                map: 'arasaka_district',
                stocks: 4,
                coins: 1000,
                dialogue_pre: [
                    { speaker: "FIXER", portrait: "", text: "Last contract, merc. Tanaka. The exec who greenlit everything." },
                    { speaker: "DAVID", portrait: "", text: "Maine. Dorio. Pilar. Gloria. This one's for all of them." },
                    { speaker: "FIXER", portrait: "", text: "He's got personal security. Top shelf stuff. Be ready." },
                    { speaker: "SYSTEM", portrait: "", text: "Defeat the Arasaka executive. Make them pay." }
                ],
                dialogue_post: [
                    { speaker: "DAVID", portrait: "", text: "It's done. They can't hurt anyone else." },
                    { speaker: "LUCY", portrait: "", text: "David... you did it. For all of them." },
                    { speaker: "SYSTEM", portrait: "", text: "All side gigs complete! A legendary software chrome has been unlocked..." }
                ]
            }
        ];

        let activeQuest = null;
        let activeSideQuest = null;
        let questDialogueQueue = [];
        let questDialogueCallback = null;
        let isQuestBattle = false;
        let isSideQuestBattle = false;

        function getQuestStatus(questId) {
            if (!saveData.questProgress) saveData.questProgress = {};
            if (saveData.questProgress[questId] === 'completed') return 'completed';
            // Check if previous quest is done
            const idx = EDGERUNNER_QUESTS.findIndex(q => q.id === questId);
            if (idx === 0) return saveData.questProgress[questId] || 'available';
            const prevQuest = EDGERUNNER_QUESTS[idx - 1];
            if (saveData.questProgress[prevQuest.id] === 'completed') {
                return saveData.questProgress[questId] || 'available';
            }
            return 'locked';
        }

        function getSideQuestStatus(sideQuestId) {
            if (!saveData.questProgress) saveData.questProgress = {};
            if (saveData.questProgress[sideQuestId] === 'completed') return 'completed';
            // Side quest available if its parent main quest is completed
            const sq = SIDE_QUESTS.find(s => s.id === sideQuestId);
            if (!sq) return 'locked';
            if (saveData.questProgress[sq.afterQuest] === 'completed') {
                return saveData.questProgress[sideQuestId] || 'available';
            }
            return 'locked';
        }

        function openStory() {
            sfx.init();
            music.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('story-screen').classList.remove('hidden');
            gameState = 'STORY';
            // Update street cred display
            const cred = getStreetCredLevel();
            const credEl = document.getElementById('street-cred-display');
            if (credEl) {
                const pct = cred.level >= 50 ? 100 : Math.floor((cred.xp / cred.xpNeeded) * 100);
                credEl.innerHTML = `STREET CRED: LV.${cred.level} <span style="color:#555">[${pct}%]</span> <span style="color:#666">|</span> <span style="color:#ffe135">DISCOUNT: ${getShopDiscount()}%</span>`;
            }
            renderQuestList();
        }

        function closeStory() {
            document.getElementById('story-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            gameState = 'TITLE';
        }

        function renderQuestList() {
            const list = document.getElementById('quest-list');
            list.innerHTML = '';

            // El Dorado progress tracker
            const totalSide = SIDE_QUESTS.length;
            const doneSide = SIDE_QUESTS.filter(sq => saveData.questProgress && saveData.questProgress[sq.id] === 'completed').length;
            const hasElDorado = saveData.cyberware && saveData.cyberware.includes('el_dorado');

            if (totalSide > 0) {
                const tracker = document.createElement('div');
                tracker.style.cssText = 'width:90%;max-width:700px;margin-bottom:10px;padding:8px 15px;background:rgba(0,255,136,0.05);border:1px solid #00ff88;font-family:Press Start 2P;font-size:8px;color:#00ff88;text-align:center;';
                if (hasElDorado) {
                    tracker.innerHTML = 'EL DORADO UNLOCKED - ICONIC SOFTWARE';
                    tracker.style.borderColor = '#ffd700';
                    tracker.style.color = '#ffd700';
                } else {
                    tracker.innerHTML = `SIDE GIGS: ${doneSide}/${totalSide} ${doneSide >= totalSide ? '- EL DORADO READY!' : ''}`;
                }
                list.appendChild(tracker);
            }

            EDGERUNNER_QUESTS.forEach(q => {
                const status = getQuestStatus(q.id);
                const card = document.createElement('div');
                card.className = 'quest-card ' + status;
                let statusText = '';
                let statusColor = '#666';
                if (status === 'completed') { statusText = '✅ DONE'; statusColor = '#0f0'; }
                else if (status === 'available') { statusText = '▶ START'; statusColor = '#ffe135'; }
                else if (status === 'locked') { statusText = '🔒 LOCKED'; statusColor = '#555'; }

                card.innerHTML = `
                    <div class="quest-num">${q.num}</div>
                    <div class="quest-info">
                        <div class="quest-title">${q.title}</div>
                        <div class="quest-desc">${q.subtitle} — ${q.desc.substring(0, 80)}${q.desc.length > 80 ? '...' : ''}</div>
                        <div class="quest-reward">REWARD: ${q.rewardName} + ${q.coins} COINS</div>
                    </div>
                    <div class="quest-status" style="color:${statusColor}">${statusText}</div>
                `;

                if (status === 'available') {
                    card.onclick = () => startQuest(q);
                } else if (status === 'completed') {
                    card.onclick = () => startQuest(q);
                }

                list.appendChild(card);

                // Insert side quests after their parent main quest
                const relatedSides = SIDE_QUESTS.filter(sq => sq.afterQuest === q.id);
                relatedSides.forEach(sq => {
                    const sStatus = getSideQuestStatus(sq.id);
                    const sCard = document.createElement('div');
                    sCard.className = 'quest-card ' + sStatus;
                    sCard.style.marginLeft = '30px';
                    sCard.style.borderLeftWidth = '4px';
                    sCard.style.borderLeftColor = sStatus === 'completed' ? '#00ff88' : sStatus === 'available' ? '#00ff88' : '#333';
                    sCard.style.opacity = sStatus === 'locked' ? '0.3' : sStatus === 'completed' ? '0.7' : '1';
                    let sStatusText = '';
                    let sStatusColor = '#666';
                    if (sStatus === 'completed') { sStatusText = '✅ DONE'; sStatusColor = '#00ff88'; }
                    else if (sStatus === 'available') { sStatusText = '▶ START'; sStatusColor = '#00ff88'; }
                    else { sStatusText = '🔒 LOCKED'; sStatusColor = '#555'; }

                    sCard.innerHTML = `
                        <div class="quest-num" style="background:#00331a;color:#00ff88;font-size:10px">${sq.num}</div>
                        <div class="quest-info">
                            <div class="quest-title" style="color:#00ff88;font-size:10px">${sq.title}</div>
                            <div class="quest-desc">${sq.subtitle} — ${sq.desc.substring(0, 70)}${sq.desc.length > 70 ? '...' : ''}</div>
                            <div class="quest-reward" style="color:#00bb66">REWARD: ${sq.coins} COINS</div>
                        </div>
                        <div class="quest-status" style="color:${sStatusColor}">${sStatusText}</div>
                    `;

                    if (sStatus === 'available') {
                        sCard.onclick = () => startSideQuest(sq);
                    } else if (sStatus === 'completed') {
                        sCard.onclick = () => startSideQuest(sq);
                    }

                    list.appendChild(sCard);
                });
            });

            // Show ending card if story is complete
            if (saveData.endingTracker && saveData.endingTracker.ending) {
                const ending = saveData.endingTracker.ending;
                const endingCard = document.createElement('div');
                endingCard.style.cssText = 'width:90%;max-width:700px;margin-top:15px;padding:20px;text-align:center;font-family:Press Start 2P;border:2px solid;';
                if (ending === 'true_ending') {
                    endingCard.style.borderColor = '#ffd700';
                    endingCard.style.background = 'rgba(255,215,0,0.08)';
                    endingCard.innerHTML = `<div style="color:#ffd700;font-size:14px;margin-bottom:8px">\u2B50 TRUE ENDING \u2B50</div><div style="color:#ffd700;font-size:8px;margin-bottom:6px">All missions completed. David's legacy lives on.</div><div style="color:#aaa;font-size:7px">REWARD: \ud83d\udd2b PRIDE \u2014 Iconic Pistol</div>`;
                } else if (ending === 'the_natural') {
                    endingCard.style.borderColor = '#00ff88';
                    endingCard.style.background = 'rgba(0,255,136,0.08)';
                    endingCard.innerHTML = `<div style="color:#00ff88;font-size:14px;margin-bottom:8px">\u26a1 THE NATURAL \u26a1</div><div style="color:#00ff88;font-size:8px;margin-bottom:6px">Beat the story without ever using a Sandevistan. Pure skill.</div><div style="color:#aaa;font-size:7px">REWARD: +5,000 EDDIES</div>`;
                } else {
                    endingCard.style.borderColor = '#888';
                    endingCard.style.background = 'rgba(255,255,255,0.03)';
                    endingCard.innerHTML = `<div style="color:#aaa;font-size:14px;margin-bottom:8px">STORY COMPLETE</div><div style="color:#888;font-size:8px;margin-bottom:6px">David's story is over. But there are other paths...</div><div style="color:#666;font-size:7px">Complete all Side Gigs for the TRUE ENDING \u2014 or try without Sandy for THE NATURAL</div>`;
                }
                list.appendChild(endingCard);
            }

            // Show ending hints if story is almost done
            const allMainDone = EDGERUNNER_QUESTS.every(q => saveData.questProgress && saveData.questProgress[q.id] === 'completed');
            if (allMainDone && !saveData.endingTracker?.ending) {
                const hint = document.createElement('div');
                hint.style.cssText = 'width:90%;max-width:700px;margin-top:8px;padding:10px;text-align:center;font-family:Press Start 2P;font-size:7px;color:#666;border:1px dashed #333;';
                hint.innerHTML = 'COMPLETE ALL SIDE GIGS FOR THE TRUE ENDING...';
                list.appendChild(hint);
            }
        }

        function startSideQuest(sq) {
            activeSideQuest = sq;
            sfx.play('ult');
            showDialogue(sq.dialogue_pre, () => {
                startSideQuestBattle(sq);
            });
        }

        function startSideQuestBattle(sq) {
            document.getElementById('story-screen').classList.add('hidden');
            isSideQuestBattle = true;
            isQuestBattle = false;
            isSurvival = false;
            isMemeBall = false;

            p1Char = CHARACTERS.find(c => c.id === 'yellowdude');
            p2Char = CHARACTERS.find(c => c.id === sq.enemy) || CHARACTERS[0];
            p2IsCpu = true;
            stocks = sq.stocks;
            selectedMap = MAPS.find(m => m.id === sq.map) || MAPS[4];

            initGame();

            const cpuPlayer = players.find(p => p.cpu);
            if (cpuPlayer) {
                cpuPlayer.stats = { ...cpuPlayer.stats, power: cpuPlayer.stats.power * 1.2, speed: cpuPlayer.stats.speed * 1.1 };
            }

            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('game-mode-hud').style.display = 'block';
            document.getElementById('game-mode-title').innerText = 'SIDE GIG';
            document.getElementById('game-score-val').innerText = sq.title.toUpperCase();

            gameState = 'GAME';
            music.play('BATTLE');
            loop();
        }

        function completeSideQuest(sq) {
            if (!saveData.questProgress) saveData.questProgress = {};
            const wasAlreadyDone = saveData.questProgress[sq.id] === 'completed';
            saveData.questProgress[sq.id] = 'completed';

            if (!wasAlreadyDone) {
                saveData.coins += sq.coins;
                // Award street cred for side quest
                addStreetCred(15);
            }

            // Check if ALL side quests complete -> award El Dorado
            const allSideDone = SIDE_QUESTS.every(s => saveData.questProgress[s.id] === 'completed');
            if (allSideDone) {
                if (!saveData.cyberware) saveData.cyberware = [];
                if (!saveData.cyberware.includes('el_dorado')) {
                    saveData.cyberware.push('el_dorado');
                    showNotification("ICONIC UNLOCKED!", "EL DORADO - Legendary Software");
                }
            }

            saveGame();
        }

        // Dialogue system
        function showDialogue(lines, callback) {
            questDialogueQueue = [...lines];
            questDialogueCallback = callback;
            const overlay = document.getElementById('dialogue-overlay');
            overlay.classList.add('active');
            advanceDialogue();
        }

        function advanceDialogue() {
            if (questDialogueQueue.length === 0) {
                document.getElementById('dialogue-overlay').classList.remove('active');
                if (questDialogueCallback) questDialogueCallback();
                return;
            }
            const line = questDialogueQueue.shift();
            document.getElementById('dialogue-speaker').innerText = line.speaker;
            document.getElementById('dialogue-portrait').innerText = line.portrait || '';
            // Typewriter effect (use textContent + substring to preserve spaces)
            const textEl = document.getElementById('dialogue-text');
            textEl.textContent = '';
            let charIdx = 0;
            const full = line.text;
            if (window._dialogueTimer) clearInterval(window._dialogueTimer);
            window._dialogueTimer = setInterval(() => {
                if (charIdx < full.length) {
                    charIdx++;
                    textEl.textContent = full.substring(0, charIdx);
                } else {
                    clearInterval(window._dialogueTimer);
                    window._dialogueTimer = null;
                }
            }, 20);
        }

        // Click/Enter advances dialogue
        document.addEventListener('click', (e) => {
            if (document.getElementById('dialogue-overlay').classList.contains('active')) {
                e.stopPropagation();
                advanceDialogue();
            }
        }, true);
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('dialogue-overlay').classList.contains('active') && (e.key === 'Enter' || e.key === ' ')) {
                e.preventDefault();
                advanceDialogue();
            }
        });

        function startQuest(quest) {
            activeQuest = quest;
            sfx.play('ult');

            // Show pre-battle dialogue
            showDialogue(quest.dialogue_pre, () => {
                // After dialogue, start the quest battle
                startQuestBattle(quest);
            });
        }

        function startQuestBattle(quest) {
            // Hide story screen
            document.getElementById('story-screen').classList.add('hidden');

            // Track Sandy usage for The Natural ending
            if (!saveData.endingTracker) saveData.endingTracker = { usedSandy: false, ending: null };
            const coreSlot = saveData.cyberSlots ? saveData.cyberSlots.core : null;
            if (coreSlot && (coreSlot.includes('sandevistan') || coreSlot === 'david_sandevistan' || coreSlot === 'sandevistan_apogee')) {
                saveData.endingTracker.usedSandy = true;
                saveGame();
            }

            isQuestBattle = true;
            isSurvival = false;
            isMemeBall = false;

            // Set player as Yellow Dude
            p1Char = CHARACTERS.find(c => c.id === 'yellowdude');
            p2Char = CHARACTERS.find(c => c.id === quest.enemy) || CHARACTERS[0];
            p2IsCpu = true;
            stocks = quest.stocks;
            selectedMap = MAPS.find(m => m.id === quest.map) || MAPS[4]; // Night City

            initGame();

            // Boss buff: give CPU more power for quest difficulty
            const cpuPlayer = players.find(p => p.cpu);
            if (cpuPlayer) {
                cpuPlayer.stats = { ...cpuPlayer.stats, power: cpuPlayer.stats.power * 1.3, speed: cpuPlayer.stats.speed * 1.1 };
            }

            // Show quest HUD
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('game-mode-hud').style.display = 'block';
            document.getElementById('game-mode-title').innerText = quest.subtitle.toUpperCase();
            document.getElementById('game-score-val').innerText = quest.title.toUpperCase();

            gameState = 'GAME';
            music.play('BATTLE');
            loop();
        }

        function completeQuest(quest) {
            if (!saveData.questProgress) saveData.questProgress = {};
            const wasAlreadyDone = saveData.questProgress[quest.id] === 'completed';
            saveData.questProgress[quest.id] = 'completed';

            // Award reward (cyberware)
            if (!saveData.cyberware) saveData.cyberware = [];
            if (!saveData.cyberware.includes(quest.reward)) {
                saveData.cyberware.push(quest.reward);
            }

            // Award coins (only first completion)
            if (!wasAlreadyDone) {
                saveData.coins += quest.coins;
                // Award street cred for quest completion
                addStreetCred(quest.coins >= 1000 ? 50 : 30);
            }

            saveGame();

            // Check if all quests complete
            const allDone = EDGERUNNER_QUESTS.every(q => saveData.questProgress[q.id] === 'completed');
            if (allDone && !saveData.trophies.includes('edgerunner_complete')) {
                unlockTrophy('edgerunner_complete');
            }

            // Evaluate ending when Episode 4 is completed
            if (quest.id === 'ep4_maxtac' && allDone && !saveData.endingTracker.ending) {
                evaluateEnding();
            }
        }

        function evaluateEnding() {
            if (!saveData.endingTracker) saveData.endingTracker = { usedSandy: false, ending: null };
            const allSideDone = SIDE_QUESTS.every(s => saveData.questProgress[s.id] === 'completed');
            const usedSandy = saveData.endingTracker.usedSandy;

            if (!usedSandy) {
                // THE NATURAL: Beat entire story without ever equipping a Sandevistan
                saveData.endingTracker.ending = 'the_natural';
                saveData.coins += 5000;
                showNotification("ENDING UNLOCKED!", '⚡ THE NATURAL — +5,000 EDDIES');
            } else if (allSideDone) {
                // TRUE ENDING: All quests + all side quests complete
                saveData.endingTracker.ending = 'true_ending';
                if (!saveData.cyberware) saveData.cyberware = [];
                if (!saveData.cyberware.includes('pride')) {
                    saveData.cyberware.push('pride');
                }
                showNotification("TRUE ENDING!", '🔫 PRIDE — Iconic Pistol Unlocked!');
            } else {
                // STANDARD ENDING: Just beat the story
                saveData.endingTracker.ending = 'standard';
                saveData.coins += 1000;
                showNotification("STORY COMPLETE!", 'Standard Ending — +1,000 EDDIES');
            }
            saveGame();
        }

        function getStreetCredLevel() {
            if (!saveData.streetCred) return { level: 1, xp: 0, xpNeeded: 100 };
            return { level: saveData.streetCred.level, xp: saveData.streetCred.xp, xpNeeded: saveData.streetCred.level * 100 };
        }

        function addStreetCred(amount) {
            if (!saveData.streetCred) saveData.streetCred = { xp: 0, level: 1 };
            saveData.streetCred.xp += amount;
            let leveledUp = false;
            while (saveData.streetCred.xp >= saveData.streetCred.level * 100 && saveData.streetCred.level < 50) {
                saveData.streetCred.xp -= saveData.streetCred.level * 100;
                saveData.streetCred.level++;
                leveledUp = true;
            }
            if (saveData.streetCred.level >= 50) saveData.streetCred.xp = 0; // Cap at 50
            if (leveledUp) {
                showNotification("STREET CRED UP!", `Level ${saveData.streetCred.level} — Night City knows your name`);
                // Unlock tier items at milestones
                if (saveData.streetCred.level >= 10) unlockTrophy('street_cred_10');
                if (saveData.streetCred.level >= 25) unlockTrophy('street_cred_25');
                if (saveData.streetCred.level >= 50) unlockTrophy('street_cred_50');
            }
            saveGame();
        }

        function getShopDiscount() {
            if (!saveData.streetCred) return 0;
            // 1% discount per street cred level, max 25%
            return Math.min(25, saveData.streetCred.level);
        }

        // ===== LOADOUT PRESETS =====
        function saveLoadoutPreset(name) {
            if (!saveData.loadoutPresets) saveData.loadoutPresets = {};
            saveData.loadoutPresets[name] = {
                core: saveData.cyberSlots ? saveData.cyberSlots.core : null,
                arm: saveData.cyberSlots ? saveData.cyberSlots.arm : null,
                software: saveData.cyberSlots ? saveData.cyberSlots.software : null,
                legs: saveData.cyberSlots ? saveData.cyberSlots.legs : null
            };
            saveGame();
            showNotification("LOADOUT SAVED", name.toUpperCase());
        }

        function loadLoadoutPreset(name) {
            if (!saveData.loadoutPresets || !saveData.loadoutPresets[name]) return;
            const preset = saveData.loadoutPresets[name];
            if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, ability: 'kiroshi', arm: null, software: null, legs: null };
            // Only equip if player owns the cyberware
            if (!saveData.cyberware) saveData.cyberware = [];
            saveData.cyberSlots.core = (preset.core && saveData.cyberware.includes(preset.core)) ? preset.core : null;
            saveData.cyberSlots.arm = (preset.arm && saveData.cyberware.includes(preset.arm)) ? preset.arm : null;
            saveData.cyberSlots.software = (preset.software && saveData.cyberware.includes(preset.software)) ? preset.software : null;
            saveData.cyberSlots.legs = (preset.legs && saveData.cyberware.includes(preset.legs)) ? preset.legs : null;
            saveGame();
            showNotification("LOADOUT LOADED", name.toUpperCase());
            renderCyberware();
        }

        function deleteLoadoutPreset(name) {
            if (saveData.loadoutPresets && saveData.loadoutPresets[name]) {
                delete saveData.loadoutPresets[name];
                saveGame();
                renderCyberware();
            }
        }

        // ===== END EDGERUNNER QUEST SYSTEM =====


        function openCyberware() {
            if (!saveData.cyberware) saveData.cyberware = [];
            if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, ability: 'kiroshi', arm: null, software: null };

            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('cyberware-screen').classList.remove('hidden');
            gameState = 'CYBER';
            sfx.init();
            renderCyberware();

            // Draw character preview
            const canvas = document.getElementById('cyber-char-preview');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 100, 100);
            const sprite = characterSprites['yellowdude'];
            if (sprite && sprite.idle && sprite.idle[0]) {
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(sprite.idle[0], 0, 0, 100, 100);
            } else {
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('😐', 50, 50);
            }
        }

        function closeCyberware() {
            document.getElementById('cyberware-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            gameState = 'TITLE';
            saveGame();
        }

        function showLoadoutPresets() {
            const panel = document.getElementById('loadout-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            const listEl = document.getElementById('loadout-list');
            listEl.innerHTML = '';
            if (!saveData.loadoutPresets) saveData.loadoutPresets = {};
            const presets = Object.keys(saveData.loadoutPresets);
            if (presets.length === 0) {
                listEl.innerHTML = '<div style="font-family:Press Start 2P;font-size:8px;color:#555;text-align:center">NO SAVED LOADOUTS</div>';
            } else {
                presets.forEach(name => {
                    const p = saveData.loadoutPresets[name];
                    const row = document.createElement('div');
                    row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:6px 10px;background:rgba(0,255,255,0.05);border:1px solid #0ff33;';
                    const coreName = p.core ? (SHOP_ITEMS.find(i => i.id === p.core)?.name || p.core) : 'NONE';
                    const armName = p.arm ? (SHOP_ITEMS.find(i => i.id === p.arm)?.name || p.arm) : 'NONE';
                    const softName = p.software ? (SHOP_ITEMS.find(i => i.id === p.software)?.name || p.software) : 'NONE';
                    const legsName = p.legs ? (SHOP_ITEMS.find(i => i.id === p.legs)?.name || p.legs) : 'NONE';
                    row.innerHTML = `
                        <div style="flex:1">
                            <div style="font-family:Press Start 2P;font-size:9px;color:#0ff;margin-bottom:4px">${name.toUpperCase()}</div>
                            <div style="font-family:Press Start 2P;font-size:6px;color:#888">C: ${coreName} | A: ${armName} | S: ${softName} | L: ${legsName}</div>
                        </div>
                        <div style="display:flex;gap:5px">
                            <button style="background:#0ff;color:#000;border:none;padding:3px 8px;cursor:pointer;font-family:Press Start 2P;font-size:7px" onclick="loadLoadoutPreset('${name}');showLoadoutPresets()">LOAD</button>
                            <button style="background:#f44;color:#fff;border:none;padding:3px 6px;cursor:pointer;font-family:Press Start 2P;font-size:7px" onclick="deleteLoadoutPreset('${name}');showLoadoutPresets()">X</button>
                        </div>
                    `;
                    listEl.appendChild(row);
                });
            }
        }

        function promptSaveLoadout() {
            const name = prompt('Enter loadout name (e.g., Combat, Stealth, Netrunner):');
            if (name && name.trim()) {
                saveLoadoutPreset(name.trim().substring(0, 15));
                showLoadoutPresets();
            }
        }

        function renderCyberware() {
            const inventory = document.getElementById('cyber-inventory');
            inventory.innerHTML = '';

            // Inventory
            if (saveData.cyberware) {
                saveData.cyberware.forEach(id => {
                    const item = SHOP_ITEMS.find(i => i.id === id);
                    if (item) {
                        const div = document.createElement('div');
                        div.className = 'shop-item';
                        if (cyberSelectedItem && cyberSelectedItem.id === id) div.classList.add('selected');
                        div.innerHTML = `<div style="font-size:20px">💾</div><div style="font-size:8px;margin-top:5px;line-height:1.2">${item.name}</div>`;
                        div.style.minHeight = '80px';
                        div.onclick = () => { cyberSelectedItem = item; renderCyberware(); sfx.play('coin'); };
                        inventory.appendChild(div);
                    }
                });
            }

            // Update Slots
            const coreSlot = document.getElementById('slot-core');
            const coreId = saveData.cyberSlots ? saveData.cyberSlots.core : null;
            if (coreId) {
                const item = SHOP_ITEMS.find(i => i.id === coreId);
                coreSlot.innerHTML = `<span style="color:#0ff">${item ? item.name : coreId}</span><br><span style="font-size:8px;color:#aaa">ACTIVE</span>`;
                coreSlot.style.borderColor = "#0ff";
                coreSlot.style.color = "#0ff";
            } else {
                coreSlot.innerHTML = "EMPTY SLOT";
                coreSlot.style.borderColor = "#555";
                coreSlot.style.color = "#666";
            }

            updateCyberDesc();

            // Update Arm Slot
            const armSlot = document.getElementById('slot-arm');
            const armId = saveData.cyberSlots ? saveData.cyberSlots.arm : null;
            if (armId) {
                const armItem = SHOP_ITEMS.find(i => i.id === armId);
                armSlot.innerHTML = `<span style="color:#f44">${armItem ? armItem.name : armId}</span><br><span style="font-size:8px;color:#aaa">ACTIVE</span>`;
                armSlot.style.borderColor = "#f44";
                armSlot.style.color = "#f44";
            } else {
                armSlot.innerHTML = "EMPTY SLOT";
                armSlot.style.borderColor = "#555";
                armSlot.style.color = "#666";
            }

            // Update Software Slot
            const softSlot = document.getElementById('slot-software');
            const softId = saveData.cyberSlots ? saveData.cyberSlots.software : null;
            if (softSlot) {
                if (softId) {
                    const softItem = SHOP_ITEMS.find(i => i.id === softId);
                    softSlot.innerHTML = `<span style="color:#ffd700">${softItem ? softItem.name : softId}</span><br><span style="font-size:8px;color:#aaa">ACTIVE</span>`;
                    softSlot.style.borderColor = "#ffd700";
                    softSlot.style.color = "#ffd700";
                } else {
                    softSlot.innerHTML = "EMPTY SLOT";
                    softSlot.style.borderColor = "#555";
                    softSlot.style.color = "#666";
                }
            }

            // Update Legs Slot
            const legsSlot = document.getElementById('slot-legs');
            const legsId = saveData.cyberSlots ? saveData.cyberSlots.legs : null;
            if (legsSlot) {
                if (legsId) {
                    const legsItem = SHOP_ITEMS.find(i => i.id === legsId);
                    legsSlot.innerHTML = `<span style="color:#00ccff">${legsItem ? legsItem.name : legsId}</span><br><span style="font-size:8px;color:#aaa">ACTIVE</span>`;
                    legsSlot.style.borderColor = "#00ccff";
                    legsSlot.style.color = "#00ccff";
                } else {
                    legsSlot.innerHTML = "EMPTY SLOT";
                    legsSlot.style.borderColor = "#555";
                    legsSlot.style.color = "#666";
                }
            }
        }

        function selectCyberSlot(type) {
            sfx.play('coin');
        }

        function updateCyberDesc() {
            const descBox = document.getElementById('cyber-item-desc');
            const btn = document.getElementById('cyber-equip-btn');

            if (!cyberSelectedItem) {
                descBox.innerText = "SELECT AN ITEM";
                btn.style.display = 'none';
                return;
            }

            const item = cyberSelectedItem;
            let status = "READY TO INSTALL";
            let color = "#aaa";

            // Check if equipped
            if (saveData.cyberSlots && saveData.cyberSlots.core === item.id) {
                status = "INSTALLED in CORE";
                color = "#0ff";
                btn.innerText = "UNEQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.arm === item.id) {
                status = "INSTALLED in ARMS";
                color = "#f44";
                btn.innerText = "UNEQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.software === item.id) {
                status = "INSTALLED in SOFTWARE";
                color = "#ffd700";
                btn.innerText = "UNEQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.legs === item.id) {
                status = "INSTALLED in LEGS";
                color = "#00ccff";
                btn.innerText = "UNEQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.core && item.subtype === 'core') {
                status = "CORE SLOT OCCUPIED";
                color = "#f00";
                btn.innerText = "SWAP / EQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.arm && item.subtype === 'arm') {
                status = "ARM SLOT OCCUPIED";
                color = "#f00";
                btn.innerText = "SWAP / EQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.software && item.subtype === 'software') {
                status = "SOFTWARE SLOT OCCUPIED";
                color = "#f00";
                btn.innerText = "SWAP / EQUIP";
                btn.style.display = 'block';
            } else if (saveData.cyberSlots && saveData.cyberSlots.legs && item.subtype === 'legs') {
                status = "LEGS SLOT OCCUPIED";
                color = "#f00";
                btn.innerText = "SWAP / EQUIP";
                btn.style.display = 'block';
            } else {
                btn.innerText = "EQUIP";
                btn.style.display = 'block';
            }

            descBox.innerHTML = `<span style='color:#ffe135'>${item.name}</span><br><br>${item.desc || 'No description data.'}<br><br><span style='color:${color}'>STATUS: ${status}</span>`;
        }

        function equipCyberware() {
            if (!cyberSelectedItem) return;
            const item = cyberSelectedItem;

            if (item.subtype === 'core') {
                if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, arm: null, software: null };
                if (saveData.cyberSlots.core === item.id) {
                    saveData.cyberSlots.core = null;
                    sfx.play('shield');
                } else {
                    saveData.cyberSlots.core = item.id;
                    sfx.play('ult');
                }
                saveGame();
                renderCyberware();
            } else if (item.subtype === 'arm') {
                if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, arm: null, software: null };
                if (saveData.cyberSlots.arm === item.id) {
                    saveData.cyberSlots.arm = null;
                    sfx.play('shield');
                } else {
                    saveData.cyberSlots.arm = item.id;
                    sfx.play('ult');
                }
                saveGame();
                renderCyberware();
            } else if (item.subtype === 'software') {
                if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, arm: null, software: null, legs: null };
                if (saveData.cyberSlots.software === item.id) {
                    saveData.cyberSlots.software = null;
                    sfx.play('shield');
                } else {
                    saveData.cyberSlots.software = item.id;
                    sfx.play('ult');
                }
                saveGame();
                renderCyberware();
            } else if (item.subtype === 'legs') {
                if (!saveData.cyberSlots) saveData.cyberSlots = { core: null, arm: null, software: null, legs: null };
                if (saveData.cyberSlots.legs === item.id) {
                    saveData.cyberSlots.legs = null;
                    sfx.play('shield');
                } else {
                    saveData.cyberSlots.legs = item.id;
                    sfx.play('ult');
                }
                saveGame();
                renderCyberware();
            }
        }
        function openGacha() {
            sfx.init();
            music.init();
            audioFiles.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('gacha-screen').classList.remove('hidden');
            gameState = 'GACHA';
            updateGachaDisplay();
            initBanner();

            // Update banner timer every second
            if (window.bannerTimerInterval) clearInterval(window.bannerTimerInterval);
            window.bannerTimerInterval = setInterval(updateBannerDisplay, 1000);

            music.play('MENU');
            loop();
        }
        function closeGacha() {
            if (window.bannerTimerInterval) clearInterval(window.bannerTimerInterval);
            document.getElementById('gacha-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            gameState = 'TITLE';
        }
        function initBanner() {
            const now = Date.now();
            if (!saveData.bannerEndTime || now >= saveData.bannerEndTime) {
                // Start new banner
                const bannerChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'];
                saveData.currentBanner = bannerChars[Math.floor(Math.random() * bannerChars.length)];
                saveData.bannerEndTime = now + (60 * 60 * 1000); // 1 hour
                saveGame();
            }
            updateBannerDisplay();
        }
        function updateBannerDisplay() {
            const now = Date.now();
            const timerEl = document.getElementById('banner-timer');
            const btnEl = document.getElementById('gacha-banner-btn');
            const timeLeftEl = document.getElementById('banner-time-left');
            const charNameEl = document.getElementById('banner-char-name');

            if (saveData.bannerEndTime && now < saveData.bannerEndTime && saveData.currentBanner) {
                const remaining = saveData.bannerEndTime - now;
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);

                const charNames = { thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH' };
                const charIcons = { thememe: '💪', gps: '🗺️', johnpork: '📞', mechabara: '🤖', bluedude: '🗡️', glitch: '⚡' };

                if (charNameEl) charNameEl.textContent = `${charIcons[saveData.currentBanner]} ${charNames[saveData.currentBanner]} ${charIcons[saveData.currentBanner]}`;
                if (timeLeftEl) timeLeftEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (timerEl) timerEl.style.display = 'block';
                if (btnEl) btnEl.style.display = 'block';
            } else {
                if (timerEl) timerEl.style.display = 'none';
                if (btnEl) btnEl.style.display = 'none';
                if (saveData.bannerEndTime && now >= saveData.bannerEndTime) {
                    initBanner();
                }
            }
        }
        function rollBannerGacha() {
            if ((saveData.gachaCoins || 0) < 1) {
                sfx.play('break');
                alert('Not enough Gacha Coins! Convert 1000 coins or earn from achievements.');
                return;
            }
            if (!saveData.currentBanner) {
                initBanner();
                return;
            }

            saveData.gachaCoins -= 1;
            saveGame();
            updateGachaDisplay();
            sfx.play('ult');

            const display = document.getElementById('gacha-display');
            display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';

            let frameIndex = 0;
            const animInterval = setInterval(() => {
                const canvas = document.getElementById('gacha-anim-canvas');
                if (!canvas) {
                    clearInterval(animInterval);
                    return;
                }
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const frame = gachaAnimFrames[frameIndex];
                const pixelSize = 10;
                for (let y = 0; y < frame.length; y++) {
                    for (let x = 0; x < frame[y].length; x++) {
                        const colorKey = frame[y][x];
                        if (gachaColors[colorKey] && colorKey !== '0') {
                            ctx.fillStyle = gachaColors[colorKey];
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                }
                frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
            }, 100);

            setTimeout(() => {
                clearInterval(animInterval);

                const roll = Math.random() * 100;
                let reward, rarity, icon, name, desc;

                // Banner gacha: 50% featured character, 30% other ultra, 20% rare char
                if (roll < 50) {
                    // 50% - Featured banner character
                    reward = saveData.currentBanner;
                    const charNames = { thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH' };
                    name = charNames[reward];
                    rarity = '⭐ BANNER FEATURED ⭐';
                    icon = '🌟';
                    desc = 'Limited Character!';
                    if (!saveData.unlocks.includes(reward)) {
                        saveData.unlocks.push(reward);
                        showNotification("🌟 BANNER FEATURED! 🌟", `${name} UNLOCKED!`);
                    } else {
                        showNotification("🌟 BANNER FEATURED! 🌟", `${name} (Already Owned)`);
                    }
                } else if (roll < 80) {
                    // 30% - Other ultra rare characters
                    const ultraChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'].filter(c => c !== saveData.currentBanner);
                    const unlockedUltra = ultraChars.filter(c => !saveData.unlocks.includes(c));
                    if (unlockedUltra.length > 0) {
                        reward = unlockedUltra[Math.floor(Math.random() * unlockedUltra.length)];
                        const charNames = { thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH' };
                        name = charNames[reward];
                        rarity = 'ULTRA RARE';
                        icon = '✨';
                        desc = 'Character Unlocked!';
                        saveData.unlocks.push(reward);
                        showNotification("✨ ULTRA RARE! ✨", `${name} UNLOCKED!`);
                    } else {
                        reward = 'crown';
                        name = 'CROWN';
                        rarity = 'RARE';
                        icon = '👑';
                        desc = 'Cosmetic!';
                        if (!saveData.cosmetics.includes('crown')) saveData.cosmetics.push('crown');
                    }
                } else {
                    // 20% - Rare characters
                    const rareChars = ['luckyblock', 'brokeboy'];
                    const unlockedRare = rareChars.filter(c => !saveData.unlocks.includes(c));
                    if (unlockedRare.length > 0) {
                        reward = unlockedRare[Math.floor(Math.random() * unlockedRare.length)];
                        const charNames = { luckyblock: 'LUCKY BLOCK', brokeboy: 'BROKE BOY' };
                        name = charNames[reward];
                        rarity = 'RARE';
                        icon = '🌟';
                        desc = 'Character Unlocked!';
                        saveData.unlocks.push(reward);
                        showNotification("🌟 RARE! 🌟", `${name} UNLOCKED!`);
                    } else {
                        reward = 'shades';
                        name = 'SHADES';
                        rarity = 'RARE';
                        icon = '🕶️';
                        desc = 'Cosmetic!';
                        if (!saveData.cosmetics.includes('shades')) saveData.cosmetics.push('shades');
                    }
                }

                saveGame();
                renderCharGrid && renderCharGrid();

                display.innerHTML = `
            <div class="gacha-result-icon" style="font-size:72px">${icon}</div>
            <div class="gacha-result-name">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity" style="color:#ff0">${rarity}</div>
        `;
            }, 2000);
        }
        function toggleGachaInfo() {
            const panel = document.getElementById('gacha-info-panel');
            if (!panel) return;

            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');

                // Update pity counter display
                const pityEl = document.getElementById('gacha-pity-display');
                if (pityEl) {
                    const pity = saveData.gachaPity || 0;
                    const remaining = 200 - pity;
                    pityEl.innerHTML = `<strong>Pity Counter:</strong> ${pity}/200 rolls (${remaining} until guaranteed Lucky Block)`;
                }
            } else {
                panel.classList.add('hidden');
            }
        }
        function updateGachaDisplay() {
            const btn = document.getElementById('gacha-roll-btn');
            const premiumBtn = document.getElementById('gacha-roll-premium-btn');
            const coinEl = document.getElementById('gacha-coin-count');
            const gachaEl = document.getElementById('gacha-coin-special-count');

            if (coinEl) coinEl.innerText = saveData.coins;
            if (gachaEl) gachaEl.innerText = saveData.gachaCoins || 0;

            if (btn) {
                if (saveData.coins >= 100) {
                    btn.disabled = false;
                    btn.innerText = `NORMAL GACHA (100💰)`;
                } else {
                    btn.disabled = true;
                    btn.innerText = `NOT ENOUGH COINS`;
                }
            }

            if (premiumBtn) {
                if ((saveData.gachaCoins || 0) >= 1) {
                    premiumBtn.disabled = false;
                } else {
                    premiumBtn.disabled = true;
                }
            }
        }
        const gachaAnimFrames = [
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0013344455444100", "0013444544544100", "0013444444544100", "0013444445444100", "0013444454444100", "0013344444444100", "0013333353333100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010011111100100", "0010015322100100", "0010013355100100", "0010012222100100", "0010015555100100", "0010111111110100", "0010000000000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010000000000100", "0014400040440100", "0010040400000100", "0010000000000100", "0014000004000100", "0010444040440100", "0010000000000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010011111100100", "0010012222100100", "0010111515110100", "0011012222101100", "0010011111100100", "0010001001000100", "0010011011000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"],
            ["0000000000000000", "0000000000000000", "0000000000000000", "0000000000000000", "0011111111111100", "0010000000000100", "0010001111000100", "0010001551000100", "0010001331000100", "0010001441000100", "0010001221000100", "0010001111000100", "0011111111111100", "0000000000000000", "0000000000000000", "0000000000000000"]
        ];
        const gachaColors = {
            '0': "rgba(0,0,0,0)",
            '1': '#000000',
            '2': '#ff0000',
            '3': '#3c587c',
            '4': '#417ea4',
            '5': '#ffffff',
            '6': '#FF0000',
            '7': '#FFA500',
            '8': '#FFFF00',
            '9': '#00FF00',
            'A': '#00FFFF',
            'B': '#0000FF',
            'C': '#8000FF',
            'D': '#FF00FF',
            'E': '#964B00',
            'F': '#808080',
            'G': '#404040',
            'H': '#606060',
            'I': '#202020',
            'J': '#008000',
            'K': '#008080',
            'L': '#800000',
            'M': '#808000',
            'N': '#0080FF',
            'O': '#FF0080',
            'P': '#C0C0C0',
            'Q': '#A0A0A0',
            'R': '#303030',
            'S': '#101010',
            'T': '#FFD700',
            'U': '#ADFF2F',
            'V': '#4B0082'
        };

        function rollGacha() {
            const GACHA_COST = 100;
            if (saveData.coins < GACHA_COST) {
                sfx.play('break');
                return;
            }
            saveData.coins -= GACHA_COST;
            saveData.gachaPity = (saveData.gachaPity || 0) + 1;
            saveGame();
            updateCoinDisplay();
            updateGachaDisplay();
            sfx.play('coin');

            // Show animation
            const display = document.getElementById('gacha-display');
            display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';

            let frameIndex = 0;
            const animInterval = setInterval(() => {
                const canvas = document.getElementById('gacha-anim-canvas');
                if (!canvas) {
                    clearInterval(animInterval);
                    return;
                }
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const frame = gachaAnimFrames[frameIndex];
                const pixelSize = 10;
                for (let y = 0; y < frame.length; y++) {
                    for (let x = 0; x < frame[y].length; x++) {
                        const colorKey = frame[y][x];
                        if (gachaColors[colorKey] && colorKey !== '0') {
                            ctx.fillStyle = gachaColors[colorKey];
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                }

                frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
            }, 150);

            // After 2 seconds, show result
            setTimeout(() => {
                clearInterval(animInterval);

                // Check pity at 200 rolls for Lucky Block
                const pityTriggered = saveData.gachaPity >= 200;
                const roll = Math.random() * 100;
                let reward = null;
                let rarity = '';
                let icon = '';
                let name = '';
                let desc = '';

                if (pityTriggered) {
                    reward = 'luckyblock';
                    rarity = 'PITY ULTRA RARE';
                    icon = '🎁';
                    name = 'LUCKY BLOCK';
                    desc = 'Character Unlocked! (Pity at 200)';
                    if (!saveData.unlocks.includes('luckyblock')) {
                        saveData.unlocks.push('luckyblock');
                        sfx.play('ult');
                        showNotification("🎁 PITY TRIGGERED! 🎁", "LUCKY BLOCK UNLOCKED!");
                    }
                    saveData.gachaPity = 0;
                } else if (roll < 0.5) {
                    reward = 'luckyblock';
                    rarity = 'ULTRA RARE';
                    icon = '🎁';
                    name = 'LUCKY BLOCK';
                    desc = 'Character Unlocked!';
                    if (!saveData.unlocks.includes('luckyblock')) {
                        saveData.unlocks.push('luckyblock');
                        sfx.play('ult');
                        showNotification("🎁 ULTRA RARE! 🎁", "LUCKY BLOCK UNLOCKED!");
                    }
                    saveData.gachaPity = 0;
                } else if (roll < 1.005) {
                    reward = 'title_restless_gambler';
                    rarity = 'RARE';
                    icon = '🎰';
                    name = 'THE RESTLESS GAMBLER';
                    desc = 'Title Unlocked!';
                    if (!saveData.titles) saveData.titles = [];
                    if (!saveData.titles.includes('restless_gambler')) {
                        saveData.titles.push('restless_gambler');
                        sfx.play('ult');
                        showNotification("🎰 RARE REWARD! 🎰", "TITLE: THE RESTLESS GAMBLER");
                    }
                } else if (roll < 10.005) {
                    reward = 'tophat';
                    rarity = 'UNCOMMON';
                    icon = '🎩';
                    name = 'TOP HAT';
                    desc = 'Cosmetic Unlocked!';
                    if (!saveData.cosmetics.includes('tophat')) {
                        saveData.cosmetics.push('tophat');
                        equippedCosmetic = 'tophat';
                        sfx.play('ult');
                        showNotification("🎩 COSMETIC UNLOCKED! 🎩", "TOP HAT");
                    }
                } else if (roll < 30.005) {
                    reward = 'power_booster';
                    rarity = 'UNCOMMON';
                    icon = '⚡';
                    name = 'POWER BOOSTER';
                    desc = 'Survival Boost Unlocked!';
                    saveData.powerBoosters = (saveData.powerBoosters || 0) + 1;
                    sfx.play('ult');
                    showNotification("⚡ POWER BOOSTER! ⚡", "Use in Survival Mode");
                } else {
                    reward = 'brokeboy';
                    rarity = 'COMMON';
                    icon = '💸';
                    name = 'BROKE BOY';
                    desc = 'Character Unlocked!';
                    if (!saveData.unlocks.includes('brokeboy')) {
                        saveData.unlocks.push('brokeboy');
                        sfx.play('coin');
                        showNotification("💸 COMMON REWARD 💸", "BROKE BOY UNLOCKED");
                    }
                }
                saveGame();
                display.innerHTML = `
            <div class="gacha-result-icon">${icon}</div>
            <div class="gacha-result-name ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${rarity}</div>
        `;
                updateGachaDisplay();
            }, 2000);
        }

        function rollPremiumGacha() {
            if ((saveData.gachaCoins || 0) < 1) {
                sfx.play('break');
                alert('Not enough Gacha Coins! Convert 1000 coins or earn from achievements.');
                return;
            }
            saveData.gachaCoins -= 1;
            saveGame();
            updateGachaDisplay();
            sfx.play('ult');

            const display = document.getElementById('gacha-display');
            display.innerHTML = '<canvas id="gacha-anim-canvas" width="160" height="160" style="image-rendering: pixelated; width: 160px; height: 160px;"></canvas>';

            let frameIndex = 0;
            const animInterval = setInterval(() => {
                const canvas = document.getElementById('gacha-anim-canvas');
                if (!canvas) {
                    clearInterval(animInterval);
                    return;
                }
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const frame = gachaAnimFrames[frameIndex];
                const pixelSize = 10;
                for (let y = 0; y < frame.length; y++) {
                    for (let x = 0; x < frame[y].length; x++) {
                        const colorKey = frame[y][x];
                        if (gachaColors[colorKey] && colorKey !== '0') {
                            ctx.fillStyle = gachaColors[colorKey];
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                }
                frameIndex = (frameIndex + 1) % gachaAnimFrames.length;
            }, 100);

            setTimeout(() => {
                clearInterval(animInterval);

                const roll = Math.random() * 100;
                let reward, rarity, icon, name, desc;

                // Premium gacha: guaranteed rare+ (characters and cosmetics)
                if (roll < 20) {
                    // 20% - Ultra Rare Characters
                    const ultraChars = ['thememe', 'gps', 'johnpork', 'mechabara', 'bluedude', 'glitch'];
                    const unlockedUltra = ultraChars.filter(c => !saveData.unlocks.includes(c));
                    if (unlockedUltra.length > 0) {
                        reward = unlockedUltra[Math.floor(Math.random() * unlockedUltra.length)];
                        const charNames = { thememe: 'THE MEME', gps: 'GPS', johnpork: 'JOHN PORK', mechabara: 'MECHA-BARA', bluedude: 'BLUE DUDE', glitch: 'GLITCH' };
                        name = charNames[reward];
                        rarity = 'ULTRA RARE';
                        icon = '✨';
                        desc = 'Character Unlocked!';
                        saveData.unlocks.push(reward);
                        showNotification("✨ ULTRA RARE! ✨", `${name} UNLOCKED!`);
                    } else {
                        reward = 'crown';
                        name = 'CROWN';
                        rarity = 'RARE';
                        icon = '👑';
                        desc = 'Cosmetic Unlocked!';
                        if (!saveData.cosmetics.includes('crown')) saveData.cosmetics.push('crown');
                    }
                } else if (roll < 50) {
                    // 30% - Rare Characters (only unlockable ones)
                    const rareChars = ['luckyblock', 'brokeboy'];
                    const unlockedRare = rareChars.filter(c => !saveData.unlocks.includes(c));
                    if (unlockedRare.length > 0) {
                        reward = unlockedRare[Math.floor(Math.random() * unlockedRare.length)];
                        const charNames = { luckyblock: 'LUCKY BLOCK', brokeboy: 'BROKE BOY' };
                        name = charNames[reward];
                        rarity = 'RARE';
                        icon = '🌟';
                        desc = 'Character Unlocked!';
                        saveData.unlocks.push(reward);
                        showNotification("🌟 RARE! 🌟", `${name} UNLOCKED!`);
                    } else {
                        reward = 'shades';
                        name = 'SHADES';
                        rarity = 'RARE';
                        icon = '🕶️';
                        desc = 'Cosmetic Unlocked!';
                        if (!saveData.cosmetics.includes('shades')) saveData.cosmetics.push('shades');
                    }
                } else {
                    // 50% - Cosmetics guaranteed
                    const cosmetics = ['tophat', 'shades', 'crown'];
                    reward = cosmetics[Math.floor(Math.random() * cosmetics.length)];
                    const cosNames = { tophat: 'TOP HAT', shades: 'SHADES', crown: 'CROWN' };
                    const cosIcons = { tophat: '🎩', shades: '🕶️', crown: '👑' };
                    name = cosNames[reward];
                    icon = cosIcons[reward];
                    rarity = 'UNCOMMON';
                    desc = 'Cosmetic Unlocked!';
                    if (!saveData.cosmetics.includes(reward)) saveData.cosmetics.push(reward);
                }

                saveGame();
                display.innerHTML = `
            <div class="gacha-result-icon">${icon}</div>
            <div class="gacha-result-name ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${name}</div>
            <div class="gacha-result-desc">${desc}</div>
            <div class="gacha-rarity ${rarity === 'ULTRA RARE' ? 'gacha-ultra-rare' : (rarity === 'RARE' ? 'gacha-rare' : 'gacha-common')}">${rarity} - PREMIUM</div>
        `;
                updateGachaDisplay();
            }, 2000);
        }

        function convertCoinsToGacha() {
            if (saveData.coins < 1000) {
                sfx.play('break');
                alert('You need at least 1000 coins to convert!');
                return;
            }
            if (confirm('Convert 1000 💰 to 1 🎫 Gacha Coin?')) {
                saveData.coins -= 1000;
                saveData.gachaCoins = (saveData.gachaCoins || 0) + 1;
                saveGame();
                updateCoinDisplay();
                updateGachaDisplay();
                sfx.play('coin');
                showNotification("🎫 CONVERTED!", "+1 Gacha Coin");
            }
        }


        window.addEventListener('keydown', e => {
            let key = e.key;
            if (gameState === 'TITLE') {
                // Check each cheat code independently
                let matched = false;

                // Cheat Code 1: thememe
                if (key === cheatCode[cheatIndex]) {
                    cheatIndex++;
                    console.log('[DEBUG] cheatCode1 progress:', cheatIndex, '/', cheatCode.length);
                    if (cheatIndex === cheatCode.length) {
                        if (!saveData.unlocks.includes('thememe')) {
                            saveData.unlocks.push('thememe'); saveGame();
                            showNotification("SECRET UNLOCKED!", "THE MEME");
                            unlockTrophy('unlock_meme');
                        }
                        cheatIndex = 0;
                    }
                    matched = true;
                } else {
                    cheatIndex = 0;
                }

                // Cheat Code 2: gps
                if (key === cheatCode2[cheatIndex2]) {
                    cheatIndex2++;
                    console.log('[DEBUG] cheatCode2 progress:', cheatIndex2, '/', cheatCode2.length);
                    if (cheatIndex2 === cheatCode2.length) {
                        if (!saveData.unlocks.includes('gps')) {
                            saveData.unlocks.push('gps'); saveGame();
                            showNotification("SECRET UNLOCKED!", "GPS");
                            unlockTrophy('unlock_gps');
                        }
                        cheatIndex2 = 0;
                    }
                    matched = true;
                } else {
                    cheatIndex2 = 0;
                }

                // Cheat Code 3: mechabara
                if (key === cheatCode3[cheatIndex3]) {
                    cheatIndex3++;
                    console.log('[DEBUG] cheatCode3 progress:', cheatIndex3, '/', cheatCode3.length);
                    if (cheatIndex3 === cheatCode3.length) {
                        if (!saveData.unlocks.includes('mechabara')) {
                            saveData.unlocks.push('mechabara'); saveGame();
                            showNotification("SECRET UNLOCKED!", "MECHA-BARA");
                            unlockTrophy('unlock_mechabara');
                        }
                        cheatIndex3 = 0;
                    }
                    matched = true;
                } else {
                    cheatIndex3 = 0;
                }

                // Cheat Code 4: bluedude
                if (key === cheatCode4[cheatIndex4]) {
                    cheatIndex4++;
                    console.log('[DEBUG] cheatCode4 progress:', cheatIndex4, '/', cheatCode4.length);
                    if (cheatIndex4 === cheatCode4.length) {
                        if (!saveData.unlocks.includes('bluedude')) {
                            saveData.unlocks.push('bluedude'); saveGame();
                            showNotification("SECRET UNLOCKED!", "BLUEDUDE");
                            unlockTrophy('unlock_bluedude');
                        }
                        cheatIndex4 = 0;
                    }
                    matched = true;
                } else {
                    cheatIndex4 = 0;
                }

                // Cheat Code 5: glitch
                if (key === cheatCodeGlitch[cheatIndexGlitch]) {
                    cheatIndexGlitch++;
                    console.log('[DEBUG] cheatCodeGlitch progress:', cheatIndexGlitch, '/', cheatCodeGlitch.length);
                    if (cheatIndexGlitch === cheatCodeGlitch.length) {
                        if (!saveData.unlocks.includes('glitch')) {
                            saveData.unlocks.push('glitch'); saveGame();
                            showNotification("REALITY BREACHED!", "⚡ GLITCH UNLOCKED ⚡");
                            unlockTrophy('unlock_glitch');
                        }
                        cheatIndexGlitch = 0;
                    }
                    matched = true;
                } else {
                    cheatIndexGlitch = 0;
                }

                // Konami Code
                if (key === cheatCodeKonami[cheatIndexKonami]) {
                    cheatIndexKonami++;
                    console.log('[DEBUG] Konami progress:', cheatIndexKonami, '/', cheatCodeKonami.length, '- Key pressed:', key);
                    if (cheatIndexKonami === cheatCodeKonami.length) {
                        const allSecrets = ['thememe', 'gps', 'mechabara', 'bluedude', 'johnpork', 'glitch', 'luckyblock', 'brokeboy'];
                        let unlocked = [];
                        allSecrets.forEach(id => {
                            if (!saveData.unlocks.includes(id)) {
                                saveData.unlocks.push(id);
                                unlocked.push(id);
                            }
                        });
                        // Max mastery for all characters
                        if (!saveData.mastery) saveData.mastery = {};
                        CHARACTERS.forEach(ch => {
                            if (!saveData.mastery[ch.id]) saveData.mastery[ch.id] = { wins: 0, matches: 0, damage: 0, level: 0 };
                            saveData.mastery[ch.id].wins = Math.max(saveData.mastery[ch.id].wins, 100);
                            saveData.mastery[ch.id].matches = Math.max(saveData.mastery[ch.id].matches, 100);
                            saveData.mastery[ch.id].level = 5;
                        });
                        unlocked.push('ALL MASTERIES');
                        if (!saveData.goldMode) {
                            saveData.goldMode = true;
                            unlocked.push('gold mode');
                        }
                        const allCosmetics = ['tophat', 'shades', 'crown'];
                        allCosmetics.forEach(cos => {
                            if (!saveData.cosmetics.includes(cos)) {
                                saveData.cosmetics.push(cos);
                                unlocked.push(cos);
                            }
                        });
                        saveData.coins += 2000;
                        saveData.gachaCoins = (saveData.gachaCoins || 0) + 3;
                        unlocked.push('2000 coins', '3 gacha coins');
                        saveGame();
                        updateCoinDisplay();
                        renderCharGrid && renderCharGrid();
                        // Check if Jack should be unlocked
                        checkJackUnlock();
                        showNotification("KONAMI CODE!", `SECRETS + MASTERIES!<br>${unlocked.map(u => u.toUpperCase()).join(', ')}`);
                        sfx.play('coin');
                        cheatIndexKonami = 0;
                        if (typeof renderMastery === 'function' && document.getElementById('mastery-screen') && !document.getElementById('mastery-screen').classList.contains('hidden')) {
                            renderMastery();
                        }
                    }
                    matched = true;
                } else if (!matched) {
                    cheatIndexKonami = 0;
                }

                // Pork Code
                if (key === cheatCodePork[cheatIndexPork]) {
                    cheatIndexPork++;
                    console.log('[DEBUG] cheatCodePork progress:', cheatIndexPork, '/', cheatCodePork.length);
                    if (cheatIndexPork === cheatCodePork.length) {
                        if (!saveData.unlocks.includes('johnpork')) {
                            saveData.unlocks.push('johnpork'); saveGame();
                            showNotification("SECRET UNLOCKED!", "JOHN PORK");
                            unlockTrophy('unlock_johnpork');
                            renderCharGrid();
                        }
                        cheatIndexPork = 0;
                    }
                    matched = true;
                } else {
                    cheatIndexPork = 0;
                }

                // Gacha Code
                if (key === cheatCodeGacha[cheatIndexGacha]) {
                    cheatIndexGacha++;
                    console.log('[DEBUG] cheatCodeGacha progress:', cheatIndexGacha, '/', cheatCodeGacha.length);
                    if (cheatIndexGacha === cheatCodeGacha.length) {
                        console.log('[DEBUG] Gacha code complete! Current unlocks:', saveData.unlocks);
                        if (!saveData.unlocks.includes('luckyblock')) {
                            saveData.unlocks.push('luckyblock');
                            saveGame();
                            showNotification("SECRET UNLOCKED!", "LUCKY BLOCK");
                            console.log('[DEBUG] Unlocked luckyblock. New unlocks:', saveData.unlocks);
                        } else {
                            console.log('[DEBUG] luckyblock already unlocked');
                        }
                        if (!saveData.unlocks.includes('brokeboy')) {
                            saveData.unlocks.push('brokeboy');
                            saveGame();
                            showNotification("SECRET UNLOCKED!", "BROKE BOY");
                            console.log('[DEBUG] Unlocked brokeboy. New unlocks:', saveData.unlocks);
                        } else {
                            console.log('[DEBUG] brokeboy already unlocked');
                        }
                        renderCharGrid();
                        cheatIndexGacha = 0;
                    }
                    matched = true;
                } else {
                    cheatIndexGacha = 0;
                }
            }
            keys[key] = !0;
            // Close quickhack menu on Escape
            if (quickhackMenuOpen && (key === 'Escape' || key === 'b' || key === 'B')) {
                closeQuickhackMenu();
                return;
            }
            // Quickhack navigation and selection
            if (quickhackMenuOpen) {
                // Number keys select from available hacks
                for (let qi = 0; qi < quickhackAvailable.length && qi < 7; qi++) {
                    if (key === String(qi + 1)) { selectQuickhack(quickhackAvailable[qi].id); return; }
                }
                if (key === 'ArrowUp' || key === 'w' || key === 'W') {
                    quickhackSelectedIndex = (quickhackSelectedIndex - 1 + quickhackAvailable.length) % quickhackAvailable.length;
                    return;
                }
                if (key === 'ArrowDown' || key === 's' || key === 'S') {
                    quickhackSelectedIndex = (quickhackSelectedIndex + 1) % quickhackAvailable.length;
                    return;
                }
                if (key === 'Enter' || key === ' ') {
                    selectQuickhack(quickhackAvailable[quickhackSelectedIndex].id);
                    return;
                }
            }
            if (gameState === 'GAME' && (key === 'Escape' || key === 'p')) togglePause();
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = !1;
            if (isTraining) {
                if (e.key === '1') {
                    trainingCpuMode = (trainingCpuMode + 1) % 4;
                    const m = ["STAND", "JUMP", "ATK", "EVADE"];
                    document.getElementById('train-cpu-mode').innerText = m[trainingCpuMode];
                }
                if (e.key === '2') {
                    players.forEach(p => p.pct = 0);
                    updateHUD();
                    sfx.play('coin');
                }
                if (e.key === '3') {
                    players[0].x = -200;
                    players[0].y = 0;
                    players[0].vx = 0;
                    players[1].x = 200;
                    players[1].y = 0;
                    players[1].vx = 0;
                    sfx.play('jump');
                }
                if (e.key === '4') {
                    toggleHitboxSetting();
                    document.getElementById('train-hitbox').innerText = showHitboxes ? "ON" : "OFF";
                }
            }
        });
        function startLocal() {
            music.init();
            sfx.init();
            isSurvival = !1;
            isTraining = !1;
            isMemeBall = !1;
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('char-select').classList.remove('hidden');
            document.getElementById('cpu-controls').classList.remove('hidden');
            renderCharGrid();
            music.play('MENU');
        }
        function startOnline() {
            music.init();
            audioFiles.init();
            sfx.init();
            isSurvival = !1; isTraining = !1; isMemeBall = !1; isOnline = true; isHost = false; netPeerReady = false;
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('online-screen').classList.remove('hidden');
            document.getElementById('online-status').textContent = '';
        }
        function hideOnline() {
            document.getElementById('online-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            try { if (netSocket) { netSocket.close(); netSocket = null; } } catch (e) { }
            isOnline = false; isHost = false; netRoom = null; netPeerReady = false;
        }
        function hostRoom() {
            const nickInput = document.getElementById('online-nickname');
            const nickname = (nickInput && nickInput.value.trim()) || 'Host';
            isHost = true; isOnline = true; netRoom = Math.random().toString(36).slice(2, 8).toUpperCase(); netReadyCount = 0; netPeerReady = false;
            netConnectedPlayers = [{ id: 'host', name: nickname + ' (Host)', ready: true }];
            netGameMode = '1v1';
            document.getElementById('online-room-code').textContent = netRoom;
            const box = document.getElementById('online-start-box'); if (box) box.style.display = 'none';
            const lobby = document.getElementById('online-lobby-list'); if (lobby) lobby.style.display = 'none';
            initSocket();
        }
        function joinRoom() {
            const code = (document.getElementById('online-join-code').value || '').trim().toUpperCase();
            if (!code) { document.getElementById('online-status').textContent = 'Enter a room code'; return; }
            const nickInput = document.getElementById('online-nickname');
            const nickname = (nickInput && nickInput.value.trim()) || 'Player';
            isHost = false; isOnline = true; netRoom = code; netReadyCount = 0; netPeerReady = false;
            netConnectedPlayers = [];
            const box = document.getElementById('online-start-box'); if (box) box.style.display = 'none';
            const lobby = document.getElementById('online-lobby-list'); if (lobby) lobby.style.display = 'none';
            initSocket();
        }
        function quickMatch() {
            const nickInput = document.getElementById('online-nickname');
            const nickname = (nickInput && nickInput.value.trim()) || 'Player';
            // Generate a quick match code with "QM" prefix
            const quickCode = 'QM' + Math.random().toString(36).slice(2, 6).toUpperCase();
            isHost = false; isOnline = true; netRoom = quickCode; netReadyCount = 0; netPeerReady = false;
            netConnectedPlayers = [];
            const box = document.getElementById('online-start-box'); if (box) box.style.display = 'none';
            const lobby = document.getElementById('online-lobby-list'); if (lobby) lobby.style.display = 'none';
            document.getElementById('online-status').textContent = 'Quick matching...';
            initSocket();
        }
        function normalizeWSURL(raw) {
            let u = (raw || '').trim();
            if (!u) return 'ws://localhost:8080';
            // Convert http/https schemes
            if (u.startsWith('http://')) u = 'ws://' + u.slice(7);
            else if (u.startsWith('https://')) u = 'wss://' + u.slice(8);
            // If user pasted a railway/render domain without protocol
            if (!u.startsWith('ws://') && !u.startsWith('wss://')) {
                // Prefer ws for local dev, wss for remote
                if (u.startsWith('localhost') || u.startsWith('127.') || u.startsWith('192.168.')) {
                    u = 'ws://' + u;
                } else {
                    u = 'wss://' + u;
                }
            }
            return u;
        }
        function initSocket() {
            netOpened = false;
            try {
                const urlInput = document.getElementById('online-ws-url');
                const WS_URL = normalizeWSURL(urlInput && urlInput.value ? urlInput.value : 'ws://localhost:8080');
                const st = document.getElementById('online-status');
                if (st) st.textContent = 'Connecting to ' + WS_URL + ' ...';
                netSocket = new WebSocket(WS_URL);
                netSocket.onerror = () => {
                    const st2 = document.getElementById('online-status');
                    if (st2) st2.textContent = 'Connection failed. Ensure a WebSocket server is running at that URL (use wss:// for hosted domains).';
                };
                netSocket.onclose = () => {
                    // Only show Disconnected if connection was previously opened
                    const st = document.getElementById('online-status');
                    if (netOpened && st && isOnline) {
                        st.textContent = 'Disconnected';
                        // If disconnect happens mid-match, pause and show notification
                        if (gameState === 'GAME' && !netDisconnected) {
                            netDisconnected = true;
                            gameState = 'PAUSED';
                            showDisconnectNotification();
                        }
                    }
                };
            } catch (e) {
                const st = document.getElementById('online-status');
                if (st) st.textContent = 'Server connection failed. Check server URL and availability.';
                return;
            }
            netSocket.onopen = () => {
                netOpened = true;
                const nickInput = document.getElementById('online-nickname');
                const nickname = (nickInput && nickInput.value.trim()) || 'Player';
                // Include friendCode so peers can verify and record stats
                try { initFriendCode(); } catch (e) { }
                sendNet({ t: 'join', room: netRoom, host: !!isHost, nickname: nickname, friendCode: saveData && saveData.friendCode ? saveData.friendCode : undefined });
                document.getElementById('online-status').textContent = 'Joined relay. Negotiating room...';
            };
            netSocket.onmessage = ev => {
                let msg; try { msg = JSON.parse(ev.data); } catch (e) { return; }
                if (msg.t === 'joined') {
                    document.getElementById('online-status').textContent = 'Room created. Waiting for players...';
                    updateLobbyList();
                    initOnlineCharSelect();
                } else if (msg.t === 'playerlist') {
                    // Server sends updated player list
                    if (msg.players) {
                        const oldCount = netConnectedPlayers.length;
                        // Preserve friendCode if provided by server; otherwise keep name/ready/id
                        netConnectedPlayers = msg.players.map(p => ({
                            id: p.id,
                            name: p.name,
                            ready: !!p.ready,
                            friendCode: p.friendCode || p.code || p.fc
                        }));
                        const newCount = netConnectedPlayers.length;
                        // If player left during match, pause and notify
                        if (gameState === 'GAME' && newCount < oldCount && !netDisconnected) {
                            netDisconnected = true;
                            gameState = 'PAUSED';
                            showDisconnectNotification();
                        }
                        netReadyCount = msg.players.length;
                        updateLobbyList();
                        try { verifyFriendsAgainstLobby(); } catch (e) { }
                        if (isHost) {
                            const minPlayers = (netGameMode === '2v2') ? 4 : 2;
                            if (netReadyCount >= minPlayers) {
                                netPeerReady = true;
                                document.getElementById('online-status').textContent = `Ready! ${netReadyCount}/${minPlayers} players`;
                                const box = document.getElementById('online-start-box'); if (box) box.style.display = 'flex';
                                initOnlineCharSelect();
                            } else {
                                document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers} players`;
                                const box = document.getElementById('online-start-box'); if (box) box.style.display = 'none';
                            }
                        } else {
                            document.getElementById('online-status').textContent = 'Connected! Waiting for host...';
                            netPeerReady = true;
                        }
                    }
                } else if (msg.t === 'ready') {
                    // Legacy ready handling (fallback if server doesn't send playerlist)
                    netReadyCount++;
                    if (isHost) {
                        const minPlayers = (netGameMode === '2v2') ? 4 : 2;
                        if (netReadyCount >= minPlayers) {
                            netPeerReady = true;
                            document.getElementById('online-status').textContent = `Player joined! ${netReadyCount}/${minPlayers}`;
                            const box = document.getElementById('online-start-box'); if (box) box.style.display = 'flex';
                        } else {
                            document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers}`;
                        }
                    } else {
                        document.getElementById('online-status').textContent = 'Connected! Waiting for host...';
                        netPeerReady = true;
                    }
                } else if (msg.t === 'inp' && isHost) {
                    // Host maps client inputs to player slots (P2, P3, P4) by playerId
                    const k = msg.k; const v = msg.v ? 1 : 0;
                    const pid = msg.playerId;

                    // Assign player slot based on connection order
                    let slot = 'p2'; // default
                    const playerIndex = netConnectedPlayers.findIndex(p => p.id === pid);
                    if (playerIndex === 1) slot = 'p2';
                    else if (playerIndex === 2) slot = 'p3';
                    else if (playerIndex === 3) slot = 'p4';

                    try {
                        // All online players use WASD by default
                        const left = getControl(slot, 'left') || 'a';
                        const right = getControl(slot, 'right') || 'd';
                        const up = getControl(slot, 'up') || 'w';
                        const down = getControl(slot, 'down') || 's';
                        const attack = getControl(slot, 'attack') || 'f';
                        const ult = getControl(slot, 'ult') || 'r';
                        const shield = getControl(slot, 'shield') || 'g';
                        const eq = (a, b) => (a === b) || (a && b && a.toLowerCase && b.toLowerCase && a.toLowerCase() === b.toLowerCase());

                        let targetInputs = netP2Inputs;
                        if (slot === 'p3') targetInputs = netP3Inputs;
                        else if (slot === 'p4') targetInputs = netP4Inputs;

                        if (eq(k, left)) targetInputs.l = v;
                        if (eq(k, right)) targetInputs.r = v;
                        if (eq(k, up)) { targetInputs.u = v; targetInputs.j = v; }
                        if (eq(k, down)) targetInputs.d = v;
                        if (eq(k, attack)) targetInputs.a = v;
                        if (eq(k, ult)) targetInputs.U = v;
                        if (eq(k, shield)) targetInputs.S = v;
                    } catch (e) { }
                } else if (msg.t === 'start') {
                    // Host instructs client to start with chosen settings
                    isMemeBall = msg.mode === 'meme'; isSurvival = false; isTraining = false;
                    netGameMode = msg.gameMode || '1v1'; // Receive mode from host
                    p1Char = CHARACTERS.find(c => c.id === msg.p1);
                    p2Char = CHARACTERS.find(c => c.id === msg.p2);
                    selectedMap = MAPS.find(m => m.id === msg.map) || MAPS[0];
                    customStocks = msg.stocks || 3;
                    rulesItemsEnabled = msg.items !== undefined ? msg.items : true;
                    rulesHazardsEnabled = msg.hazards !== undefined ? msg.hazards : true;
                    rulesTeamAttack = msg.teamAttack || false;
                    const ts = document.getElementById('title-screen'); if (ts) ts.classList.add('hidden');
                    const os = document.getElementById('online-screen'); if (os) os.classList.add('hidden');
                    const sb = document.getElementById('online-start-box'); if (sb) sb.style.display = 'none';
                    const hud = document.getElementById('hud'); if (hud) hud.classList.remove('hidden');
                    // Initialize scene but as client renderer
                    if (isMemeBall) beginMemeBall(); else startGame();
                } else if (msg.t === 'state') {
                    applyNetState(msg.s);
                } else if (msg.t === 'ping') {
                    sendNet({ t: 'pong' });
                }
            };
            netSocket.onclose = () => {
                if (isOnline) document.getElementById('online-status').textContent = 'Disconnected';
            };
        }
        function showDisconnectNotification(isHostDisconnect = false) {
            // Create overlay notification
            const overlay = document.createElement('div');
            overlay.id = 'disconnect-overlay';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center';
            const title = document.createElement('div');
            title.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#ff4444;margin-bottom:20px";
            title.textContent = isHostDisconnect ? 'HOST DISCONNECTED' : 'PLAYER DISCONNECTED';
            const msg = document.createElement('div');
            msg.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#fff;margin-bottom:30px;text-align:center;max-width:500px;line-height:1.8";
            msg.textContent = isHostDisconnect ? 'The host has left the match.' : 'A player has disconnected from the match.';
            const btn = document.createElement('button');
            btn.className = 'menu-btn';
            btn.textContent = 'RETURN TO LOBBY';
            btn.onclick = () => {
                document.body.removeChild(overlay);
                hideOnline();
                showTitle();
            };
            overlay.appendChild(title);
            overlay.appendChild(msg);
            overlay.appendChild(btn);
            document.body.appendChild(overlay);
        }
        function showDisconnectNotification(isHostDisconnect = false) {
            // Create overlay notification
            const overlay = document.createElement('div');
            overlay.id = 'disconnect-overlay';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center';
            const title = document.createElement('div');
            title.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#ff4444;margin-bottom:20px";
            title.textContent = isHostDisconnect ? 'HOST DISCONNECTED' : 'PLAYER DISCONNECTED';
            const msg = document.createElement('div');
            msg.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#fff;margin-bottom:30px;text-align:center;max-width:500px;line-height:1.8";
            msg.textContent = isHostDisconnect ? 'The host has left the match.' : 'A player has disconnected from the match.';
            const btn = document.createElement('button');
            btn.className = 'menu-btn';
            btn.textContent = 'RETURN TO LOBBY';
            btn.onclick = () => {
                document.body.removeChild(overlay);
                hideOnline();
                showTitle();
            };
            overlay.appendChild(title);
            overlay.appendChild(msg);
            overlay.appendChild(btn);
            document.body.appendChild(overlay);
        }
        function sendNet(obj) { try { if (netSocket && netSocket.readyState === 1) netSocket.send(JSON.stringify(obj)); } catch (e) { } }

        function selectOnlineMode(mode) {
            if (!isHost) return;
            netGameMode = mode;
            // Update button styles
            const btn1v1 = document.getElementById('mode-1v1-btn');
            const btn2v2 = document.getElementById('mode-2v2-btn');
            if (mode === '1v1') {
                if (btn1v1) { btn1v1.style.background = '#0f0'; btn1v1.style.color = '#000'; }
                if (btn2v2) { btn2v2.style.background = ''; btn2v2.style.color = ''; }
            } else {
                if (btn1v1) { btn1v1.style.background = ''; btn1v1.style.color = ''; }
                if (btn2v2) { btn2v2.style.background = '#0f0'; btn2v2.style.color = '#000'; }
            }
            // Re-check player count requirement
            const minPlayers = (netGameMode === '2v2') ? 4 : 2;
            if (netReadyCount >= minPlayers) {
                netPeerReady = true;
                document.getElementById('online-status').textContent = `Ready! ${netReadyCount}/${minPlayers} players`;
                const box = document.getElementById('online-start-box'); if (box) box.style.display = 'flex';
            } else {
                netPeerReady = false;
                document.getElementById('online-status').textContent = `Waiting... ${netReadyCount}/${minPlayers} players`;
                const box = document.getElementById('online-start-box'); if (box) box.style.display = 'none';
            }
        }

        function updateLobbyList() {
            const listEl = document.getElementById('online-player-list');
            const lobbyEl = document.getElementById('online-lobby-list');
            const ctrlEl = document.getElementById('online-controls-help');
            if (!listEl || !lobbyEl) return;

            if (netConnectedPlayers.length > 0) {
                lobbyEl.style.display = 'flex';
                if (ctrlEl) ctrlEl.style.display = 'flex';
                let html = '';
                netConnectedPlayers.forEach((p, i) => {
                    const icon = p.ready ? '✓' : '○';
                    const color = p.ready ? '#0f0' : '#888';
                    const fc = p.friendCode ? ` <span style="color:#666">(${p.friendCode})</span>` : '';
                    html += `<div style="color:${color}">${icon} ${p.name || 'Player ' + (i + 1)}${fc}</div>`;
                });
                listEl.innerHTML = html;
            } else {
                lobbyEl.style.display = 'none';
                if (ctrlEl) ctrlEl.style.display = 'none';
            }
        }

        // Mark friends as verified if their code appears in the current lobby
        function verifyFriendsAgainstLobby() {
            if (!saveData || !saveData.friends || saveData.friends.length === 0) return;
            let changed = false;
            const codesInLobby = new Set(netConnectedPlayers.filter(p => p.friendCode).map(p => p.friendCode));
            saveData.friends.forEach(f => {
                if (f && f.code && codesInLobby.has(f.code)) {
                    if (!f.verified) { f.verified = true; changed = true; }
                    const p = netConnectedPlayers.find(p => p.friendCode === f.code);
                    if (p && p.name && f.name !== p.name) { f.name = p.name; changed = true; }
                    f.lastSeenAt = Date.now();
                }
            });
            if (changed) { try { saveGame(); renderFriends(); } catch (e) { } }
        }

        function initOnlineCharSelect() {
            try {
                const p1Sel = document.getElementById('online-p1-char');
                const p2Sel = document.getElementById('online-p2-char');
                if (!p1Sel || !p2Sel) return;
                // Populate options
                const makeOpts = sel => {
                    sel.innerHTML = '';
                    CHARACTERS.forEach(c => {
                        const opt = document.createElement('option');
                        opt.value = c.id; opt.textContent = `${c.icon} ${c.name}`;
                        sel.appendChild(opt);
                    });
                };
                makeOpts(p1Sel); makeOpts(p2Sel);
                // Set defaults
                p1Sel.value = (p1Char && p1Char.id) || 'doge';
                p2Sel.value = (p2Char && p2Char.id) || 'chad';
                const prev = document.getElementById('online-picked-preview');
                const renderPrev = () => {
                    const c1 = CHARACTERS.find(x => x.id === p1Sel.value);
                    const c2 = CHARACTERS.find(x => x.id === p2Sel.value);
                    if (prev) prev.textContent = `P1: ${c1 ? (c1.icon + ' ' + c1.name) : p1Sel.value} | P2: ${c2 ? (c2.icon + ' ' + c2.name) : p2Sel.value}`;
                };
                p1Sel.onchange = renderPrev; p2Sel.onchange = renderPrev; renderPrev();
            } catch (e) { }
        }

        function onlineStart(mode) {
            if (!isHost || !netPeerReady) return;
            try {
                // Default characters if not chosen yet
                const p1Sel = document.getElementById('online-p1-char');
                const p2Sel = document.getElementById('online-p2-char');
                const p1Pick = p1Sel && p1Sel.value ? p1Sel.value : ((p1Char && p1Char.id) || 'doge');
                const p2Pick = p2Sel && p2Sel.value ? p2Sel.value : ((p2Char && p2Char.id) || 'chad');
                p1Char = CHARACTERS.find(c => c.id === p1Pick) || CHARACTERS.find(c => c.id === 'doge') || CHARACTERS[0];
                p2Char = CHARACTERS.find(c => c.id === p2Pick) || CHARACTERS.find(c => c.id === 'chad') || CHARACTERS[1];
                const stageSel = document.getElementById('online-stage-sel');
                const stocksInput = document.getElementById('online-stocks');
                const stageId = (stageSel && stageSel.value) || 'flat';
                const stocks = (stocksInput && parseInt(stocksInput.value)) || 3;
                customStocks = stocks; // Set global for host
                // Read custom rules
                const itemsCheck = document.getElementById('online-items');
                const hazardsCheck = document.getElementById('online-hazards');
                const teamAttackCheck = document.getElementById('online-teamattack');
                rulesItemsEnabled = itemsCheck ? itemsCheck.checked : true;
                rulesHazardsEnabled = hazardsCheck ? hazardsCheck.checked : true;
                rulesTeamAttack = teamAttackCheck ? teamAttackCheck.checked : false;
                selectedMap = MAPS.find(m => m.id === stageId) || MAPS[0];
                sendNet({ t: 'start', mode: mode === 'meme' ? 'meme' : 'vs', gameMode: netGameMode, p1: p1Char.id, p2: p2Char.id, map: selectedMap.id, stocks: stocks, items: rulesItemsEnabled, hazards: rulesHazardsEnabled, teamAttack: rulesTeamAttack });
                document.getElementById('online-screen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                isSurvival = false; isTraining = false; isMemeBall = (mode === 'meme');
                if (isMemeBall) beginMemeBall(); else startGame();
            } catch (e) { }
        }

        // Client: capture inputs and send to host
        window.addEventListener('keydown', e => {
            if (isOnline && !isHost && netPeerReady) sendNet({ t: 'inp', k: e.key, v: 1 });
        });
        window.addEventListener('keyup', e => {
            if (isOnline && !isHost && netPeerReady) sendNet({ t: 'inp', k: e.key, v: 0 });
        });

        function applyNetState(s) {
            try {
                if (!isOnline || isHost) return;
                // players - sync all received player states
                if (players && s.players) {
                    const numPlayers = Math.min(players.length, s.players.length);
                    for (let i = 0; i < numPlayers; i++) {
                        const sp = s.players[i];
                        if (!players[i] || !sp) continue;
                        players[i].x = sp.x; players[i].y = sp.y; players[i].vx = sp.vx; players[i].vy = sp.vy;
                        players[i].pct = sp.pct; players[i].stocks = sp.stocks; players[i].ult = sp.ult;
                    }
                    // Refresh HUD to reflect authoritative host values (damage %, stocks, ult charge)
                    if (typeof updateHUD === 'function') updateHUD();
                }
                if (typeof isMemeBall !== 'undefined' && s.ball && ball) {
                    ball.x = s.ball.x; ball.y = s.ball.y; ball.vx = s.ball.vx; ball.vy = s.ball.vy;
                    ball.inPlay = s.ball.inPlay; ball.hasCrossedNet = s.ball.cross;
                }
                if (typeof p1Score !== 'undefined' && s.score) {
                    p1Score = s.score[0]; p2Score = s.score[1];
                    const sc = document.getElementById('game-score-val'); if (sc) sc.innerText = `${p1Score} - ${p2Score}`;
                }
            } catch (e) { }
        }
        function startSurvival() {
            music.init();
            sfx.init();
            isSurvival = !0;
            isTraining = !1;
            isMemeBall = !1;
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('char-select').classList.remove('hidden');
            document.getElementById('cpu-controls').classList.remove('hidden');
            document.getElementById('select-instruction').innerText = "CHOOSE YOUR HEROES";
            renderCharGrid();
            music.play('MENU');
        }
        function startTraining() {
            music.init();
            sfx.init();
            isTraining = !0;
            isSurvival = !1;
            isMemeBall = !1;
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('char-select').classList.remove('hidden');
            document.getElementById('cpu-controls').classList.add('hidden');
            document.getElementById('select-instruction').innerText = "CHOOSE HERO";
            renderCharGrid();
            music.play('MENU');
        }
        function startSpectator() {
            music.init();
            sfx.init();
            isTraining = !1;
            isSurvival = !1;
            isMemeBall = !1;

            // Auto-select two random unlocked characters
            const unlocked = CHARACTERS.filter(c => saveData.unlocks.includes(c.id));
            if (unlocked.length < 2) {
                alert('Unlock more characters to use Spectator Mode!');
                return;
            }

            p1Char = unlocked[Math.floor(Math.random() * unlocked.length)];
            p2Char = unlocked[Math.floor(Math.random() * unlocked.length)];
            while (p2Char.id === p1Char.id) {
                p2Char = unlocked[Math.floor(Math.random() * unlocked.length)];
            }

            // Set both to CPU
            p2IsCpu = true;

            // Random map
            selectedMap = MAPS[Math.floor(Math.random() * MAPS.length)];

            showNotification('SPECTATOR MODE', `${p1Char.name} VS ${p2Char.name}`);

            // Start immediately
            document.getElementById('title-screen').classList.add('hidden');
            setTimeout(() => {
                document.getElementById('hud').classList.remove('hidden');
                initGame();
                saveMatchSettings();
                gameState = 'GAME';
                music.play('BATTLE');
                loop();
            }, 1000);
        }
        function startMemeBall() {
            music.init();
            sfx.init();
            isMemeBall = !0;
            isSurvival = !1;
            isTraining = !1;
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('char-select').classList.remove('hidden');
            document.getElementById('cpu-controls').classList.add('hidden');
            document.getElementById('select-instruction').innerText = "CHOOSE PLAYER";
            renderCharGrid();
            music.play('MENU');
        }
        function showMoves() {
            sfx.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('moves-screen').classList.remove('hidden');
            // Hide overlapping HUD elements while viewing moves
            const coin = document.getElementById('coin-display'); if (coin) coin.dataset.prevDisplay = coin.style.display, coin.style.display = 'none';
            const warn = document.getElementById('mega-warning'); if (warn) warn.dataset.prevDisplay = warn.style.display, warn.style.display = 'none';
            const secret = document.getElementById('secret-unlock'); if (secret) secret.dataset.prevDisplay = secret.style.display, secret.style.display = 'none';
            const c = document.getElementById('moves-content');
            c.innerHTML = `
        <div>
            <h3>Universal Moves (All Characters)</h3>
            <ul>
                <li><strong>Neutral Attack</strong> (F/L): 8% dmg • low KB • 30f CD.</li>
                <li><strong>Side Attack</strong> (←/→ + F/L): 12% dmg • med-high horiz KB • 30f CD.</li>
                <li><strong>Up Attack</strong> (↑ + F/L): 10% dmg • high vertical KB • 30f CD.</li>
                <li><strong>Down Attack</strong> (↓ + F/L): 10% dmg • pop-up • 30f CD.</li>
            </ul>
        </div>
        <h3>Roster Details</h3>
        <div class="moves-grid" id="moves-grid"></div>
        `;

            // Add CSS to make modal work properly
            const styleTagId = 'moves-modal-style';
            if (!document.getElementById(styleTagId)) {
                const style = document.createElement('style');
                style.id = styleTagId;
                style.textContent = `
                    #moves-screen { padding-top: 20px; }
                    #move-detail { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 500; }
                    #move-detail.show { display: flex; }
                    .move-card { cursor: pointer; transition: transform 0.2s; }
                    .move-card:hover { transform: scale(1.02); }
                `;
                document.head.appendChild(style);
            }

            // Define complete character detail content map before cards are built
            window._moveDetailContent = {
                'doge': {
                    specials: 'Uses universal moveset.',
                    ult: 'Moon Crash: Summon falling moon at opponent; strong projectile for pressure and kills.'
                },
                'frog': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'cat': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'capy': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'spongy': {
                    specials: 'Uses universal moveset. Low weight makes combo-friendly.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'troll': {
                    specials: 'Uses universal moveset.',
                    ult: 'Mega Hit: 40% dmg, very high horizontal knockback.'
                },
                'sanic': {
                    specials: 'Universal standard attacks.',
                    ult: 'Light Speed: Teleport to opponent, 30% hit, 1s invincibility.'
                },
                'chad': {
                    specials: 'Universal; high power/weight amplify effectiveness.',
                    ult: 'Giga Stun: 180f stun; guaranteed follow-up setup.'
                },
                '67kid': {
                    specials: 'Up: Self 67% dmg + stun. Down: Ground pound, 10% dmg, strong vertical KB.',
                    ult: 'Brain Rot: Reverse opponent velocity + 60f stun; gimp recoveries.'
                },
                'amogus': {
                    specials: 'Side: Vent dash (no hitbox). Up: High vertical recovery.',
                    ult: 'Emergency Meeting: Screen nuke ~50% dmg.'
                },
                'sahur': {
                    specials: 'Down: 200x40 hitbox, 20% dmg. Up: 12% dmg, very high vertical KB. Side: 15% dmg high KB.',
                    ult: 'Deafening Beat: 180f stun; setup tool.'
                },
                'primo': {
                    specials: 'Down: Wide ground-pound. Up: Diagonal recovery with hitbox. Side: Fast dash 12% dmg.',
                    ult: 'Tag Team: Summon projectile Primo across screen.'
                },
                'ocralito': {
                    specials: 'Down: 150px belly flop 14%. Up: Safe vertical recovery 10%. Side: Belly slide reduces friction to 0.98.',
                    ult: 'Deep Freeze: 120f stun.'
                },
                'mechabara': {
                    specials: 'Down: Ground Laser pops up (16%). Up: Huge vertical jump (10%). Side: Drill Lunge multi-hit.',
                    ult: 'Orbital Strike: Falling projectile (moon style).'
                },
                'bluedude': {
                    specials: 'Down: 15f parry + 25% counter. Up: 100x100 spin 12%. Side: Blade Dash 9%.',
                    ult: 'Zero Slash: Massive close-range slash, 35%.'
                },
                'johnpork': {
                    specials: 'Down: Global 10%. Up: Random buff 5s. Side: 120f stun.',
                    ult: 'Pig Slam: Falling pig, extreme KB, 100%.'
                },
                'thememe': {
                    specials: 'All stats 999; universal moves overpower.',
                    ult: 'DEATH: 999%.'
                },
                'gps': {
                    specials: 'Down: Confuse 5s. Up: Vertical teleport. Side: Horizontal teleport.',
                    ult: 'Global Rotation: Flip stage physics ~10s.'
                },
                'luckyblock': {
                    specials: 'Side: 50% chance for 5x rapid 100% hits. Up: Spawn coin + delayed hit. Down: Crush from above.',
                    ult: 'Gambling Fever: Random slot machine buffs for 20s.'
                },
                'brokeboy': {
                    specials: 'Side: Beg/boost chance; side animation. Up: Sucker Punch with custom animation. Down: Parry (shield).',
                    ult: 'Mrbeast: Temporary power/speed/weight/inv boost; plays unique ult animation.'
                },
                'glitch': {
                    specials: 'Side: Pixel Shift (70% forward/30% reverse dash). Up: Data Corruption (random teleport + 10% position swap). Down: Reality Break (50% stun opponent 60f OR self 30f).',
                    ult: 'System Crash: Reverse opponent controls 3s + 1.5x damage.'
                }
            };

            // Build roster cards if not already and attach handlers
            const grid = document.getElementById('moves-grid');
            if (grid) {
                // If grid is empty, build from available CHARACTERS
                if (!grid.children.length && typeof CHARACTERS !== 'undefined' && Array.isArray(CHARACTERS)) {
                    const toCard = (ch) => {
                        const stats = `<span class=statline>Speed: ${ch.speed} • Power: ${ch.power} • Jump: ${ch.jump} • Weight: ${ch.weight}</span>`;
                        return `
                        <div class="move-card" data-char-key="${ch.id}">
                          <div class="move-thumb"><canvas width="16" height="16" id="moves-thumb-${ch.id}" style="width:48px;height:48px"></canvas></div>
                          <div class="move-details">
                            <div class="move-title">${ch.name}</div>
                            ${stats}
                            <div><span class="badge">SIDE</span>${ch.moves.side}</div>
                            <div><span class="badge">UP</span>${ch.moves.up}</div>
                            <div><span class="badge">DOWN</span>${ch.moves.down}</div>
                            <div><span class="badge">ULT</span>${ch.moves.ult}</div>
                          </div>
                        </div>`;
                    };
                    grid.innerHTML = CHARACTERS.map(toCard).join('');
                    // Render thumbnails
                    CHARACTERS.forEach(ch => {
                        const cvs = document.getElementById(`moves-thumb-${ch.id}`);
                        if (!cvs) return;
                        const mctx = cvs.getContext('2d');
                        mctx.imageSmoothingEnabled = !1;
                        const spr = characterSprites[ch.id];
                        if (spr) {
                            if (spr.idle && spr.idle[0]) {
                                mctx.drawImage(spr.idle[0], 0, 0, cvs.width, cvs.height);
                            } else {
                                mctx.drawImage(spr, 0, 0, cvs.width, cvs.height);
                            }
                        } else {
                            mctx.font = "16px Arial";
                            mctx.textAlign = "center";
                            mctx.textBaseline = "middle";
                            mctx.fillText(ch.icon || '?', 8, 8);
                        }
                    });
                }

                const openModal = (ch, entry) => {
                    const modalEl = document.getElementById('move-detail');
                    if (!modalEl) return;
                    document.getElementById('move-detail-title').innerText = ch?.name || 'Character';
                    document.getElementById('move-detail-stats').innerHTML = `Speed: ${ch?.speed || '—'} • Power: ${ch?.power || '—'} • Jump: ${ch?.jump || '—'} • Weight: ${ch?.weight || '—'}`;
                    document.getElementById('move-detail-universal').innerHTML = `<strong>Universal Attacks</strong><br>Neutral: 8% dmg • low KB • 30f CD<br>Side: 12% dmg • med-high horiz KB • 30f CD<br>Up: 10% dmg • high vertical KB • 30f CD<br>Down: 10% dmg • pop-up • 30f CD`;
                    document.getElementById('move-detail-specials').innerHTML = `<strong>Special Moves</strong><br>${entry.specials}`;
                    document.getElementById('move-detail-ult').innerHTML = `<strong>Ultimate</strong><br>${entry.ult}`;
                    modalEl.classList.add('show');
                };

                const closeModal = () => {
                    const modalEl = document.getElementById('move-detail');
                    if (modalEl) modalEl.classList.remove('show');
                };
                // Make closeModal available globally for the CLOSE button
                window.closeMoveDetail = closeModal;

                // Close handlers
                const closeBtn = document.getElementById('move-detail-close');
                if (closeBtn) closeBtn.onclick = closeModal;
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeModal();
                });
                document.getElementById('move-detail')?.addEventListener('click', (e) => {
                    if (e.target.id === 'move-detail') closeModal();
                });

                // Card click handlers
                Array.from(grid.children).forEach((el) => {
                    if (!el.dataset.bound) {
                        el.dataset.bound = '1';
                        el.addEventListener('click', () => {
                            const key = el.getAttribute('data-char-key');
                            const ch = CHARACTERS.find(c => c.id === key);
                            const entry = window._moveDetailContent?.[key] || { specials: 'Uses universal moves.', ult: 'Default ult' };
                            openModal(ch, entry);
                        });
                    }
                });
            }
            // Old card build removed to prevent duplicate variable declarations and handlers
        }
        function hideMoves() {
            document.getElementById('moves-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            // Restore HUD elements
            const coin = document.getElementById('coin-display'); if (coin) coin.style.display = coin.dataset.prevDisplay || '';
            const warn = document.getElementById('mega-warning'); if (warn) warn.style.display = warn.dataset.prevDisplay || '';
            const secret = document.getElementById('secret-unlock'); if (secret) secret.style.display = secret.dataset.prevDisplay || '';
        }
        function openMoveDetail(id) {
            const ch = CHARACTERS.find(c => c.id === id);
            if (!ch) return;
            const md = document.getElementById('move-detail');
            md.style.display = 'flex';
            document.getElementById('move-detail-title').innerText = ch.name;
            document.getElementById('move-detail-stats').innerHTML = `Speed: ${ch.speed} • Power: ${ch.power} • Jump: ${ch.jump} • Weight: ${ch.weight}`;
            const uni = document.getElementById('move-detail-universal');
            uni.innerHTML = `<strong>Universal Attacks</strong><br>Neutral 8% • Side 12% • Up 10% • Down 10% • Typical CD: 30f`;
            const spec = document.getElementById('move-detail-specials');
            const ult = document.getElementById('move-detail-ult');
            const entry = (window._moveDetailContent || {})[id] || { specials: 'Uses universal moves.', ult: 'Default ult' };
            spec.innerHTML = `<strong>Specials</strong><br>${entry.specials}`;
            ult.innerHTML = `<strong>Ult</strong><br>${entry.ult}`;
            // Render thumb
            const cvs = document.getElementById('move-detail-thumb');
            const ctx2 = cvs.getContext('2d');
            ctx2.clearRect(0, 0, cvs.width, cvs.height);
            ctx2.imageSmoothingEnabled = !1;
            const spr = characterSprites[id];
            if (spr) {
                if (spr.idle && spr.idle[0]) ctx2.drawImage(spr.idle[0], 0, 0, cvs.width, cvs.height);
                else ctx2.drawImage(spr, 0, 0, cvs.width, cvs.height);
            } else {
                ctx2.font = "48px Arial"; ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle'; ctx2.fillText(ch.icon || '?', cvs.width / 2, cvs.height / 2);
            }
        }
        function closeMoveDetail() {
            document.getElementById('move-detail').style.display = 'none';
        }
        function openSettings() {
            sfx.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('settings-screen').classList.remove('hidden');
            updateMobileControlsSetting();
        }
        function closeSettings() {
            document.getElementById('settings-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        }
        function deleteSaveFile() {
            if (confirm('Are you sure you want to delete your save file? This will reset all progress, coins, unlocks, and cosmetics. This action cannot be undone!')) {
                localStorage.removeItem(SAVE_KEY);
                alert('Save file deleted! The game will now reload.');
                location.reload();
            }
        }
        function toggleHitboxSetting() {
            showHitboxes = !showHitboxes;
            const b = document.getElementById('btn-hitbox');
            if (showHitboxes) {
                b.innerText = "ON";
                b.className = "toggle-btn toggle-on";
            } else {
                b.innerText = "OFF";
                b.className = "toggle-btn toggle-off";
            }
            sfx.play('coin');
        }
        function toggleMusicSetting() {
            let e = music.toggle();
            const b = document.getElementById('btn-music');
            if (u) {
                // Up attack: use custom up-attack animation and lock for a bit
                this.playAnimation("attack_up", 36);
            } else {
                b.innerText = "OFF";
                b.className = "toggle-btn toggle-off";
            }
            sfx.play('coin');
        }
        function toggleMobileSetting() {
            saveData.mobileControls = !saveData.mobileControls;
            saveGame();
            updateMobileControlsSetting();
            sfx.play('coin');
        }
        function updateMobileControlsSetting() {
            const b = document.getElementById('btn-mobile');
            const controls = document.getElementById('mobile-controls');
            const touchCapable = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (b) {
                if (saveData.mobileControls) {
                    b.innerText = "ON";
                    b.className = "toggle-btn toggle-on";
                } else {
                    b.innerText = "OFF";
                    b.className = "toggle-btn toggle-off";
                }
            }
            if (saveData.mobileControls && touchCapable) {
                controls.style.display = 'block';
            } else {
                controls.style.display = 'none';
            }
        }
        function showTrophies() {
            sfx.init();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('trophy-screen').classList.remove('hidden');
            renderTrophies();
        }
        function hideTrophies() {
            document.getElementById('trophy-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        }

        // ========== MASTERY SYSTEM ==========
        function initMastery(charId) {
            if (!saveData.mastery) saveData.mastery = {};
            if (!saveData.mastery[charId]) {
                saveData.mastery[charId] = { wins: 0, matches: 0, damage: 0, level: 0 };
            }
        }
        function trackMatch(charId, won, damageDealt) {
            initMastery(charId);
            saveData.mastery[charId].matches++;
            if (won) saveData.mastery[charId].wins++;
            saveData.mastery[charId].damage += Math.floor(damageDealt);

            // Calculate level: Bronze(5), Silver(15), Gold(30), Diamond(50), Master(100)
            const wins = saveData.mastery[charId].wins;
            let oldLevel = saveData.mastery[charId].level;
            if (wins >= 100) saveData.mastery[charId].level = 5;
            else if (wins >= 50) saveData.mastery[charId].level = 4;
            else if (wins >= 30) saveData.mastery[charId].level = 3;
            else if (wins >= 15) saveData.mastery[charId].level = 2;
            else if (wins >= 5) saveData.mastery[charId].level = 1;

            saveGame();
            return saveData.mastery[charId].level > oldLevel;
        }
        function getMasteryRank(level) {
            const ranks = ['UNRANKED', 'BRONZE', 'SILVER', 'GOLD', 'DIAMOND', 'MASTER'];
            const colors = ['#666', '#cd7f32', '#c0c0c0', '#ffd700', '#b9f2ff', '#ff00ff'];
            const icons = ['', '🥉', '🥈', '🥇', '💎', '👑'];
            return { name: ranks[level], color: colors[level], icon: icons[level] };
        }
        function showMastery() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('mastery-screen').classList.remove('hidden');
            renderMastery();
        }
        function hideMastery() {
            document.getElementById('mastery-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        }
        function renderMastery() {
            const grid = document.getElementById('mastery-grid');
            grid.innerHTML = '';

            CHARACTERS.forEach(char => {
                initMastery(char.id);
                const m = saveData.mastery[char.id];
                const rank = getMasteryRank(m.level);
                const winRate = m.matches > 0 ? ((m.wins / m.matches) * 100).toFixed(1) : 0;

                const card = document.createElement('div');
                card.style.cssText = `background:#222;border:3px solid ${rank.color};padding:20px;border-radius:10px;`;
                card.innerHTML = `
            <div style="display:flex;align-items:center;gap:15px;margin-bottom:15px">
                <div style="font-size:48px">${char.icon}</div>
                <div>
                    <div style="font-family:'Press Start 2P';font-size:16px;color:#fff">${char.name}</div>
                    <div style="font-family:'Press Start 2P';font-size:12px;color:${rank.color};margin-top:5px">${rank.icon} ${rank.name}</div>
                </div>
            </div>
            <div style="font-family:'Press Start 2P';font-size:10px;color:#aaa;line-height:1.8">
                <div>WINS: <span style="color:#0f0">${m.wins}</span></div>
                <div>MATCHES: <span style="color:#fff">${m.matches}</span></div>
                <div>WIN RATE: <span style="color:#ffd700">${winRate}%</span></div>
                <div>DAMAGE DEALT: <span style="color:#f00">${m.damage}</span></div>
            </div>
            <div style="margin-top:10px;background:#333;border-radius:5px;height:10px;overflow:hidden">
                <div style="background:${rank.color};height:100%;width:${(m.wins % (rank.name === 'MASTER' ? 100 : [5, 10, 15, 20, 50][m.level])) / ([5, 10, 15, 20, 50, 100][m.level]) * 100}%"></div>
            </div>
            <div style="font-family:'Press Start 2P';font-size:8px;color:#666;margin-top:5px;text-align:right">
                ${m.level < 5 ? `Next: ${[5, 15, 30, 50, 100][m.level]} wins` : 'MAX RANK!'}
            </div>
        `;
                grid.appendChild(card);
            });
        }

        // ========== FRIEND CODE SYSTEM ==========
        function generateFriendCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                if (i === 4) code += '-';
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        function initFriendCode() {
            if (!saveData.friendCode) {
                saveData.friendCode = generateFriendCode();
                saveGame();
            }
        }
        function showFriends() {
            initFriendCode();
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('friends-screen').classList.remove('hidden');
            document.getElementById('your-friend-code').textContent = saveData.friendCode;
            renderFriends();
        }
        function hideFriends() {
            document.getElementById('friends-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        }
        function copyFriendCode() {
            navigator.clipboard.writeText(saveData.friendCode).then(() => {
                showNotification('COPIED!', 'Friend code copied to clipboard');
                sfx.play('coin');
            });
        }
        function addFriend() {
            const input = document.getElementById('friend-code-input');
            const code = input.value.trim().toUpperCase();

            if (!code) {
                alert('Please enter a friend code');
                return;
            }
            if (code === saveData.friendCode) {
                alert("You can't add yourself!");
                return;
            }
            if (saveData.friends.some(f => f.code === code)) {
                alert('Friend already added!');
                return;
            }

            // Add as unverified until seen online (or validated by server)
            saveData.friends.push({
                code: code,
                name: `Player ${code.substr(0, 4)}`,
                addedAt: Date.now(),
                verified: false
            });
            saveGame();
            input.value = '';
            renderFriends();
            showNotification('FRIEND ADDED', code + ' (UNVERIFIED)');
            sfx.play('coin');
        }
        function removeFriend(code) {
            if (confirm('Remove this friend?')) {
                saveData.friends = saveData.friends.filter(f => f.code !== code);
                saveGame();
                renderFriends();
                sfx.play('break');
            }
        }
        function renderFriends() {
            const list = document.getElementById('friends-list');
            if (!saveData.friends || saveData.friends.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#666;font-family:Press Start 2P;font-size:12px;padding:40px">No friends yet. Share your code!</div>';
                return;
            }

            list.innerHTML = saveData.friends.map(f => {
                const hasStats = f.stats && typeof f.stats.wins === 'number' && typeof f.stats.losses === 'number' && f.stats.favoriteChar;
                let statsHtml = '<div style="font-family: \'Press Start 2P\'; font-size:10px; color:#666; margin-top:8px">No stats yet</div>';
                if (hasStats) {
                    const total = (f.stats.wins || 0) + (f.stats.losses || 0);
                    const winRate = total > 0 ? Math.floor(((f.stats.wins || 0) / total) * 100) : 0;
                    statsHtml = `
            <div style="display:flex;gap:15px;flex-wrap:wrap;font-family:'Press Start 2P';font-size:9px;color:#aaa;border-top:1px solid #444;padding-top:10px">
                <div style="color:#0f0">W: ${f.stats.wins}</div>
                <div style="color:#f00">L: ${f.stats.losses}</div>
                <div style="color:#ffd700">WR: ${winRate}%</div>
                <div style="color:#fff">Main: ${String(f.stats.favoriteChar).toUpperCase()}</div>
            </div>`;
                }
                return `
        <div style="background:#222;border:2px solid #555;padding:15px;margin-bottom:10px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <div>
                    <div style="font-family:'Press Start 2P';font-size:14px;color:#fff">${f.name} ${f.verified ? '<span style=\'color:#0f0;font-size:10px\'>[VERIFIED]</span>' : '<span style=\'color:#999;font-size:10px\'>[UNVERIFIED]</span>'}</div>
                    <div style="font-family:'Press Start 2P';font-size:10px;color:#666;margin-top:5px">${f.code}</div>
                </div>
                <button class="menu-btn danger-btn" onclick="removeFriend('${f.code}')" style="font-size:10px;padding:8px 16px">REMOVE</button>
            </div>
            ${statsHtml}
        </div>
        `;
            }).join('');
        }

        // ========== SOUND TEST ==========
        function showSoundTest() {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('sound-test-screen').classList.remove('hidden');
            renderSoundTest();
        }
        function hideSoundTest() {
            document.getElementById('sound-test-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
            music.stop();
        }
        function renderSoundTest() {
            const musicList = document.getElementById('music-list');
            const sfxList = document.getElementById('sfx-list');

            const musicTracks = ['MENU', 'GAME', 'BOSS'];
            musicList.innerHTML = musicTracks.map(track => `
        <button class="menu-btn" onclick="music.play('${track}')" style="font-size:12px;padding:12px">
            🎵 ${track}
        </button>
    `).join('');

            const sfxNames = ['hit', 'jump', 'coin', 'shield', 'break', 'ult', 'parry'];
            sfxList.innerHTML = sfxNames.map(name => `
        <button class="menu-btn" onclick="sfx.play('${name}')" style="font-size:12px;padding:12px">
            🔊 ${name.toUpperCase()}
        </button>
    `).join('');
        }

        // ========== CONTROL REMAPPING ==========
        let remappingPlayer = null;
        let remappingAction = null;
        function showControlsConfig() {
            document.getElementById('settings-screen').classList.add('hidden');
            document.getElementById('controls-config-screen').classList.remove('hidden');
            loadControlsDisplay();
        }
        function hideControlsConfig() {
            document.getElementById('controls-config-screen').classList.add('hidden');
            document.getElementById('settings-screen').classList.remove('hidden');
        }
        function loadControlsDisplay() {
            if (!saveData.customControls) {
                saveData.customControls = {
                    p1: { left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'q', shield: 'g' },
                    p2: { left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g' },
                    p3: { left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g' },
                    p4: { left: 'a', right: 'd', up: 'w', down: 's', attack: 'f', ult: 'r', shield: 'g' }
                };
            }

            // Update button displays
            for (const player of ['p1', 'p2', 'p3', 'p4']) {
                for (const action in saveData.customControls[player]) {
                    const btn = document.querySelector(`button[onclick="remapKey('${player}','${action}')"]`);
                    if (btn) btn.textContent = saveData.customControls[player][action];
                }
            }
        }
        function remapKey(player, action) {
            remappingPlayer = player;
            remappingAction = action;
            const btn = document.querySelector(`button[onclick="remapKey('${player}','${action}')"]`);
            if (btn) {
                btn.classList.add('remapping');
                btn.textContent = 'PRESS KEY...';
            }

            const handler = (e) => {
                e.preventDefault();
                const key = e.key;

                if (!saveData.customControls) saveData.customControls = { p1: {}, p2: {} };
                saveData.customControls[player][action] = key;
                saveGame();

                if (btn) {
                    btn.classList.remove('remapping');
                    btn.textContent = key;
                }

                document.removeEventListener('keydown', handler);
                remappingPlayer = null;
                remappingAction = null;
                sfx.play('coin');
            };

            document.addEventListener('keydown', handler);
        }
        function resetControls() {
            saveData.customControls = null;
            saveGame();
            loadControlsDisplay();
            showNotification('CONTROLS RESET', 'Default controls restored');
            sfx.play('coin');
        }
        function getControl(player, action) {
            if (!saveData.customControls) return null;
            return saveData.customControls[player] && saveData.customControls[player][action];
        }

        // ========== REMATCH SYSTEM ==========
        let lastMatchSettings = null;
        function rematch() {
            // Quest battle retry
            if (isQuestBattle && activeQuest) {
                document.getElementById('game-over').classList.add('hidden');
                startQuestBattle(activeQuest);
                return;
            }
            // Side quest battle retry
            if (isSideQuestBattle && activeSideQuest) {
                document.getElementById('game-over').classList.add('hidden');
                startSideQuestBattle(activeSideQuest);
                return;
            }

            if (!lastMatchSettings) {
                location.reload();
                return;
            }

            // Restore previous match settings
            p1Char = lastMatchSettings.p1Char;
            p2Char = lastMatchSettings.p2Char;
            selectedMap = lastMatchSettings.stage;
            p2IsCpu = lastMatchSettings.isCpu;
            cpuLevel = lastMatchSettings.cpuLevel;

            // Hide game over, start new match
            document.getElementById('game-over').classList.add('hidden');
            startGameLoop();
        }
        function exitToMenu() {
            // Clean up quest state
            if (isQuestBattle) {
                isQuestBattle = false;
                activeQuest = null;
            }
            if (isSideQuestBattle) {
                isSideQuestBattle = false;
                activeSideQuest = null;
            }
            location.reload();
        }
        function saveMatchSettings() {
            lastMatchSettings = {
                p1Char: p1Char,
                p2Char: p2Char,
                stage: selectedMap,
                isCpu: p2IsCpu,
                cpuLevel: cpuLevel
            };
        }

        function renderTrophies() {
            const grid = document.getElementById('trophy-grid');
            grid.innerHTML = '';
            for (const id in MASTER_TROPHY_LIST) {
                const trophy = MASTER_TROPHY_LIST[id];
                const unlocked = saveData.trophies.includes(id);
                const div = document.createElement('div');
                div.className = unlocked ? 'trophy-item unlocked' : 'trophy-item locked';
                if (unlocked) {
                    div.innerHTML = `<div class="trophy-icon">${trophy.icon}</div><div class="trophy-name">${trophy.name}</div><div class="trophy-desc">${trophy.desc}</div>`;
                } else {
                    div.innerHTML = `<div class="trophy-icon">❓</div><div class="trophy-name">LOCKED</div><div class="trophy-desc">???</div>`;
                }
                grid.appendChild(div);
            }
        }
        function toggleCpu() {
            p2IsCpu = !p2IsCpu;
            document.getElementById('cpu-toggle').innerText = p2IsCpu ? "P2: CPU" : "P2: HUMAN";
            document.getElementById('cpu-toggle').classList.toggle('cpu-active', p2IsCpu);
            document.getElementById('cpu-level-container').style.display = p2IsCpu ? 'flex' : 'none';
        }
        function updateCpuLevel(v) {
            cpuLevel = parseInt(v);
            document.getElementById('cpu-level-val').innerText = cpuLevel;
        }
        function renderCharGrid() {
            const g = document.getElementById('char-grid');
            g.innerHTML = '';
            CHARACTERS.forEach(c => {
                const d = document.createElement('div');
                d.className = 'char-card';
                d.id = `card-${c.id}`;
                let iconHtml;
                if (characterSprites[c.id]) {
                    iconHtml = `<canvas width="16" height="16" id="sprite-${c.id}"></canvas>`;
                } else {
                    iconHtml = `<span class="char-icon" style="font-size: 40px;">${c.icon}</span>`;
                }
                if (!saveData.unlocks.includes(c.id)) {
                    d.classList.add('locked');
                    d.innerHTML = `<div class="lock-icon">🔒</div>${iconHtml}`;
                } else {
                    d.innerHTML = iconHtml;
                    d.onclick = () => selectCharacter(c);
                }
                g.appendChild(d);
                if (characterSprites[c.id]) {
                    const miniCanvas = document.getElementById(`sprite-${c.id}`);
                    if (miniCanvas) {
                        const miniCtx = miniCanvas.getContext('2d');
                        miniCtx.imageSmoothingEnabled = !1;
                        const sprite = characterSprites[c.id];
                        if (sprite.idle && sprite.idle[0]) {
                            miniCtx.drawImage(sprite.idle[0], 0, 0, miniCanvas.width, miniCanvas.height);
                        } else if (sprite) {
                            miniCtx.drawImage(sprite, 0, 0, miniCanvas.width, miniCanvas.height);
                        }
                    }
                }
            });
            updateMasteryToggles();
        }

        function isCharMastered(charId) {
            try {
                initMastery(charId);
                return saveData.mastery[charId].level >= 5;
            } catch (e) {
                return false;
            }
        }

        function checkJackUnlock() {
            // Check if Jack is already unlocked
            if (saveData.unlocks.includes('jack')) return false;

            // Get all characters except Jack
            const nonJackChars = CHARACTERS.filter(c => c.id !== 'jack');

            // Check if ALL non-Jack characters are mastered
            const allMastered = nonJackChars.every(c => isCharMastered(c.id));

            if (allMastered) {
                saveData.unlocks.push('jack');
                saveGame();
                // Show unlock notification
                showJackUnlock();
                return true;
            }
            return false;
        }

        function showJackUnlock() {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:10000;display:flex;flex-direction:column;align-items:center;justify-content:center;animation:fadeIn 0.5s';

            const icon = document.createElement('div');
            icon.style.cssText = "font-size:120px;margin-bottom:30px;animation:bounce 1s infinite";
            icon.textContent = '🃏';

            const title = document.createElement('div');
            title.style.cssText = "font-family:'Press Start 2P';font-size:32px;color:#FFD700;margin-bottom:20px;text-align:center";
            title.textContent = 'CHARACTER UNLOCKED!';

            const charName = document.createElement('div');
            charName.style.cssText = "font-family:'Press Start 2P';font-size:24px;color:#fff;margin-bottom:40px;text-align:center";
            charName.textContent = 'JACK OF ALL TRADES';

            const desc = document.createElement('div');
            desc.style.cssText = "font-family:'Press Start 2P';font-size:12px;color:#aaa;margin-bottom:40px;text-align:center;max-width:600px;line-height:2";
            desc.innerHTML = 'Master of None<br/>You have mastered every character!<br/>The ultimate fighter awaits...';

            const btn = document.createElement('button');
            btn.className = 'menu-btn';
            btn.textContent = 'CONTINUE';
            btn.onclick = () => {
                document.body.removeChild(overlay);
                renderCharGrid();
            };

            overlay.appendChild(icon);
            overlay.appendChild(title);
            overlay.appendChild(charName);
            overlay.appendChild(desc);
            overlay.appendChild(btn);
            document.body.appendChild(overlay);

            // Add animations
            const style = document.createElement('style');
            style.textContent = `
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
    `;
            document.head.appendChild(style);
        }

        function updateMasteryToggles() {
            const b1 = document.getElementById('p1-mastery-toggle');
            const b2 = document.getElementById('p2-mastery-toggle');
            if (b1) {
                if (p1Char && isCharMastered(p1Char.id)) {
                    b1.style.display = 'inline-block';
                    b1.innerText = `P1 MASTERY: ${useMasteryP1 ? 'ON' : 'OFF'}`;
                } else {
                    b1.style.display = 'none';
                }
            }
            if (b2) {
                if (p2Char && isCharMastered(p2Char.id)) {
                    b2.style.display = 'inline-block';
                    b2.innerText = `P2 MASTERY: ${useMasteryP2 ? 'ON' : 'OFF'}`;
                } else {
                    b2.style.display = 'none';
                }
            }
        }

        function toggleMastery(player) {
            if (player === 1 && p1Char && isCharMastered(p1Char.id)) {
                useMasteryP1 = !useMasteryP1;
            } else if (player === 2 && p2Char && isCharMastered(p2Char.id)) {
                useMasteryP2 = !useMasteryP2;
            }
            updateMasteryToggles();
            sfx.play('coin');
        }
        function highlightChar(id, p) {
            const cards = document.getElementsByClassName('char-card');
            for (let c of cards) c.classList.remove(`selected-p${p}`);
            document.getElementById(`card-${id}`)?.classList.add(`selected-p${p}`);
        }
        function selectCharacter(c) {
            sfx.play('coin');
            if (isSurvival) {
                if (!p1Char) {
                    p1Char = c;
                    highlightChar(c.id, 1);
                    try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch (e) { }
                    updateMasteryToggles();
                    document.getElementById('select-instruction').innerText = "P2 CHOOSE";
                    document.getElementById('select-instruction').style.color = "var(--p2)";
                } else if (!p2Char) {
                    p2Char = c;
                    highlightChar(c.id, 2);
                    try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch (e) { }
                    updateMasteryToggles();
                    document.getElementById('char-select').classList.add('hidden');
                    selectedMap = MAPS[2];
                    beginSurvival();
                }
            } else if (isTraining) {
                p1Char = c;
                p2Char = CHARACTERS.find(ch => ch.id === 'chad');
                try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch (e) { }
                try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch (e) { }
                document.getElementById('char-select').classList.add('hidden');
                goToMapSelect();
            } else if (isMemeBall) {
                p1Char = c;
                let normalChars = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', 'chad', 'troll', '67kid', 'amogus', 'sahur', 'primo', 'ocralito', 'mechabara', 'bluedude', 'johnpork', 'nyancat', 'shrek', 'rickastley'];
                let enemyCharId = normalChars[Math.floor(Math.random() * normalChars.length)];
                p2Char = CHARACTERS.find(c => c.id === enemyCharId);
                try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch (e) { }
                try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch (e) { }
                document.getElementById('char-select').classList.add('hidden');
                selectedMap = MAPS[0];
                beginMemeBall();
            } else {
                if (!p1Char) {
                    p1Char = c;
                    highlightChar(c.id, 1);
                    try { initMastery(p1Char.id); useMasteryP1 = isCharMastered(p1Char.id); } catch (e) { }
                    updateMasteryToggles();
                    document.getElementById('select-instruction').innerText = "P2 CHOOSE";
                    document.getElementById('select-instruction').style.color = "var(--p2)";
                } else if (!p2Char) {
                    p2Char = c;
                    highlightChar(c.id, 2);
                    try { initMastery(p2Char.id); useMasteryP2 = isCharMastered(p2Char.id); } catch (e) { }
                    updateMasteryToggles();
                    setTimeout(goToMapSelect, 500);
                }
            }
        }
        function goToMapSelect() {
            document.getElementById('char-select').classList.add('hidden');
            document.getElementById('map-select').classList.remove('hidden');
            const g = document.getElementById('map-grid');
            g.innerHTML = '';
            MAPS.forEach(m => {
                const d = document.createElement('div');
                d.className = 'map-card';
                d.innerHTML = `<div style="font-size:40px">🗺️</div><div>${m.id.toUpperCase()}</div>`;
                d.onclick = () => {
                    selectedMap = m;
                    document.getElementById('map-select').classList.add('hidden');
                    startGame();
                };
                g.appendChild(d);
            });
        }
        function startGame() {
            document.getElementById('hud').classList.remove('hidden');
            audioFiles.init();
            initGame();
            saveMatchSettings();
            gameState = 'GAME';
            music.play('BATTLE');
            loop();
        }
        const startGameLoop = startGame;
        function togglePause() {
            // Toggle between running and paused game states
            if (gameState === 'GAME') {
                gameState = 'PAUSED';
                const pm = document.getElementById('pause-menu');
                if (pm) pm.classList.remove('hidden');
            } else if (gameState === 'PAUSED') {
                gameState = 'GAME';
                const pm = document.getElementById('pause-menu');
                if (pm) pm.classList.add('hidden');
                // Resume the game loop
                loop();
            }
        }
        function beginSurvival() {
            killCount = 0;
            survivalWave = 1;
            spawnTimer = 0;
            document.getElementById('hud').classList.remove('hidden');
            if (p2IsCpu || p2Char) {
                document.getElementById('p2-hud-box').style.display = 'block';
            } else {
                document.getElementById('p2-hud-box').style.display = 'none';
            }
            document.getElementById('game-mode-hud').style.display = 'block';
            document.getElementById('game-mode-title').innerText = "CO-OP SURVIVAL";
            document.getElementById('game-score-val').innerText = "KILLS: 0";
            platforms = [];
            items = [];
            ultEffects = [];
            players = [];
            backgrounds = [];
            itemTimer = 0;
            megaCoinSpawned = !1;
            worldFlipped = !1;
            mapTimer = 0;
            particles = [];
            targets = [];
            for (let i = 0; i < 20; i++) backgrounds.push({
                x: Math.random() * 2000 - 1000,
                y: Math.random() * 600 - 300,
                s: Math.random() * 30 + 20,
                sp: Math.random() * 0.5 + 0.1
            });
            platforms.push({
                x: -200,
                y: 200,
                w: 400,
                h: 500,
                t: 'solid',
                c: '#4e342e',
                vx: 0,
                vy: 0,
                angle: 0
            });
            platforms.push({
                x: -1000,
                y: 400,
                w: 2000,
                h: 200,
                t: 'lava',
                c: '#e74c3c',
                vx: 0,
                vy: -0.2,
                angle: 0
            });
            players = [new Fighter(1, p1Char, -100, 0, !0, !1)];
            if (p2Char) {
                players.push(new Fighter(2, p2Char, 100, 0, !p2IsCpu, p2IsCpu));
            }
            players.forEach(p => p.stocks = 3);
            if (saveData.powerBoosters > 0) {
                const boost = 1.2;
                players.forEach(p => {
                    if (!p.cpu) {
                        const originalStats = p.stats;
                        p.stats = {
                            ...originalStats,
                            speed: originalStats.speed * boost,
                            power: originalStats.power * boost,
                            jump: originalStats.jump * boost,
                            weight: Math.max(0.5, originalStats.weight / boost)
                        };
                    }
                });
                saveData.powerBoosters = Math.max(0, (saveData.powerBoosters || 0) - 1);
                saveGame();
                setTimeout(() => {
                    showNotification("⚡ POWER BOOSTER ACTIVATED! ⚡", "Speed, Attack, Health, Regen Boosted!");
                }, 500);
            }
            document.getElementById('p1-name').innerText = p1Char.name;
            if (p2Char) document.getElementById('p2-name').innerText = p2Char.name;
            updateHUD();
            gameState = 'GAME';
            music.play('BOSS');
            loop();
        }
        function beginMemeBall() {
            p1Score = 0;
            p2Score = 0;
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('game-mode-hud').style.display = 'block';
            document.getElementById('game-mode-title').innerText = "FIRST TO 5";
            document.getElementById('game-score-val').innerText = "0 - 0";
            platforms = [];
            items = [];
            ultEffects = [];
            players = [];
            backgrounds = [];
            itemTimer = 0;
            megaCoinSpawned = !1;
            worldFlipped = !1;
            mapTimer = 0;
            particles = [];
            targets = [];
            for (let i = 0; i < 20; i++) backgrounds.push({
                x: Math.random() * 2000 - 1000,
                y: Math.random() * 600 - 300,
                s: Math.random() * 30 + 20,
                sp: Math.random() * 0.5 + 0.1
            });
            platforms.push({
                x: -600,
                y: 200,
                w: 1200,
                h: 500,
                t: 'solid',
                c: '#546E7A'
            });
            platforms.push({
                x: -10,
                y: -100,
                w: 20,
                h: 300,
                t: 'solid',
                c: '#FFF'
            });
            players = [new Fighter(1, p1Char, -200, 0, !0, !1), new Fighter(2, p2Char, 200, 0, !1, isOnline ? !1 : !0)];
            try {
                players[0].masteryActive = (isCharMastered(p1Char.id) && useMasteryP1);
                players[1].masteryActive = (isCharMastered(p2Char.id) && useMasteryP2);
            } catch (e) { }
            players.forEach(p => {
                p.stocks = 99;
            });
            ball = new Ball();
            ball.reset(1);
            gameState = 'GAME';
            music.play('BATTLE');
            loop();
        }
        function initGame() {
            if (!p1Char) p1Char = CHARACTERS[0];
            if (!p2Char) p2Char = CHARACTERS[1];
            platforms = [];
            items = [];
            ultEffects = [];
            targets = [];
            itemTimer = 0;
            megaCoinSpawned = !1;
            backgrounds = [];
            particles = [];
            worldFlipped = !1;
            flipTimer = 0;
            const gy = 200;
            for (let i = 0; i < 20; i++) backgrounds.push({
                x: Math.random() * 2000 - 1000,
                y: Math.random() * 600 - 300,
                s: Math.random() * 30 + 20,
                sp: Math.random() * 0.5 + 0.1
            });
            if (selectedMap.id === 'flat') platforms.push({
                x: -600,
                y: gy,
                w: 1200,
                h: 500,
                t: 'solid',
                c: selectedMap.c,
                vx: 0,
                vy: 0,
                angle: 0,
                pivotX: 0,
                pivotY: 0
            });
            else if (selectedMap.id === 'plat') {
                platforms.push({
                    x: -500,
                    y: gy,
                    w: 1000,
                    h: 500,
                    t: 'solid',
                    c: selectedMap.c,
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
                platforms.push({
                    x: -300,
                    y: gy - 150,
                    w: 150,
                    h: 20,
                    t: 'pass',
                    c: '#ddd',
                    vx: 1,
                    vy: 0,
                    angle: 0
                });
                platforms.push({
                    x: 150,
                    y: gy - 150,
                    w: 150,
                    h: 20,
                    t: 'pass',
                    c: '#ddd',
                    vx: -1,
                    vy: 0,
                    angle: 0
                });
                platforms.push({
                    x: -75,
                    y: gy - 280,
                    w: 150,
                    h: 20,
                    t: 'pass',
                    c: '#ddd',
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
            } else if (selectedMap.id === 'edge') {
                platforms.push({
                    x: -200,
                    y: gy,
                    w: 400,
                    h: 500,
                    t: 'solid',
                    c: selectedMap.c,
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
                if (rulesHazardsEnabled) {
                    platforms.push({
                        x: -1000,
                        y: 400,
                        w: 2000,
                        h: 200,
                        t: 'lava',
                        c: '#e74c3c',
                        vx: 0,
                        vy: -0.2,
                        angle: 0
                    });
                }
            } else if (selectedMap.id === 'machine') {
                platforms.push({
                    x: -400,
                    y: 300,
                    w: 400,
                    h: 20,
                    t: 'machine_left',
                    c: '#95a5a6',
                    vx: 0,
                    vy: 0,
                    angle: 0,
                    pivotX: -400,
                    pivotY: 300
                });
                platforms.push({
                    x: 0,
                    y: 300,
                    w: 400,
                    h: 20,
                    t: 'machine_right',
                    c: '#95a5a6',
                    vx: 0,
                    vy: 0,
                    angle: 0,
                    pivotX: 400,
                    pivotY: 300
                });
            } else if (selectedMap.id === 'nightcity') {
                // Main rooftop
                platforms.push({
                    x: -400,
                    y: gy,
                    w: 800,
                    h: 500,
                    t: 'solid',
                    c: '#1a0a20',
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
                // Left floating platform (neon pink)
                platforms.push({
                    x: -500,
                    y: gy - 120,
                    w: 130,
                    h: 15,
                    t: 'pass',
                    c: '#ff00ff',
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
                // Right floating platform (cyan)
                platforms.push({
                    x: 370,
                    y: gy - 120,
                    w: 130,
                    h: 15,
                    t: 'pass',
                    c: '#00ffff',
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
                // Top center platform (yellow)
                platforms.push({
                    x: -80,
                    y: gy - 220,
                    w: 160,
                    h: 15,
                    t: 'pass',
                    c: '#ffff00',
                    vx: 0,
                    vy: 0,
                    angle: 0
                });
            } else if (selectedMap.id === 'badlands') {
                // Badlands: wide flat desert with scattered cover
                platforms.push({
                    x: -700, y: gy + 20, w: 1400, h: 500, t: 'solid', c: '#5c3a1a', vx: 0, vy: 0, angle: 0
                });
                // Industrial ruin platforms
                platforms.push({
                    x: -450, y: gy - 100, w: 120, h: 20, t: 'pass', c: '#8b5a2b', vx: 0, vy: 0, angle: 0
                });
                platforms.push({
                    x: 330, y: gy - 100, w: 120, h: 20, t: 'pass', c: '#8b5a2b', vx: 0, vy: 0, angle: 0
                });
                // Wrecked car as center platform
                platforms.push({
                    x: -80, y: gy - 60, w: 160, h: 15, t: 'pass', c: '#664422', vx: 0, vy: 0, angle: 0
                });
            } else if (selectedMap.id === 'arasaka_district') {
                // Arasaka District: Multi-level corp building rooftops
                // Main wide platform
                platforms.push({
                    x: -500, y: gy, w: 1000, h: 500, t: 'solid', c: '#0a0a18', vx: 0, vy: 0, angle: 0
                });
                // Left server rack platform
                platforms.push({
                    x: -420, y: gy - 140, w: 140, h: 15, t: 'pass', c: '#ff0044', vx: 0, vy: 0, angle: 0
                });
                // Right server rack platform
                platforms.push({
                    x: 280, y: gy - 140, w: 140, h: 15, t: 'pass', c: '#00ffff', vx: 0, vy: 0, angle: 0
                });
                // High center helipad platform
                platforms.push({
                    x: -100, y: gy - 260, w: 200, h: 15, t: 'pass', c: '#ff0044', vx: 0, vy: 0, angle: 0
                });
                // Moving drone platform
                platforms.push({
                    x: -60, y: gy - 150, w: 100, h: 12, t: 'pass', c: '#00ffff', vx: 1.5, vy: 0, angle: 0
                });
            } else if (selectedMap.id === 'arasaka_tower') {
                // Arasaka Tower Top: Narrow arena, high stakes
                // Main narrow tower top
                platforms.push({
                    x: -300, y: gy, w: 600, h: 500, t: 'solid', c: '#1a0020', vx: 0, vy: 0, angle: 0
                });
                // Left antenna arm
                platforms.push({
                    x: -450, y: gy - 80, w: 180, h: 12, t: 'pass', c: '#ff0044', vx: 0, vy: 0, angle: 0
                });
                // Right antenna arm
                platforms.push({
                    x: 270, y: gy - 80, w: 180, h: 12, t: 'pass', c: '#ff0044', vx: 0, vy: 0, angle: 0
                });
                // Center floating platform (cyberskeleton debris)
                platforms.push({
                    x: -70, y: gy - 180, w: 140, h: 12, t: 'pass', c: '#880022', vx: 0, vy: 0, angle: 0
                });
                // Hazard: if hazards enabled, falling debris zone
                if (rulesHazardsEnabled) {
                    platforms.push({
                        x: -800, y: 500, w: 1600, h: 200, t: 'lava', c: '#ff0022', vx: 0, vy: -0.15, angle: 0
                    });
                }
            } else if (selectedMap.id === 'backrooms') {
                // Backrooms: Eerie yellow liminal space with repeating rooms
                platforms.push({
                    x: -600, y: gy, w: 1200, h: 500, t: 'solid', c: '#9e8c5a', vx: 0, vy: 0, angle: 0
                });
                // Ceiling platforms
                platforms.push({
                    x: -500, y: gy - 200, w: 200, h: 12, t: 'pass', c: '#a8976a', vx: 0, vy: 0, angle: 0
                });
                platforms.push({
                    x: 300, y: gy - 200, w: 200, h: 12, t: 'pass', c: '#a8976a', vx: 0, vy: 0, angle: 0
                });
                // Center platform
                platforms.push({
                    x: -100, y: gy - 100, w: 200, h: 12, t: 'pass', c: '#b5a478', vx: 0, vy: 0, angle: 0
                });
                // Wandering platform (entity)
                if (rulesHazardsEnabled) {
                    platforms.push({
                        x: -60, y: gy - 150, w: 80, h: 10, t: 'pass', c: '#665533', vx: 0.8, vy: 0, angle: 0
                    });
                }
            } else if (selectedMap.id === 'space') {
                // Space: Floating asteroids, low gravity arena
                // Center asteroid
                platforms.push({
                    x: -200, y: gy, w: 400, h: 500, t: 'solid', c: '#333340', vx: 0, vy: 0, angle: 0
                });
                // Left floating rock
                platforms.push({
                    x: -500, y: gy - 80, w: 150, h: 25, t: 'pass', c: '#4a4a5e', vx: 0, vy: 0, angle: 0
                });
                // Right floating rock
                platforms.push({
                    x: 350, y: gy - 80, w: 150, h: 25, t: 'pass', c: '#4a4a5e', vx: 0, vy: 0, angle: 0
                });
                // High platform
                platforms.push({
                    x: -80, y: gy - 200, w: 160, h: 15, t: 'pass', c: '#555568', vx: 0, vy: 0, angle: 0
                });
                // Orbiting platform
                platforms.push({
                    x: -50, y: gy - 120, w: 100, h: 12, t: 'pass', c: '#6a6a80', vx: 1.2, vy: 0, angle: 0
                });
            } else if (selectedMap.id === 'minecraft') {
                // Minecraft: Blocky terrain with dirt, grass, trees
                platforms.push({
                    x: -600, y: gy, w: 1200, h: 500, t: 'solid', c: '#8B6914', vx: 0, vy: 0, angle: 0
                });
                // Left hill
                platforms.push({
                    x: -550, y: gy - 60, w: 200, h: 60, t: 'solid', c: '#5b8731', vx: 0, vy: 0, angle: 0
                });
                // Right hill
                platforms.push({
                    x: 350, y: gy - 40, w: 180, h: 40, t: 'solid', c: '#5b8731', vx: 0, vy: 0, angle: 0
                });
                // Floating block platforms
                platforms.push({
                    x: -200, y: gy - 120, w: 80, h: 25, t: 'pass', c: '#b8a042', vx: 0, vy: 0, angle: 0
                });
                platforms.push({
                    x: 120, y: gy - 150, w: 80, h: 25, t: 'pass', c: '#b8a042', vx: 0, vy: 0, angle: 0
                });
                // Center tree trunk
                platforms.push({
                    x: -15, y: gy - 80, w: 30, h: 80, t: 'solid', c: '#6b4423', vx: 0, vy: 0, angle: 0
                });
            } else platforms.push({
                x: -600,
                y: gy,
                w: 1200,
                h: 500,
                t: 'solid',
                c: selectedMap.c
            });
            let p2C = !p2IsCpu && !isTraining;
            let p2CPU = p2IsCpu || isTraining;

            // Determine player count based on mode
            const playerCount = (isOnline && netGameMode === '2v2') ? 4 : 2;

            if (playerCount === 4) {
                // 2v2: 4 fighters
                const p3Char = CHARACTERS.find(c => c.id === 'pepe') || CHARACTERS[2] || CHARACTERS[0];
                const p4Char = CHARACTERS.find(c => c.id === 'wojak') || CHARACTERS[3] || CHARACTERS[1];
                players = [
                    new Fighter(1, p1Char, -300, 0, true, false),   // Team 1
                    new Fighter(2, p2Char, 300, 0, true, false),    // Team 2
                    new Fighter(3, p3Char, -150, 0, true, false),   // Team 1
                    new Fighter(4, p4Char, 150, 0, true, false)     // Team 2
                ];
                players[0].team = 1; players[2].team = 1;  // P1 & P3 = Team 1
                players[1].team = 2; players[3].team = 2;  // P2 & P4 = Team 2
                // Ensure no boss behavior in online
                players.forEach(p => { p.isBoss = false; console.log(`P${p.id}: ${p.stats.id}, isBoss=${p.isBoss}`); });
                // Apply custom stocks if in online mode
                if (isOnline && typeof customStocks !== 'undefined') {
                    players.forEach(p => p.stocks = customStocks);
                }
            } else {
                // 1v1: 2 fighters
                players = [new Fighter(1, p1Char, -200, 0, true, false), new Fighter(2, p2Char, 200, 0, p2C, p2CPU)];
                // Ensure no boss behavior in online
                if (isOnline) players.forEach(p => { p.isBoss = false; console.log(`P${p.id}: ${p.stats.id}, isBoss=${p.isBoss}`); });
                // Apply custom stocks if in online mode
                if (isOnline && typeof customStocks !== 'undefined') {
                    players.forEach(p => p.stocks = customStocks);
                }
            }

            // Ensure mastery flags reflect latest toggles
            try {
                players[0].masteryActive = (isCharMastered(p1Char.id) && useMasteryP1);
                if (players.length > 1) players[1].masteryActive = (isCharMastered(p2Char.id) && useMasteryP2);
            } catch (e) { }
            document.getElementById('p1-name').innerText = p1Char.name;
            document.getElementById('p2-name').innerText = p2Char.name;
            document.getElementById('p2-hud-box').style.display = 'block';
            updateHUD();
            document.getElementById('game-mode-hud').style.display = 'none';
        }
        function updateHUD() {
            players.forEach(p => {
                const x = p.id === 1 ? 'p1' : 'p2';
                if (document.getElementById(`${x}-pct`)) {
                    document.getElementById(`${x}-pct`).innerText = Math.floor(p.pct) + '%';
                    document.getElementById(`${x}-stocks`).innerText = '●'.repeat(p.stocks);
                    const b = document.getElementById(`${x}-ult-bar`);
                    b.style.width = p.ult + '%';
                    if (p.ult >= 100) b.parentNode.classList.add('ult-ready');
                    else b.parentNode.classList.remove('ult-ready');
                }
            });
        }
        function endGame(w) {
            gameState = 'GAMEOVER';
            document.getElementById('game-over').classList.remove('hidden');

            // Track mastery for both players
            let masteryMsg = '';
            if (!isSurvival && !isMemeBall && players.length >= 2) {
                const p1Damage = players[1].pct; // Damage dealt to opponent
                const p2Damage = players[0].pct;

                const p1LeveledUp = trackMatch(p1Char.id, w === 1, p1Damage);
                const p2LeveledUp = trackMatch(p2Char.id, w === 2, p2Damage);

                if (p1LeveledUp) {
                    const rank = getMasteryRank(saveData.mastery[p1Char.id].level);
                    masteryMsg += `\n${p1Char.name}: ${rank.icon} ${rank.name}!`;
                }
                if (p2LeveledUp) {
                    const rank = getMasteryRank(saveData.mastery[p2Char.id].level);
                    masteryMsg += `\n${p2Char.name}: ${rank.icon} ${rank.name}!`;
                }

                if (masteryMsg) {
                    document.getElementById('mastery-progress').innerHTML = `<div style="color:#ffd700">MASTERY UP!</div>${masteryMsg}`;
                    // Check if Jack should be unlocked
                    setTimeout(() => checkJackUnlock(), 1000);
                } else {
                    document.getElementById('mastery-progress').innerHTML = '';
                    // Still check for Jack unlock even without level up
                    checkJackUnlock();
                }
            }

            // Record vs-friend stats for online 1v1 when opponent is a verified friend
            try {
                if (isOnline && netConnectedPlayers && netConnectedPlayers.length >= 2) {
                    const myNickInput = document.getElementById('online-nickname');
                    const myName = (myNickInput && myNickInput.value.trim()) || 'Player';
                    const opponent = netConnectedPlayers.find(p => p && p.name && p.name !== myName);
                    const oppCode = opponent && opponent.friendCode;
                    if (oppCode && saveData && Array.isArray(saveData.friends)) {
                        const friend = saveData.friends.find(f => f.code === oppCode);
                        if (friend) {
                            friend.verified = true;
                            friend.lastSeenAt = Date.now();
                            if (!friend.stats) friend.stats = { wins: 0, losses: 0, favoriteChar: p2Char && p2Char.id ? p2Char.id : '' };
                            // Winner is w (1 for P1, 2 for P2). Assume you are P1 when hosting or local.
                            // If you are not host, mapping may vary; we use myName to infer winner string on the GAME! text.
                            if (w === 1) friend.losses = (friend.losses || 0) + 1; else friend.wins = (friend.wins || 0) + 1;
                            // Update favoriteChar heuristic: most recently used char when winning
                            if (w === 2 && p2Char && p2Char.id) friend.stats.favoriteChar = p2Char.id;
                            if (w === 1 && p1Char && p1Char.id) friend.stats.favoriteChar = p1Char.id;
                            try { saveGame(); renderFriends(); } catch (e) { }
                        }
                    }
                }
            } catch (e) { }

            if (isSurvival) {
                document.getElementById('winner-display').innerText = `KILLS: ${killCount}`;
                if (killCount >= 50) unlockTrophy('kills_50');
            } else if (isQuestBattle && activeQuest) {
                // Quest battle ended
                if (w === 1) {
                    // Player won the quest!
                    document.getElementById('game-over').classList.add('hidden');
                    document.getElementById('winner-display').innerText = '';
                    // Show post-battle dialogue, then award reward
                    const quest = activeQuest;
                    setTimeout(() => {
                        showDialogue(quest.dialogue_post, () => {
                            completeQuest(quest);
                            showNotification("QUEST COMPLETE!", quest.rewardName + " UNLOCKED!");
                            isQuestBattle = false;
                            activeQuest = null;
                            // Return to story screen
                            document.getElementById('game-over').classList.add('hidden');
                            document.getElementById('hud').classList.add('hidden');
                            document.getElementById('game-mode-hud').style.display = 'none';
                            gameState = 'STORY';
                            document.getElementById('story-screen').classList.remove('hidden');
                            renderQuestList();
                        });
                    }, 1000);
                    return; // Skip normal endgame display
                } else {
                    // Player lost the quest
                    document.getElementById('winner-display').innerText = `MISSION FAILED\n${activeQuest.title}`;
                    document.getElementById('winner-display').style.color = "#ff003c";
                    document.getElementById('rematch-btn').innerText = "RETRY MISSION";
                    // Keep activeQuest so rematch can retry
                }
            } else if (isSideQuestBattle && activeSideQuest) {
                // Side quest battle ended
                if (w === 1) {
                    // Player won the side quest!
                    document.getElementById('game-over').classList.add('hidden');
                    document.getElementById('winner-display').innerText = '';
                    const sq = activeSideQuest;
                    setTimeout(() => {
                        showDialogue(sq.dialogue_post, () => {
                            completeSideQuest(sq);
                            showNotification("GIG COMPLETE!", sq.coins + " EDDIES EARNED");
                            isSideQuestBattle = false;
                            activeSideQuest = null;
                            document.getElementById('game-over').classList.add('hidden');
                            document.getElementById('hud').classList.add('hidden');
                            document.getElementById('game-mode-hud').style.display = 'none';
                            gameState = 'STORY';
                            document.getElementById('story-screen').classList.remove('hidden');
                            renderQuestList();
                        });
                    }, 1000);
                    return;
                } else {
                    document.getElementById('winner-display').innerText = `GIG FAILED\n${activeSideQuest.title}`;
                    document.getElementById('winner-display').style.color = "#ff003c";
                    document.getElementById('rematch-btn').innerText = "RETRY GIG";
                }
            } else if (isMemeBall) {
                if (w === 1) {
                    earnCoins(100);
                    document.getElementById('winner-display').innerText = "P1 WINS!";
                } else {
                    document.getElementById('winner-display').innerText = "CPU WINS!";
                }
            } else {
                if (w === 1) {
                    earnCoins(50);
                    addStreetCred(10); // Street cred for winning a regular match
                    document.getElementById('winner-display').innerText = `GAME!\n${p1Char.name} WINS`;
                    if (players.length > 0 && players[0].pct === 0) unlockTrophy('flawless');
                } else {
                    addStreetCred(3); // Small street cred even for losing
                    document.getElementById('winner-display').innerText = `GAME!\n${p2Char.name} WINS`;
                    if (players.length > 1 && players[1].pct === 0) unlockTrophy('flawless');
                }
            }
            document.getElementById('winner-display').style.color = "";
            // Reset button text if not a quest battle
            if (!isQuestBattle && !isSideQuestBattle) {
                document.getElementById('rematch-btn').innerText = "REMATCH";
            }
            for (let i = 0; i < 50; i++) confetti.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 20,
                vy: (Math.random() - 0.5) * 20,
                c: `hsl(${Math.random() * 360},100%,50%)`
            });
        }
        function loop() {
            if (gameState === 'SHOP') {
                drawShop();
                requestAnimationFrame(loop);
                return;
            }
            if (gameState === 'PAUSED') return;
            if (gameState === 'GAMEOVER') {
                draw();
                requestAnimationFrame(loop);
                return;
            }
            if (gameState !== 'GAME') return;
            if (hitStop > 0) {
                hitStop--;
                draw();
                requestAnimationFrame(loop);
                return;
            }
            mapTimer++;
            // Combo timer decay
            if (comboTimer > 0) { comboTimer--; if (comboTimer <= 0) comboCount = 0; }
            // Announcer timer
            if (announceTimer > 0) announceTimer--;
            // Weather system tick
            if (weatherType !== 'none') {
                weatherTimer--;
                if (weatherTimer <= 0) { weatherType = 'none'; weatherParticles = []; }
            } else if (mapTimer % 3600 === 0 && Math.random() < 0.4) {
                // Random weather event every ~60 seconds
                const weathers = ['rain', 'snow', 'wind', 'meteor'];
                weatherType = weathers[Math.floor(Math.random() * weathers.length)];
                weatherTimer = 600 + Math.floor(Math.random() * 600);
                showAnnounce('⚠️ ' + weatherType.toUpperCase() + ' INCOMING!', '#aaf');
            }
            if (selectedMap.id === 'plat') {
                platforms[1].x = -300 + Math.sin(mapTimer * 0.05) * 100;
                platforms[1].vx = Math.cos(mapTimer * 0.05) * 5;
                platforms[2].x = 150 - Math.sin(mapTimer * 0.05) * 100;
                platforms[2].vx = -Math.cos(mapTimer * 0.05) * 5;
            } else if (selectedMap.id === 'edge') {
                platforms[1].y = 400 + Math.sin(mapTimer * 0.02) * 100;
            } else if (selectedMap.id === 'machine') {
                let cycle = mapTimer % 1800;
                let targetAngle = 0;
                if (cycle > 480 && cycle < 840) {
                    targetAngle = -0.5;
                } else if (cycle > 1320 && cycle < 1680) {
                    targetAngle = 0.5;
                }
                platforms[0].angle += (targetAngle - platforms[0].angle) * 0.01;
                platforms[1].angle += (-targetAngle - platforms[1].angle) * 0.01;
            }
            if (!isMemeBall) {
                itemTimer++;
                if (itemTimer > 400) {
                    if (rulesItemsEnabled && Math.random() < 0.7) items.push(new Item());
                    itemTimer = 0;
                }
                if (!megaCoinSpawned && selectedMap.id !== 'machine' && mapTimer > 600 && Math.random() < 0.01) {
                    items.push(new Item('mega'));
                    megaCoinSpawned = !0;
                    const warn = document.getElementById('mega-warning');
                    warn.style.display = 'block';
                    sfx.play('ult');
                    setTimeout(() => warn.style.display = 'none', 3000);
                }
            }
            if (worldFlipped) {
                flipTimer--;
                if (flipTimer <= 0) worldFlipped = !1;
            }

            // Handle Meme Ball serving
            if (isMemeBall && isServing) {
                const server = players.find(p => p.id === servingPlayer);
                if (server) {
                    // CPU auto-serve logic
                    if (server.cpu) {
                        serveCharge += 2;
                        if (serveCharge >= 40 + Math.random() * 40) {
                            ball.serve(serveCharge, servingPlayer);
                            serveCharge = 0;
                        }
                    } else {
                        // Check for serve input (attack button)
                        const controls = servingPlayer === 1 ?
                            { atk: getControl('p1', 'attack') || 'f' } :
                            { atk: getControl('p2', 'attack') || 'l' };

                        if (keys[controls.atk]) {
                            serveCharge = Math.min(serveCharge + 3, 100);
                        } else if (serveCharge > 0) {
                            // Release serve
                            ball.serve(serveCharge, servingPlayer);
                            serveCharge = 0;
                        }
                    }
                }
            }

            if (isSurvival) {
                spawnTimer++;
                let playersAlive = players.filter(p => p.stocks > 0 && !p.cpu).length;
                let rate = Math.max(60, 120 - (killCount * 2));
                if (playersAlive > 1) rate = Math.max(30, 80 - (killCount * 2));
                if (spawnTimer > rate && players.filter(p => p.cpu).length < 5) {
                    let normalChars = ['doge', 'frog', 'cat', 'capy', 'spongy', 'sanic', 'chad', 'troll', '67kid', 'amogus', 'sahur', 'primo', 'ocralito', 'mechabara', 'bluedude', 'johnpork', 'nyancat', 'shrek', 'rickastley'];
                    let enemyCharId = normalChars[Math.floor(Math.random() * normalChars.length)];
                    let enemyChar = CHARACTERS.find(c => c.id === enemyCharId);
                    let enemy = new Fighter(players.length + 1, enemyChar, Math.random() * 600 - 300, -300, !1, !0);
                    enemy.stocks = 1;
                    enemy.pct = killCount * 5;
                    players.push(enemy);
                    spawnTimer = 0;
                }
            }
            if (isMemeBall) ball.update();
            let livingPlayers = 0;
            for (let i = players.length - 1; i >= 0; i--) {
                if (players[i].stocks <= 0) {
                    if (isSurvival) {
                        if (players[i].cpu) {
                            killCount++;
                            earnCoins(5);
                            sfx.play('coin');
                            document.getElementById('game-score-val').innerText = `KILLS: ${killCount}`;
                            // Track Dynlar/Apogee kills for Yellow Dude
                            const humanPlayer = players.find(p => !p.cpu && p.stats.id === 'yellowdude');
                            if (humanPlayer) {
                                trackDynlarKill(humanPlayer);
                            }
                            players.splice(i, 1);
                        }
                    }
                } else {
                    livingPlayers++;
                }
            }
            if (!isSurvival && gameState === 'GAME') {
                let p1 = players.find(p => p.id === 1);
                let p2 = players.find(p => p.id === 2);
                if (p1 && p1.stocks <= 0) {
                    endGame(2);
                    return;
                }
                if (p2 && p2.stocks <= 0) {
                    endGame(1);
                    return;
                }
            } else if (isSurvival && gameState === 'GAME') {
                let livingHumans = players.filter(p => !p.cpu && p.stocks > 0).length;
                if (livingHumans === 0) {
                    endGame(2);
                    return;
                }
            }
            players.forEach(p => p.update());
            // Track David's Sandy afterimages
            players.forEach(p => {
                if (p.davidSandyActive) {
                    davidSandyAfterimages.push({
                        x: p.x,
                        y: p.y,
                        w: p.w,
                        h: p.h,
                        charId: p.stats.id,
                        dir: p.dir,
                        animation: p.animation,
                        frame: p.frame,
                        alpha: 0.7,
                        life: 12
                    });
                }
            });
            // Update and cull afterimages
            for (let i = davidSandyAfterimages.length - 1; i >= 0; i--) {
                davidSandyAfterimages[i].life--;
                davidSandyAfterimages[i].alpha *= 0.85;
                if (davidSandyAfterimages[i].life <= 0) {
                    davidSandyAfterimages.splice(i, 1);
                }
            }
            items.forEach(i => i.update());
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    if (p.text) {
                        p.y += p.vy;
                    } else {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.2;
                    }
                }
            }
            for (let i = ultEffects.length - 1; i >= 0; i--) {
                let e = ultEffects[i];
                e.l--;
                if (e.t === 'moon') {
                    e.y += 15;
                    players.forEach(p => {
                        if (p.stocks > 0 && Math.abs(p.x - e.x) < 100 && Math.abs(p.y - e.y) < 100) p.hit(0, 20, 2);
                    });
                } else if (e.t === 'tear') {
                    e.y += 10;
                    players.forEach(p => {
                        if (p.stocks > 0 && Math.abs(p.x - e.x) < 30 && Math.abs(p.y - e.y) < 30) p.hit(10, 0, 1);
                    });
                } else if (e.t === 'primo') {
                    e.x += e.vx;
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 50 && Math.abs(p.y - e.y) < 50) p.hit(e.vx, -10, 25);
                    });
                } else if (e.t === 'pork') {
                    e.y += 25;
                    ctx.font = "200px Arial";
                    ctx.fillText('🐖', e.x - 100, e.y);
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - (e.x - 50)) < 100 && Math.abs(p.y - e.y) < 100) {
                            p.hit(0, -30, 100);
                            e.l = 0;
                        }
                    });
                } else if (e.t === 'fire') {
                    // Overheat Effect
                    if (Math.random() < 0.4) {
                        particles.push({
                            x: e.x + (Math.random() - 0.5) * 60,
                            y: e.y + (Math.random() - 0.5) * 60,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -2 - Math.random() * 2,
                            size: Math.random() * 6 + 2,
                            life: 30,
                            color: Math.random() > 0.5 ? '#ff4400' : '#ffff00'
                        });
                    }
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 50 && Math.abs(p.y - e.y) < 50) {
                            p.hit(0, -1, 0.5); // Tick damage
                            e.l--; // Drain faster if hitting?
                        }
                    });
                } else if (e.t === 'spark') {
                    e.x += e.vx;
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 5, color: '#00ffff', size: 2 });
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 30 && Math.abs(p.y - e.y) < 30) {
                            p.hit(e.vx * 0.5, -5, 8);
                            p.stun = 60;
                            sfx.play('break');
                            e.l = 0;
                            particles.push({ x: p.x, y: p.y, text: "SHORT CIRCUIT", life: 60, vy: -1, color: '#0ff' });
                        }
                    });
                } else if (e.t === 'synapse') {
                    // Synapse Burnout - high damage brain fry
                    e.x += e.vx;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Electric arcs
                    for (let j = 0; j < 3; j++) {
                        particles.push({ x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 8, color: '#f0f', size: 3 });
                    }
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 35 && Math.abs(p.y - e.y) < 35) {
                            const dmg = e.dmg || 35;
                            p.hit(e.vx * 0.3, -15, dmg);
                            p.stun = 90;
                            sfx.play('break');
                            e.l = 0;
                            particles.push({ x: p.x, y: p.y, text: "🧠 BURNOUT!", life: 60, vy: -1, color: '#f0f' });
                        }
                    });
                } else if (e.t === 'contagion') {
                    // Contagion - poison DOT that spreads
                    e.x += e.vx;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 15 + Math.sin(e.l * 0.2) * 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Toxic particles
                    if (Math.random() < 0.5) {
                        particles.push({ x: e.x + (Math.random()-0.5)*30, y: e.y + (Math.random()-0.5)*30, vx: 0, vy: -1, life: 20, color: '#0f0', size: 4 });
                    }
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x - e.x) < 40 && Math.abs(p.y - e.y) < 40) {
                            // Apply poison status
                            if (!p.poisoned) {
                                p.poisoned = true;
                                p.poisonTimer = 180; // 3 seconds of poison
                                p.poisonOwner = e.owner;
                                particles.push({ x: p.x, y: p.y, text: "☠️ INFECTED", life: 60, vy: -1, color: '#0f0' });
                                sfx.play('break');
                            }
                        }
                    });
                } else if (e.t === 'missile') {
                    // Projectile Launch System missile
                    e.x += e.vx;
                    e.vy = (e.vy || 0) + 0.05; // Slight gravity
                    e.y += e.vy;
                    // Draw missile
                    ctx.fillStyle = '#ff4400';
                    ctx.fillRect(e.x - 6, e.y - 3, 12, 6);
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(e.vx > 0 ? e.x - 8 : e.x + 6, e.y - 2, 4, 4);
                    // Smoke trail
                    if (Math.random() < 0.7) {
                        particles.push({ x: e.x - e.vx * 0.5, y: e.y + (Math.random()-0.5)*6, vx: -e.vx * 0.05, vy: (Math.random()-0.5)*2, life: 15, color: '#888', size: 3 });
                    }
                    // Check collision with players
                    let missileHit = false;
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x + p.w/2 - e.x) < 30 && Math.abs(p.y + p.h/2 - e.y) < 30) {
                            missileHit = true;
                            const missileDmg = e.dmg || 15;
                            p.hit(e.vx * 0.3, -8, missileDmg);
                            sfx.play('break');
                            e.l = 0;
                        }
                    });
                    // Explosion on hit or timeout
                    if (missileHit || e.l <= 1) {
                        // AoE blast
                        players.forEach(p => {
                            if (p.stocks > 0 && p.id !== e.owner) {
                                const dist = Math.abs(p.x - e.x) + Math.abs(p.y - e.y);
                                if (dist < 120) {
                                    p.hit((p.x > e.x ? 5 : -5), -5, 8);
                                }
                            }
                        });
                        // Explosion VFX
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            particles.push({ x: e.x + Math.cos(angle)*15, y: e.y + Math.sin(angle)*15, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, life: 20, color: Math.random() > 0.5 ? '#ff4400' : '#ff0', size: 5 });
                        }
                        if (e.l > 1) e.l = 0;
                    }
                } else if (e.t === 'nyan_rainbow') {
                    // Nyan Storm rainbow projectile
                    e.y += e.vy || 6;
                    e.x += e.vx || 0;
                    // Draw rainbow streak
                    const rainbowColors = ['#FF0000','#FF7F00','#FFFF00','#00FF00','#0000FF','#8B00FF'];
                    for (let rc = 0; rc < 6; rc++) {
                        ctx.fillStyle = rainbowColors[rc];
                        ctx.fillRect(e.x - 12 + rc * 4, e.y - 8, 4, 16);
                    }
                    // Sparkle trail
                    if (Math.random() < 0.4) {
                        particles.push({
                            x: e.x + (Math.random()-0.5)*20, y: e.y - 10,
                            vx: (Math.random()-0.5)*2, vy: -Math.random()*2,
                            life: 12, color: rainbowColors[Math.floor(Math.random()*6)], size: 3
                        });
                    }
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x + p.w/2 - e.x) < 30 && Math.abs(p.y + p.h/2 - e.y) < 30) {
                            p.hit((Math.random()-0.5)*8, -8, 8);
                            sfx.play('hit');
                        }
                    });
                } else if (e.t === 'pride_bullet') {
                    // Pride Quick Draw bullet projectile
                    e.x += e.vx;
                    // Draw bullet trail
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(e.x - 4, e.y - 1, 8, 3);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(e.x - 2, e.y, 4, 1);
                    // Trail particle
                    if (Math.random() < 0.6) {
                        particles.push({ x: e.x - e.vx * 0.3, y: e.y + (Math.random()-0.5)*4, vx: 0, vy: 0, life: 8, color: '#ffaa33', size: 1 });
                    }
                    players.forEach(p => {
                        if (p.stocks > 0 && p.id !== e.owner && Math.abs(p.x + p.w/2 - e.x) < 25 && Math.abs(p.y + p.h/2 - e.y) < 25) {
                            const bulletDmg = e.dmg || 5;
                            p.hit(e.vx * 0.15, -2, bulletDmg);
                            sfx.play('hit');
                            e.l = 0;
                            // Impact sparks
                            for (let s = 0; s < 4; s++) {
                                particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 12, color: '#ffd700', size: 2 });
                            }
                        }
                    });
                }
                if (e.l <= 0) ultEffects.splice(i, 1);
            }
            players.forEach(atk => {
                if (atk.box && atk.box.act) {
                    let ax = atk.x + atk.box.relX,
                        ay = atk.y + atk.box.relY;
                    players.forEach(def => {
                        // Skip if same player, or same team in 2v2 mode (unless team attack enabled)
                        const sameTeam = (atk.team && def.team && atk.team === def.team);
                        const skipTeammate = sameTeam && !rulesTeamAttack;
                        if (def.stocks > 0 && atk.id !== def.id && !skipTeammate && ax < def.x + def.w && ax + atk.box.w > def.x && ay < def.y + def.h && ay + atk.box.h > def.y) {
                            let d = atk.dir ? 1 : -1;
                            // Mastery Lucky Block global buffs to all moves
                            let kbx = atk.box.kbx;
                            let kby = atk.box.kby;
                            let dmg = atk.box.dmg;
                            if (atk.masteryActive && atk.stats && atk.stats.id === 'luckyblock') {
                                kbx *= 1.2;
                                kby *= 1.15;
                                dmg *= 1.2;
                            }
                            // BERSERK: +50% damage when active
                            if (atk.berserkActive) {
                                dmg = Math.round(dmg * 1.5);
                                kbx *= 1.2;
                            }
                            // OPTICAL CAMO: First attack from stealth does 2x damage
                            if (atk.opticalCamoActive) {
                                dmg *= 2;
                                atk.opticalCamoActive = false;
                                atk.globalAlpha = 1;
                                particles.push({ x: atk.x + atk.w/2, y: atk.y, text: "🔪 STEALTH HIT", life: 30, vy: -2, color: '#0ff' });
                            }
                            if (atk.box.effect === 'stun') {
                                def.stun = 60;
                                sfx.play('break');
                                particles.push({ x: def.x + def.w / 2, y: def.y, text: "STUNPED", life: 60, vy: -1, color: '#0ff' });
                            }
                            def.hit(Math.abs(kbx) * d, kby, dmg);
                            atk.box.act = !1;
                            // COMBO COUNTER
                            if (atk.id === comboLastHitter || comboTimer <= 0) {
                                comboCount = (atk.id === comboLastHitter && comboTimer > 0) ? comboCount + 1 : 1;
                            } else {
                                comboCount = 1;
                            }
                            comboLastHitter = atk.id;
                            comboTimer = 90; // 1.5 sec combo window
                            if (comboCount > comboBestThisGame) comboBestThisGame = comboCount;
                            // ANNOUNCER HYPE
                            if (comboCount === 3) showAnnounce('NICE COMBO!', '#00ff88');
                            if (comboCount === 5) showAnnounce('UNSTOPPABLE!', '#ff0');
                            if (comboCount === 8) showAnnounce('GODLIKE!', '#f0f');
                            if (comboCount >= 10) showAnnounce('🔥 LEGENDARY! 🔥', '#ff4400');
                            if (dmg >= 30) showAnnounce('💥 HEAVY HIT!', '#ff3333');
                            if (def.pct > 100 && def.pct - dmg <= 100) showAnnounce('⚠️ DANGER ZONE!', '#ff0');
                        }
                    });
                }
            });
            let targetsArr = players.filter(p => p.stocks > 0);
            if (targetsArr.length === 0 && players[0]) targetsArr = [players[0]];
            let mx = 0,
                my = 0;
            if (targetsArr.length > 0) {
                mx = targetsArr.reduce((sum, p) => sum + p.x, 0) / targetsArr.length;
                my = targetsArr.reduce((sum, p) => sum + p.y, 0) / targetsArr.length;
            }
            let d = 0;
            if (targetsArr.length > 1) d = Math.sqrt(Math.pow(targetsArr[1].x - targetsArr[0].x, 2));
            let tz = Math.max(0.5, Math.min(1.2, 1000 / (d + 200)));
            if (targetsArr.length === 1) tz = 0.8;
            my = Math.max(my, -400);
            my = Math.min(my, 400);
            camera.x += (mx - camera.x) * 0.1;
            camera.y += (my - camera.y) * 0.1;
            camera.zoom += (tz - camera.zoom) * 0.05;
            // Online client: render-only
            if (isOnline && !isHost) {
                draw();
                requestAnimationFrame(loop);
                return;
            }
            // Host: broadcast state to client at ~30Hz
            if (isOnline && isHost && netPeerReady) {
                if ((netTick++ % 2) === 0) {
                    const snap = {
                        players: players.map(p => ({ x: p.x, y: p.y, vx: p.vx, vy: p.vy, pct: p.pct, stocks: p.stocks, ult: p.ult })),
                        score: [p1Score, p2Score]
                    };
                    if (isMemeBall && ball) {
                        snap.ball = { x: ball.x, y: ball.y, vx: ball.vx, vy: ball.vy, inPlay: ball.inPlay, cross: ball.hasCrossedNet };
                    }
                    sendNet({ t: 'state', s: snap });
                }
            }
            draw();
            requestAnimationFrame(loop);

        }
        function draw() {
            ctx.imageSmoothingEnabled = !1;
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            const scrollX = mapTimer * 0.2;
            for (let i = 0; i < backgrounds.length; i++) {
                const b = backgrounds[i];
                ctx.fillStyle = isSurvival ? 'rgba(255,100,100,0.1)' : 'rgba(255,255,255,0.1)';
                let bx = b.x - (camera.x * 0.2) - scrollX * b.sp;
                if (bx < -1500) b.x += 3000;
                let by = b.y - (camera.y * 0.1);
                ctx.beginPath();
                ctx.arc(400 + bx, 300 + by, b.s, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            // Night City neon background
            if (selectedMap && selectedMap.id === 'nightcity') {
                ctx.fillStyle = '#0a0015';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Distant neon buildings
                const buildingData = [
                    { x: 50, w: 60, h: 300, c: '#ff00ff' },
                    { x: 130, w: 80, h: 400, c: '#00ffff' },
                    { x: 230, w: 50, h: 250, c: '#ffff00' },
                    { x: 300, w: 100, h: 450, c: '#ff0088' },
                    { x: 420, w: 70, h: 320, c: '#00ff88' },
                    { x: 510, w: 90, h: 380, c: '#8800ff' },
                    { x: 620, w: 60, h: 280, c: '#ff4400' },
                    { x: 700, w: 80, h: 420, c: '#00ffff' }
                ];
                buildingData.forEach(b => {
                    const baseY = canvas.height - b.h;
                    ctx.fillStyle = '#111';
                    ctx.fillRect(b.x, baseY, b.w, b.h);
                    // Neon outline
                    ctx.strokeStyle = b.c;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = b.c;
                    ctx.shadowBlur = 15;
                    ctx.strokeRect(b.x, baseY, b.w, b.h);
                    // Windows
                    for (let wy = baseY + 15; wy < canvas.height - 20; wy += 25) {
                        for (let wx = b.x + 10; wx < b.x + b.w - 10; wx += 15) {
                            ctx.fillStyle = Math.random() > 0.3 ? b.c : '#222';
                            ctx.fillRect(wx, wy, 8, 10);
                        }
                    }
                });
                ctx.shadowBlur = 0;
                // Holographic ad (animated text-like effect)
                const adY = 100 + Math.sin(mapTimer * 0.05) * 10;
                ctx.fillStyle = `rgba(255, 0, 128, ${0.5 + Math.sin(mapTimer * 0.1) * 0.3})`;
                ctx.font = "bold 24px 'Press Start 2P', monospace";
                ctx.shadowColor = '#ff0088';
                ctx.shadowBlur = 20;
                ctx.fillText('NIGHT CITY', 280, adY);
                ctx.shadowBlur = 0;
            }
            // Badlands desert background
            if (selectedMap && selectedMap.id === 'badlands') {
                // Desert sky gradient
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, '#1a0800');
                grad.addColorStop(0.4, '#5c2800');
                grad.addColorStop(0.7, '#8b4513');
                grad.addColorStop(1, '#3d1f00');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Sand dunes
                ctx.fillStyle = '#5c3a1a';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 80);
                for (let x = 0; x <= canvas.width; x += 40) {
                    ctx.lineTo(x, canvas.height - 80 + Math.sin(x * 0.015 + mapTimer * 0.01) * 20);
                }
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.fill();
                // Distant industrial ruins
                const ruins = [{x: 80, h: 120}, {x: 200, h: 80}, {x: 350, h: 150}, {x: 500, h: 60}, {x: 600, h: 100}, {x: 720, h: 130}];
                ruins.forEach(r => {
                    ctx.fillStyle = '#2a1500';
                    ctx.fillRect(r.x, canvas.height - 80 - r.h, 40, r.h);
                    // Rust glow
                    ctx.fillStyle = 'rgba(255, 80, 0, 0.15)';
                    ctx.fillRect(r.x - 2, canvas.height - 80 - r.h - 2, 44, r.h + 4);
                });
                // Dust particles
                for (let i = 0; i < 5; i++) {
                    const dx = (mapTimer * 0.5 + i * 170) % canvas.width;
                    const dy = 100 + Math.sin(mapTimer * 0.02 + i) * 50;
                    ctx.fillStyle = 'rgba(210, 150, 80, 0.3)';
                    ctx.beginPath();
                    ctx.arc(dx, dy, 2 + Math.sin(i) * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                // BADLANDS text
                ctx.fillStyle = `rgba(210, 120, 40, ${0.4 + Math.sin(mapTimer * 0.08) * 0.2})`;
                ctx.font = "bold 20px 'Press Start 2P', monospace";
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 10;
                ctx.fillText('THE BADLANDS', 260, 60);
                ctx.shadowBlur = 0;
            }
            // Arasaka District background
            if (selectedMap && selectedMap.id === 'arasaka_district') {
                ctx.fillStyle = '#040018';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Massive corp buildings
                const corpBuildings = [
                    {x: 30, w: 100, h: 450, c: '#ff0044'}, {x: 150, w: 70, h: 350, c: '#00ffff'},
                    {x: 240, w: 120, h: 500, c: '#ff0044'}, {x: 380, w: 80, h: 380, c: '#ffffff'},
                    {x: 480, w: 110, h: 480, c: '#ff0044'}, {x: 610, w: 90, h: 420, c: '#00ffff'},
                    {x: 720, w: 80, h: 360, c: '#ff0044'}
                ];
                corpBuildings.forEach(b => {
                    const baseY = canvas.height - b.h;
                    ctx.fillStyle = '#0a0a18';
                    ctx.fillRect(b.x, baseY, b.w, b.h);
                    ctx.strokeStyle = b.c;
                    ctx.lineWidth = 1;
                    ctx.shadowColor = b.c;
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(b.x, baseY, b.w, b.h);
                    // Arasaka logo windows (red pattern)
                    for (let wy = baseY + 20; wy < canvas.height - 30; wy += 30) {
                        for (let wx = b.x + 8; wx < b.x + b.w - 8; wx += 12) {
                            ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,0,68,0.6)' : '#111';
                            ctx.fillRect(wx, wy, 6, 12);
                        }
                    }
                });
                ctx.shadowBlur = 0;
                // Arasaka logo text
                ctx.fillStyle = '#ff0044';
                ctx.font = "bold 28px 'Press Start 2P', monospace";
                ctx.shadowColor = '#ff0044';
                ctx.shadowBlur = 30;
                ctx.fillText('ARASAKA', 270, 70);
                ctx.font = "12px 'Press Start 2P', monospace";
                ctx.fillStyle = '#888';
                ctx.fillText('CORPO DISTRICT', 280, 95);
                ctx.shadowBlur = 0;
                // Floating data streams
                for (let i = 0; i < 8; i++) {
                    const sx = (i * 110 + mapTimer * 0.3) % canvas.width;
                    const sy = (mapTimer * 0.8 + i * 80) % canvas.height;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
                    ctx.fillRect(sx, sy, 2, 20);
                }
            }
            // Arasaka Tower Top background
            if (selectedMap && selectedMap.id === 'arasaka_tower') {
                // Dark dramatic sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGrad.addColorStop(0, '#000000');
                skyGrad.addColorStop(0.3, '#0a0008');
                skyGrad.addColorStop(0.6, '#1a0020');
                skyGrad.addColorStop(1, '#0a0008');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // City lights far below
                for (let i = 0; i < 50; i++) {
                    const lx = (i * 17 + 5) % canvas.width;
                    const ly = canvas.height - 20 - Math.random() * 40;
                    const colors = ['#ff0044', '#00ffff', '#ffff00', '#ff00ff', '#00ff88'];
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.globalAlpha = 0.2 + Math.sin(mapTimer * 0.05 + i) * 0.15;
                    ctx.fillRect(lx, ly, 3, 3);
                }
                ctx.globalAlpha = 1;
                // Tower antenna/spire
                ctx.strokeStyle = '#ff0044';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ff0044';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, canvas.height - 60);
                ctx.lineTo(canvas.width / 2, 30);
                ctx.stroke();
                // Blinking red light at top
                ctx.fillStyle = Math.sin(mapTimer * 0.1) > 0 ? '#ff0044' : '#440011';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, 25, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // ARASAKA TOWER text
                ctx.fillStyle = '#ff0044';
                ctx.font = "bold 22px 'Press Start 2P', monospace";
                ctx.shadowColor = '#ff0044';
                ctx.shadowBlur = 25;
                ctx.fillText('ARASAKA TOWER', 230, 70);
                ctx.font = "10px 'Press Start 2P', monospace";
                ctx.fillStyle = `rgba(255, 0, 68, ${0.5 + Math.sin(mapTimer * 0.1) * 0.3})`;
                ctx.fillText('FINAL FLOOR', 310, 90);
                ctx.shadowBlur = 0;
                // Lightning flashes
                if (Math.random() < 0.005) {
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
            // ====== BACKROOMS BACKGROUND ======
            if (selectedMap && selectedMap.id === 'backrooms') {
                // Sickly yellow fluorescent glow
                const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGrad.addColorStop(0, '#c4b078');
                bgGrad.addColorStop(0.5, '#b5a060');
                bgGrad.addColorStop(1, '#9e8c50');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Repeating wall pattern
                ctx.strokeStyle = '#a89860';
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += 80) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += 60) {
                    ctx.beginPath();
                    ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                // Flickering fluorescent lights
                const flickerAlpha = 0.3 + Math.sin(mapTimer * 0.15) * 0.1 + (Math.random() < 0.05 ? 0.3 : 0);
                for (let lx = 60; lx < canvas.width; lx += 160) {
                    ctx.fillStyle = `rgba(255, 255, 200, ${flickerAlpha})`;
                    ctx.fillRect(lx - 30, 20, 60, 8);
                    // Light cone
                    ctx.fillStyle = `rgba(255, 255, 180, ${flickerAlpha * 0.15})`;
                    ctx.beginPath();
                    ctx.moveTo(lx - 30, 28); ctx.lineTo(lx + 30, 28);
                    ctx.lineTo(lx + 80, canvas.height); ctx.lineTo(lx - 80, canvas.height);
                    ctx.fill();
                }
                // Damp stain patches
                ctx.fillStyle = 'rgba(120, 100, 50, 0.15)';
                ctx.fillRect(200, 150, 80, 40);
                ctx.fillRect(500, 250, 60, 30);
                ctx.fillRect(50, 300, 90, 50);
                // "LEVEL 0" text
                ctx.fillStyle = 'rgba(80, 70, 40, 0.4)';
                ctx.font = "bold 16px monospace";
                ctx.fillText('LEVEL 0', 20, canvas.height - 20);
                // Occasional glitch
                if (Math.random() < 0.01) {
                    ctx.fillStyle = 'rgba(200, 180, 100, 0.1)';
                    ctx.fillRect(0, Math.random() * canvas.height, canvas.width, 3);
                }
            }
            // ====== SPACE BACKGROUND ======
            if (selectedMap && selectedMap.id === 'space') {
                // Deep space gradient
                ctx.fillStyle = '#000010';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Stars (deterministic based on position for consistency)
                for (let i = 0; i < 80; i++) {
                    const sx = (i * 37 + 13) % canvas.width;
                    const sy = (i * 53 + 7) % canvas.height;
                    const brightness = 0.3 + Math.sin(mapTimer * 0.03 + i * 0.7) * 0.3;
                    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    ctx.fillRect(sx, sy, i % 3 === 0 ? 2 : 1, i % 3 === 0 ? 2 : 1);
                }
                // Nebula glow
                const nebX = canvas.width * 0.7;
                const nebY = canvas.height * 0.3;
                const nebGrad = ctx.createRadialGradient(nebX, nebY, 10, nebX, nebY, 150);
                nebGrad.addColorStop(0, 'rgba(100, 0, 200, 0.15)');
                nebGrad.addColorStop(0.5, 'rgba(50, 0, 150, 0.08)');
                nebGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = nebGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Planet in background
                ctx.fillStyle = '#1a3060';
                ctx.beginPath();
                ctx.arc(120, canvas.height - 100, 60, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#2a4080';
                ctx.beginPath();
                ctx.arc(120, canvas.height - 100, 60, 0.3, 2.8);
                ctx.fill();
                // Planet ring
                ctx.strokeStyle = 'rgba(150, 180, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(120, canvas.height - 100, 90, 20, 0.3, 0, Math.PI * 2);
                ctx.stroke();
                // "DEEP SPACE" text
                ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.font = "bold 14px monospace";
                ctx.fillText('DEEP SPACE', canvas.width - 140, 30);
            }
            // ====== MINECRAFT BACKGROUND ======
            if (selectedMap && selectedMap.id === 'minecraft') {
                // Minecraft sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGrad.addColorStop(0, '#7ec8e3');
                skyGrad.addColorStop(0.6, '#a8d8ea');
                skyGrad.addColorStop(1, '#87ceeb');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Blocky clouds
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 5; i++) {
                    const cx = ((mapTimer * 0.3 + i * 180) % (canvas.width + 200)) - 100;
                    const cy = 30 + i * 25;
                    ctx.fillRect(cx, cy, 60, 15);
                    ctx.fillRect(cx + 10, cy - 10, 40, 10);
                    ctx.fillRect(cx - 15, cy + 5, 20, 10);
                }
                // Distant blocky mountains
                ctx.fillStyle = '#5b8731';
                for (let bx = 0; bx < canvas.width; bx += 30) {
                    const bh = 40 + Math.sin(bx * 0.05) * 25 + Math.cos(bx * 0.03) * 15;
                    ctx.fillRect(bx, canvas.height - 60 - bh, 30, bh);
                }
                // Dirt layer
                ctx.fillStyle = '#8B6914';
                ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                // Grass top
                ctx.fillStyle = '#5b8731';
                ctx.fillRect(0, canvas.height - 62, canvas.width, 5);
                // Pixel sun
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(canvas.width - 80, 30, 20, 20);
                ctx.fillRect(canvas.width - 70, 20, 20, 40);
                ctx.fillRect(canvas.width - 90, 30, 40, 20);
                // Trees in background
                for (let tx = 0; tx < canvas.width; tx += 150) {
                    // Trunk
                    ctx.fillStyle = '#6b4423';
                    ctx.fillRect(tx + 65, canvas.height - 120, 15, 60);
                    // Leaves (blocky)
                    ctx.fillStyle = '#2d7a1e';
                    ctx.fillRect(tx + 45, canvas.height - 160, 55, 15);
                    ctx.fillRect(tx + 50, canvas.height - 175, 45, 15);
                    ctx.fillRect(tx + 55, canvas.height - 190, 35, 15);
                }
            }
            if (isTraining) {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 50) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }
                for (let y = 0; y < canvas.height; y += 50) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }
                ctx.stroke();
            }
            ctx.save();
            ctx.imageSmoothingEnabled = !1;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            if (worldFlipped) ctx.rotate(Math.PI);
            if (shake > 0) {
                ctx.translate(Math.random() * shake - shake / 2, Math.random() * shake - shake / 2);
                shake *= 0.9;
            }
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);
            platforms.forEach(p => {
                if (p.t.startsWith('machine')) {
                    ctx.save();
                    ctx.translate(p.pivotX, p.pivotY);
                    ctx.rotate(p.angle);
                    let drawX = p.x - p.pivotX;
                    ctx.fillStyle = p.c;
                    ctx.fillRect(drawX, 0, p.w, p.h);
                    ctx.restore();
                } else {
                    ctx.fillStyle = p.c;
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                }
            });
            items.forEach(i => i.draw());
            targets.forEach(t => {
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(t.x + 20, t.y + 20, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(t.x + 20, t.y + 20, 10, 0, Math.PI * 2);
                ctx.fill()
            });
            ultEffects.forEach(e => {
                if (e.t === 'moon') {
                    ctx.font = "200px Arial";
                    ctx.fillText('🌚', e.x - 100, e.y)
                } else if (e.t === 'tear') {
                    ctx.fillStyle = '#3498db';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 10, 0, Math.PI * 2);
                    ctx.fill()
                } else if (e.t === 'primo') {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    if (e.vx < 0) ctx.scale(-1, 1);
                    const sprite = characterSprites['primo'];
                    if (sprite) {
                        ctx.drawImage(sprite, -25, -25, 50, 50);
                    } else {
                        ctx.font = "50px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText('🧱', 0, 0);
                    }
                    ctx.restore();
                } else if (e.t === 'pork') {
                    ctx.font = "200px Arial";
                    ctx.fillText('🐖', e.x - 100, e.y);
                }
            });
            
            // Draw David's Sandy RED AFTERIMAGES (anime style - no ctx.filter for performance)
            davidSandyAfterimages.forEach(ghost => {
                ctx.save();
                ctx.globalAlpha = ghost.alpha * 0.5;
                const spriteData = characterSprites[ghost.charId];
                const drawX = ghost.x + ghost.w/2;
                const drawY = ghost.y + ghost.h/2;
                ctx.translate(drawX, drawY);
                if (!ghost.dir) ctx.scale(-1, 1);
                if (spriteData && spriteData.idle) {
                    const anim = spriteData[ghost.animation] || spriteData['idle'];
                    const frame = anim ? anim[ghost.frame % anim.length] : null;
                    if (frame) {
                        ctx.drawImage(frame, -ghost.w/2, -ghost.h/2, ghost.w, ghost.h);
                    }
                } else if (spriteData) {
                    ctx.drawImage(spriteData, -ghost.w/2, -ghost.h/2, ghost.w, ghost.h);
                }
                // Red overlay on the ghost silhouette
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = '#ff003c';
                ctx.fillRect(-ghost.w/2, -ghost.h/2, ghost.w, ghost.h);
                ctx.restore();
            });
            
            players.forEach(p => p.draw());
            
            // RED SCREEN TINT when David's Sandy is active (anime style)
            const sandyActive = players.some(p => p.davidSandyActive);
            if (sandyActive) {
                ctx.save();
                ctx.globalAlpha = 0.1 + Math.sin(Date.now() * 0.008) * 0.05;
                ctx.fillStyle = '#ff003c';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
            
            if (isMemeBall && ball) ball.draw();

            // Draw serve indicator
            if (isMemeBall && isServing) {
                const server = players.find(p => p.id === servingPlayer);
                if (server) {
                    ctx.save();
                    ctx.font = "20px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    // Serve prompt
                    ctx.fillStyle = '#ff0';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    const promptY = server.y - 120;
                    ctx.strokeText('HOLD TO CHARGE', server.x, promptY);
                    ctx.fillText('HOLD TO CHARGE', server.x, promptY);

                    // Power bar
                    if (serveCharge > 0) {
                        const barW = 100;
                        const barH = 10;
                        const barX = server.x - barW / 2;
                        const barY = server.y - 100;

                        // Background
                        ctx.fillStyle = '#333';
                        ctx.fillRect(barX, barY, barW, barH);

                        // Power fill
                        const powerColor = serveCharge < 50 ? '#0f0' : serveCharge < 80 ? '#ff0' : '#f00';
                        ctx.fillStyle = powerColor;
                        ctx.fillRect(barX, barY, (serveCharge / 100) * barW, barH);

                        // Border
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(barX, barY, barW, barH);
                    }

                    ctx.restore();
                }
            }

            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life / 60;
                if (p.text) {
                    ctx.fillStyle = 'red';
                    ctx.font = "bold 30px 'Black Ops One'";
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 5;
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                }
                ctx.restore();
            });
            // Draw quickhack menu on target (in world coords)
            drawQuickhackMenu(ctx);
            if (gameState === 'GAMEOVER') {
                confetti.forEach(c => {
                    c.x += c.vx;
                    c.y += c.vy;
                    c.vy += 0.5;
                    ctx.fillStyle = c.c;
                    ctx.fillRect(c.x, c.y, 10, 10);
                });
            }
            ctx.restore();
            // ====== COMBO COUNTER HUD (screen space) ======
            if (comboCount >= 2) {
                const comboAlpha = Math.min(1, comboTimer / 30);
                ctx.save();
                ctx.globalAlpha = comboAlpha;
                const comboSize = Math.min(40, 20 + comboCount * 2);
                ctx.font = `bold ${comboSize}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'right';
                const comboColors = comboCount >= 10 ? '#ff4400' : comboCount >= 8 ? '#f0f' : comboCount >= 5 ? '#ff0' : comboCount >= 3 ? '#00ff88' : '#fff';
                ctx.fillStyle = comboColors;
                ctx.shadowColor = comboColors;
                ctx.shadowBlur = 15;
                ctx.fillText(`${comboCount}x COMBO`, canvas.width - 20, 80);
                ctx.shadowBlur = 0;
                ctx.font = "12px monospace";
                ctx.fillStyle = '#aaa';
                ctx.fillText(`Best: ${comboBestThisGame}x`, canvas.width - 20, 100);
                ctx.restore();
            }
            // ====== ANNOUNCER HUD (screen space) ======
            if (announceTimer > 0) {
                ctx.save();
                const scale = announceTimer > 100 ? 1 + (120 - announceTimer) * 0.03 : 1;
                ctx.globalAlpha = Math.min(1, announceTimer / 30);
                ctx.translate(canvas.width / 2, 140);
                ctx.scale(scale, scale);
                ctx.font = "bold 36px 'Press Start 2P', monospace";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = announceColor;
                ctx.shadowColor = announceColor;
                ctx.shadowBlur = 25;
                ctx.fillText(announceText, 0, 0);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            // ====== WEATHER EFFECTS (screen space) ======
            if (weatherType === 'rain') {
                ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
                for (let i = 0; i < 30; i++) {
                    const rx = (mapTimer * 3 + i * 53) % canvas.width;
                    const ry = (mapTimer * 8 + i * 97) % canvas.height;
                    ctx.fillRect(rx, ry, 1, 8);
                }
                // Rain affects friction
            } else if (weatherType === 'snow') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 25; i++) {
                    const sx = (mapTimer * 0.5 + i * 67 + Math.sin(mapTimer * 0.02 + i) * 30) % canvas.width;
                    const sy = (mapTimer * 2 + i * 83) % canvas.height;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2 + (i % 3), 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (weatherType === 'wind') {
                // Horizontal wind lines
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 15; i++) {
                    const wy = (i * 41 + 20) % canvas.height;
                    const wx = (mapTimer * 5 + i * 120) % (canvas.width + 200) - 100;
                    ctx.beginPath();
                    ctx.moveTo(wx, wy); ctx.lineTo(wx + 40 + i * 3, wy);
                    ctx.stroke();
                }
            } else if (weatherType === 'meteor') {
                // Falling fireballs (visual only, they do damage too)
                if (mapTimer % 20 === 0 && Math.random() < 0.3) {
                    ultEffects.push({
                        t: 'nyan_rainbow', // Reuse rainbow projectile handler for visual impact
                        x: -400 + Math.random() * 800,
                        y: -500,
                        vx: (Math.random() - 0.5) * 2,
                        vy: 8 + Math.random() * 4,
                        l: 80,
                        owner: 0 // No owner - hits everyone
                    });
                }
                ctx.fillStyle = 'rgba(255, 80, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height * 0.15);
            }
        }
        function drawShop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const pb = document.getElementById('shop-right');
            if (pb) {
                const r = pb.getBoundingClientRect();
                const cx = r.left + r.width / 2;
                const cy = r.top + r.height / 2 - 50;
                ctx.save();
                ctx.imageSmoothingEnabled = !1;
                ctx.translate(cx, cy);
                ctx.scale(5, 5);
                const c = CHARACTERS[shopCharIndex];
                const sprite = characterSprites[c.id];
                if (saveData.goldMode) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.shadowBlur = 0;
                }
                if (sprite && sprite.idle) {
                    ctx.drawImage(sprite.idle[0], -25, -25, 50, 50);
                } else if (sprite) {
                    ctx.drawImage(sprite, -25, -25, 50, 50);
                } else {
                    ctx.font = "50px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(c.icon, 0, 0);
                }
                if (saveData.goldMode) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                    if (sprite && sprite.idle) {
                        ctx.drawImage(sprite.idle[0], -25, -25, 50, 50);
                    } else if (sprite) {
                        ctx.drawImage(sprite, -25, -25, 50, 50);
                    }
                }
                ctx.shadowBlur = 0;
                let cos = equippedCosmetic;
                if (shopSelectedItem && shopSelectedItem.type === 'cosmetic') cos = shopSelectedItem.id;
                ctx.fillStyle = 'white';
                ctx.font = "30px Arial";
                if (cos === 'tophat') ctx.fillText('🎩', 0, -30);
                if (cos === 'shades') ctx.fillText('🕶️', 5, 0);
                if (cos === 'crown') ctx.fillText('👑', 0, -35);
                ctx.restore();
            }
        }
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = !1;
        }
        window.addEventListener('resize', resize);
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            const b = (id, k) => {
                const e = document.getElementById(id);
                e.addEventListener('touchstart', e => {
                    e.preventDefault();
                    touchInput[k] = !0
                });
                e.addEventListener('touchend', e => {
                    e.preventDefault();
                    touchInput[k] = !1
                })
            };
            b('btn-left', 'left');
            b('btn-right', 'right');
            b('btn-up', 'up');
            b('btn-down', 'down');
            b('btn-atk', 'atk');
            b('btn-jump', 'jump');
            b('btn-ult', 'ult');
            b('btn-shield', 'shield');
        }
        let pendingScreenshot = null;

        function openFeedback() {
            // Capture screenshot before hiding other screens
            try {
                pendingScreenshot = canvas.toDataURL('image/jpeg', 0.5);
                document.getElementById('screenshot-preview').style.backgroundImage = `url(${pendingScreenshot})`;
            } catch (e) {
                console.error("Screenshot failed", e);
                pendingScreenshot = null;
                document.getElementById('screenshot-preview').style.backgroundImage = 'none';
            }

            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById('feedback-screen').classList.remove('hidden');
            document.getElementById('feedback-status').innerText = '';
            document.getElementById('feedback-list').classList.add('hidden');
        }

        function closeFeedback() {
            document.getElementById('feedback-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        }

        function submitFeedback() {
            const text = document.getElementById('feedback-text').value;
            if (!text.trim()) return;

            const includeScreenshot = document.getElementById('include-screenshot').checked;

            // Save to local storage for now
            let feedbacks = JSON.parse(localStorage.getItem('smash_feedback') || '[]');
            feedbacks.push({
                date: new Date().toLocaleString(),
                text: text,
                image: includeScreenshot ? pendingScreenshot : null
            });
            localStorage.setItem('smash_feedback', JSON.stringify(feedbacks));

            document.getElementById('feedback-text').value = '';
            document.getElementById('feedback-status').innerText = 'FEEDBACK SENT! THANK YOU!';
            document.getElementById('feedback-status').style.color = '#2ecc71';

            setTimeout(() => {
                document.getElementById('feedback-status').innerText = '';
            }, 3000);
        }

        // Global Cheat Codes
        let cheatInput = '';
        const moneyCheat = 'money';

        window.addEventListener('keydown', (e) => {
            if (typeof gameState !== 'undefined' && gameState === 'TITLE') {
                // Ignore non-character keys
                if (e.key.length > 1) return;

                cheatInput += e.key.toLowerCase();
                if (cheatInput.length > 20) cheatInput = cheatInput.slice(-20);

                if (cheatInput.endsWith(moneyCheat)) {
                    saveData.coins += 100000;
                    saveGame();
                    sfx.play('coin');
                    showNotification("CHEAT ACTIVATED", "100,000 COINS ADDED");
                    cheatInput = '';
                    // Inline update since updateCoinDisplay might not exist
                    if (document.getElementById('coin-count')) {
                        document.getElementById('coin-count').innerText = saveData.coins;
                    }
                }
            }
        });

        // Cheat Code: "feedback"
        let feedbackCheatInput = '';
        const feedbackCheatCode = 'feedback';

        window.addEventListener('keydown', (e) => {
            // Only listen if feedback screen is open
            if (document.getElementById('feedback-screen').classList.contains('hidden')) return;

            // Ignore non-character keys to keep it simple
            if (e.key.length > 1) return;

            feedbackCheatInput += e.key.toLowerCase();
            if (feedbackCheatInput.length > feedbackCheatCode.length) {
                feedbackCheatInput = feedbackCheatInput.slice(-feedbackCheatCode.length);
            }

            if (feedbackCheatInput === feedbackCheatCode) {
                showFeedbackList();
                feedbackCheatInput = '';
            }
        });

        function showFeedbackList() {
            const list = document.getElementById('feedback-list');
            list.classList.remove('hidden');
            list.innerHTML = '';

            const feedbacks = JSON.parse(localStorage.getItem('smash_feedback') || '[]');
            if (feedbacks.length === 0) {
                list.innerHTML = '<div style="color: #aaa; text-align: center;">NO FEEDBACK YET</div>';
                return;
            }

            feedbacks.reverse().forEach(f => {
                const item = document.createElement('div');
                item.style.borderBottom = '1px solid #444';
                item.style.padding = '10px';
                item.style.marginBottom = '10px';

                let imgHtml = '';
                if (f.image) {
                    imgHtml = `<img src="${f.image}" style="max-width: 100%; border: 1px solid #555; margin-top: 10px; border-radius: 4px;">`;
                }

                item.innerHTML = `
            <div style="color: #888; font-size: 10px; margin-bottom: 5px;">${f.date}</div>
            <div style="color: #fff; white-space: pre-wrap;">${f.text}</div>
            ${imgHtml}
        `;
                list.appendChild(item);
            });
        }

        loadGame();
        resize();
    </script>
</body>

</html>